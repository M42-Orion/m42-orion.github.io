<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RAG-什么是chunking</title>
    <url>/2025/02/15/RAG-%E4%BB%80%E4%B9%88%E6%98%AFchunking/</url>
    <content><![CDATA[<h3 id="什么是-Chunking？"><a href="#什么是-Chunking？" class="headerlink" title="什么是 Chunking？"></a>什么是 Chunking？</h3><p>在自然语言处理（NLP）和文本分析领域，<strong>Chunking</strong>（分块）是一种将文本分割成有意义的、可管理的片段的技术。这些片段通常被称为“块”（chunks），可以是短语、句子、段落或其他有意义的语言单元。Chunking 的目标是从文本中提取出结构化的信息，以便更好地理解和处理语言数据。</p>
<h4 id="Chunking-的基本概念"><a href="#Chunking-的基本概念" class="headerlink" title="Chunking 的基本概念"></a>Chunking 的基本概念</h4><p>Chunking 的核心思想是将连续的文本分割成更小的、有意义的单元。与简单的分词（tokenization）不同，Chunking 不仅仅是把文本拆分成单词，而是将这些单词组合成更大的语义单元。例如，在句子“The quick brown fox jumps over the lazy dog”中，Chunking 可能会将“The quick brown fox”识别为一个名词短语（NP），而“jumps over the lazy dog”识别为一个动词短语（VP）。</p>
<h4 id="Chunking-的应用场景"><a href="#Chunking-的应用场景" class="headerlink" title="Chunking 的应用场景"></a>Chunking 的应用场景</h4><ol>
<li><p><strong>信息提取</strong>：<br>Chunking 可以帮助从文本中提取出关键信息，如人名、地名、日期、组织机构等。例如，在新闻文章中，Chunking 可以用于识别出事件的主角、地点和时间。</p>
</li>
<li><p><strong>语法分析</strong>：<br>在句法分析中，Chunking 是构建句法树的重要步骤。通过将句子分割成短语，可以更好地理解句子的结构和语法关系。</p>
</li>
<li><p><strong>机器翻译</strong>：<br>在机器翻译中，Chunking 可以帮助识别出源语言中的短语结构，从而生成更准确的目标语言翻译。</p>
</li>
<li><p><strong>问答系统</strong>：<br>在问答系统中，Chunking 可以用于识别问题中的关键短语，从而更准确地匹配答案。</p>
</li>
<li><p><strong>文本摘要</strong>：<br>Chunking 可以帮助识别文本中的重要信息，从而生成简洁的摘要。</p>
</li>
</ol>
<h4 id="Chunking-的技术实现"><a href="#Chunking-的技术实现" class="headerlink" title="Chunking 的技术实现"></a>Chunking 的技术实现</h4><p>Chunking 的实现通常依赖于自然语言处理工具和算法。以下是一些常用的方法：</p>
<ol>
<li><p><strong>规则-based 方法</strong>：<br>这种方法依赖于预定义的语法规则和模式来识别文本中的块。例如，可以使用正则表达式来匹配名词短语或动词短语。</p>
</li>
<li><p><strong>统计-based 方法</strong>：<br>这种方法使用机器学习算法来训练模型，以识别文本中的块。常用的算法包括隐马尔可夫模型（HMM）、条件随机场（CRF）等。</p>
</li>
<li><p><strong>深度学习-based 方法</strong>：<br>近年来，深度学习技术在 Chunking 中也得到了广泛应用。例如，可以使用循环神经网络（RNN）或 Transformer 模型来识别文本中的块。</p>
</li>
</ol>
<h4 id="Chunking-的挑战"><a href="#Chunking-的挑战" class="headerlink" title="Chunking 的挑战"></a>Chunking 的挑战</h4><p>尽管 Chunking 在文本处理中具有广泛的应用，但它也面临一些挑战：</p>
<ol>
<li><p><strong>语言的多样性</strong>：<br>不同语言的语法结构和表达方式差异很大，这使得 Chunking 在多语言环境中的实现变得复杂。</p>
</li>
<li><p><strong>歧义性</strong>：<br>自然语言中存在大量的歧义，同一个词或短语在不同的上下文中可能具有不同的含义。这使得 Chunking 的准确性受到影响。</p>
</li>
<li><p><strong>长距离依赖</strong>：<br>在某些情况下，文本中的块可能跨越多个句子或段落，这使得 Chunking 的识别变得更加困难。</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Chunking 是自然语言处理中的一项重要技术，它通过将文本分割成有意义的块，帮助我们从文本中提取出结构化的信息。无论是在信息提取、语法分析、机器翻译还是问答系统中，Chunking 都发挥着关键作用。尽管面临一些挑战，但随着技术的不断进步，Chunking 的准确性和应用范围将会进一步提升。</p>
<p>通过理解和掌握 Chunking 技术，我们可以更好地处理和分析文本数据，从而为各种 NLP 应用提供强有力的支持。</p>
]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>RAG</tag>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>RAG-python库Chonkie的使用</title>
    <url>/2025/02/15/RAG-python%E5%BA%93Chonkie%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="使用-Python-库-Chonkie-快速上手"><a href="#使用-Python-库-Chonkie-快速上手" class="headerlink" title="使用 Python 库 Chonkie 快速上手"></a>使用 Python 库 Chonkie 快速上手</h2><p>在自然语言处理（NLP）领域，文本分块（chunking）是一种常见的任务，它将长文本分割成更小的块，以便于后续处理和分析。无论是构建 RAG（Retrieve-Augment-Generate）模型，还是进行大规模文本处理，分块都是一项基础且关键的步骤。然而，现有的许多分块工具要么功能过于复杂，要么过于简陋，难以满足开发者的实际需求。<br>幸运的是，现在有了 Chonkie —— 一个简单易用的 Python 库，它专注于提供高效且灵活的文本分块解决方案。本文将详细介绍如何使用 Chonkie 快速上手文本分块，并通过几个实际示例展示其强大的功能。</p>
<h2 id="什么是-Chonkie？"><a href="#什么是-Chonkie？" class="headerlink" title="什么是 Chonkie？"></a>什么是 Chonkie？</h2><p>Chonkie 是一个轻量级的 Python 库，旨在简化文本分块的过程。它提供了多种分块策略，包括基于句子的分块、递归分块、语义分块和双通道合并分块等，能够满足不同场景下的需求。Chonkie 的设计目标是简单、高效且易于扩展，让开发者能够专注于核心业务逻辑，而不是被复杂的分块逻辑所困扰。<br>安装 Chonkie<br>在开始之前，您需要先安装 Chonkie。可以通过以下命令快速安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install chonkie</span><br></pre></td></tr></table></figure>
<p>示例文本<br>为了更好地展示 Chonkie 的功能，我们将使用以下示例文本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&#x27;&#x27;&#x27;团圆年｜且行且思谋新篇</span></span><br><span class="line"><span class="string">编者按：春节，是中华民族传统节日，是万家团圆、辞旧迎新的日子。新时代以来，每到年味渐浓之时，习近平总书记都会深入到群众当中，问冷暖送祝福、听民声解民忧。值此辞旧迎新之际，央视网推出系列特稿，与您一起循着总书记新春足迹，感悟深厚的人民情怀。</span></span><br><span class="line"><span class="string">在中国传统文化中，春节是一年之始，也是万象更新的时刻。每年春节前夕走基层，习近平总书记总是一路调研、一路思索，为各地发展部署谋划。</span></span><br><span class="line"><span class="string">为乡村振兴谋新篇&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="句子分块器（SentenceChunker）"><a href="#句子分块器（SentenceChunker）" class="headerlink" title="句子分块器（SentenceChunker）"></a>句子分块器（SentenceChunker）</h2><p>句子分块器将文本拆分为多个块，同时保留完整的句子边界。这对于需要保持句子完整性的任务非常有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> SentenceChunker</span><br><span class="line"></span><br><span class="line">chunker = SentenceChunker(</span><br><span class="line">    tokenizer=<span class="string">&quot;gpt2&quot;</span>,  <span class="comment"># 使用 GPT-2 分词器</span></span><br><span class="line">    chunk_size=<span class="number">512</span>,    <span class="comment"># 每个块的最大字符数</span></span><br><span class="line">    chunk_overlap=<span class="number">128</span>, <span class="comment"># 块之间的重叠字符数</span></span><br><span class="line">    min_sentences_per_chunk=<span class="number">1</span>  <span class="comment"># 每个块最少包含的句子数</span></span><br><span class="line">)</span><br><span class="line">chunks = chunker.chunk(text)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文本块内容: <span class="subst">&#123;chunk.text&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;令牌数量: <span class="subst">&#123;chunk.token_count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;句子数量: <span class="subst">&#123;<span class="built_in">len</span>(chunk.sentences)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="递归分块器（RecursiveChunker）"><a href="#递归分块器（RecursiveChunker）" class="headerlink" title="递归分块器（RecursiveChunker）"></a>递归分块器（RecursiveChunker）</h2><p>递归分块器以递归方式将文档分块为较小的块，适用于结构良好的长文档。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> RecursiveChunker, RecursiveRules</span><br><span class="line"></span><br><span class="line">chunker = RecursiveChunker(</span><br><span class="line">    tokenizer=<span class="string">&quot;gpt2&quot;</span>,  <span class="comment"># 使用 GPT-2 分词器</span></span><br><span class="line">    chunk_size=<span class="number">512</span>,    <span class="comment"># 每个块的最大令牌数</span></span><br><span class="line">    rules=RecursiveRules(),  <span class="comment"># 使用默认的递归规则</span></span><br><span class="line">    min_characters_per_chunk=<span class="number">12</span>  <span class="comment"># 每个块最少包含的字符数</span></span><br><span class="line">)</span><br><span class="line">chunks = chunker.chunk(text)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文本块内容: <span class="subst">&#123;chunk.text&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;令牌数量: <span class="subst">&#123;chunk.token_count&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="语义分块器（SemanticChunker）"><a href="#语义分块器（SemanticChunker）" class="headerlink" title="语义分块器（SemanticChunker）"></a>语义分块器（SemanticChunker）</h2><p>语义分块器根据语义相似性将文本拆分为块，确保相关内容位于同一块中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> SemanticChunker</span><br><span class="line"></span><br><span class="line">chunker = SemanticChunker(</span><br><span class="line">    embedding_model=<span class="string">&quot;minishlab/potion-base-8M&quot;</span>,  <span class="comment"># 使用嵌入模型</span></span><br><span class="line">    threshold=<span class="number">0.5</span>,  <span class="comment"># 分块的阈值</span></span><br><span class="line">    chunk_size=<span class="number">512</span>,  <span class="comment"># 每个分块的最大令牌数</span></span><br><span class="line">    min_sentences=<span class="number">1</span>  <span class="comment"># 每个分块最少包含的句子数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chunks = chunker.chunk(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文本块内容: <span class="subst">&#123;chunk.text&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;令牌数量: <span class="subst">&#123;chunk.token_count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;分块中的句子数量: <span class="subst">&#123;<span class="built_in">len</span>(chunk.sentences)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="双通道合并分块器（SDPMChunker）"><a href="#双通道合并分块器（SDPMChunker）" class="headerlink" title="双通道合并分块器（SDPMChunker）"></a>双通道合并分块器（SDPMChunker）</h2><p>双通道合并分块器通过语义相似性分组，然后在跳过窗口中合并相似的组，适用于具有重复主题的文档。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> SDPMChunker</span><br><span class="line"></span><br><span class="line">chunker = SDPMChunker(</span><br><span class="line">    embedding_model=<span class="string">&quot;minishlab/potion-base-8M&quot;</span>,  <span class="comment"># 使用嵌入模型</span></span><br><span class="line">    threshold=<span class="number">0.5</span>,  <span class="comment"># 分块的阈值</span></span><br><span class="line">    chunk_size=<span class="number">512</span>,  <span class="comment"># 每个分块的最大令牌数</span></span><br><span class="line">    min_sentences=<span class="number">1</span>,  <span class="comment"># 每个分块最少包含的句子数</span></span><br><span class="line">    skip_window=<span class="number">1</span>  <span class="comment"># 跳过窗口大小</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chunks = chunker.chunk(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;分块内容: <span class="subst">&#123;chunk.text&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;令牌数量: <span class="subst">&#123;chunk.token_count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;分块句子数量: <span class="subst">&#123;<span class="built_in">len</span>(chunk.sentences)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Chonkie 提供了多种灵活的分块策略，能够满足不同场景下的需求。无论是基于句子的分块、递归分块，还是语义分块和双通道合并分块，Chonkie 都能以简单高效的方式完成任务。通过本文的介绍，您应该已经掌握了如何使用 Chonkie 进行文本分块。更多详细信息和高级功能，可以参考 Chonkie 官方文档。</p>
]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>RAG</tag>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>anaconda与python</title>
    <url>/2024/12/01/anaconda%E4%B8%8Epython/</url>
    <content><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Python是一种广泛使用的编程语言，它以其简洁的语法和强大的库支持而闻名。然而，Python在科学计算和数据分析领域中的使用受到了一些限制。为了解决这个问题，Anaconda应运而生，它是一个用于科学计算的Python发行版，它包含了Python解释器、大量的科学计算库和工具，以及一个包管理器conda。</p>
<h2 id="Python与Anaconda的关系"><a href="#Python与Anaconda的关系" class="headerlink" title="Python与Anaconda的关系"></a>Python与Anaconda的关系</h2><p>Python与Anaconda之间的关系非常密切。Anaconda是一个基于Python的发行版，它包含了Python解释器、大量的科学计算库和工具，以及一个包管理器conda。因此，Python是Anaconda的基础，而Anaconda则提供了Python在科学计算和数据分析领域中的强大支持。</p>
<h2 id="Python与Anaconda的区别"><a href="#Python与Anaconda的区别" class="headerlink" title="Python与Anaconda的区别"></a>Python与Anaconda的区别</h2><p>Python与Anaconda在安装源、安装方式、环境管理和包管理方面有一些区别。Python的官方源是Python Package Index (PyPI)，而Anaconda的官方源是Anaconda Repository。PyPI上的包可能不是官方版本，而Anaconda Repository上的包通常是官方版本。Python的包管理器pip可以直接从PyPI安装包，而Anaconda的包管理器conda可以从Anaconda Repository和PyPI安装包。Python的环境管理相对复杂，需要手动创建虚拟环境，并使用pip安装包。而Anaconda的环境管理相对简单，可以直接使用conda创建虚拟环境，并使用conda安装包。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Python与Anaconda之间的关系非常密切，它们在科学计算和数据分析领域中的使用受到了广泛的应用。Python是Anaconda的基础，而Anaconda则提供了Python在科学计算和数据分析领域中的强大支持。Python与Anaconda在安装源、安装方式、环境管理和包管理方面有一些区别，因此，在使用这两种工具时，需要根据具体需求进行选择。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p>[1] Anaconda官方文档: <a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a><br>[2] pip官方文档: <a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a><br>[3] conda vs pip: <a href="https://www.anaconda.com/products/distribution#conda-vs-pip">https://www.anaconda.com/products/distribution#conda-vs-pip</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>conda与pip</title>
    <url>/2024/12/01/conda%E4%B8%8Epip/</url>
    <content><![CDATA[<h2 id="conda与pip的区别"><a href="#conda与pip的区别" class="headerlink" title="conda与pip的区别"></a>conda与pip的区别</h2><p>conda install 和 pip install 是两种常用的Python包管理工具,它们都可以用来安装和管理Python库。但是,它们在安装源和安装方式上有一些区别。</p>
<ol>
<li>安装源</li>
</ol>
<p>conda install 使用的是Anaconda的官方源,而pip install 可以指定任意源来安装库。因此,conda install 安装的库通常都是官方版本的库,而pip install 安装的库可能是官方版本的库,也可能是其他版本的库。</p>
<ol start="2">
<li>安装方式</li>
</ol>
<p>conda install 使用的是Anaconda的包管理器,它会在安装库时自动处理依赖关系,并将其安装到Anaconda的虚拟环境中。因此,使用conda install 安装的库都是独立的,不会影响系统中的其他Python库。而pip install 安装的库则是直接安装到系统Python的site-packages目录中,可能会与其他库发生冲突。</p>
<ol start="3">
<li>影响或问题</li>
</ol>
<p>(1) 版本冲突</p>
<p>由于pip install 安装的库是直接安装到系统Python的site-packages目录中,因此可能会与其他库发生版本冲突。例如,如果系统中已经安装了一个版本的库,而使用pip install 安装了另一个版本的库,可能会导致系统中的库出现兼容性问题。</p>
<p>(2) 依赖问题</p>
<p>pip install 安装的库不会自动处理依赖关系,因此可能会出现依赖问题。例如,如果安装的库依赖于其他库,而没有正确安装依赖库,可能会导致库无法正常使用。</p>
<p>(3) 环境问题</p>
<p>conda install 安装的库都是独立的,不会影响系统中的其他Python库。而pip install 安装的库则是直接安装到系统Python的site-packages目录中,可能会与其他库发生冲突。因此,如果需要使用不同的库,建议使用conda install 安装到不同的环境中。</p>
<p>参考内容:</p>
<p>[1] Anaconda官方文档: <a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a><br>[2] pip官方文档: <a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a><br>[3] conda vs pip: <a href="https://www.anaconda.com/products/distribution#conda-vs-pip">https://www.anaconda.com/products/distribution#conda-vs-pip</a></p>
<p>conda install 和 pip install 在安装源和安装方式上有一些区别,可能会导致一些影响或问题。因此,在使用这两种工具时,需要根据具体需求进行选择。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>conda那些命令</title>
    <url>/2022/08/11/conda%E9%82%A3%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li><p>创建虚拟环境 ： <code>conda create --name my_first_env python=3.6</code></p>
</li>
<li><p>列出虚拟环境 ： <code>conda env list</code></p>
</li>
<li><p>激活虚拟环境 ： <code>conda activate my_first_env</code></p>
</li>
<li><p>查看环境信息 ： <code>conda info -e</code></p>
</li>
<li><p>根据路径激活虚拟环境 ： <code>conda source /root/python/bin/activate</code></p>
</li>
<li><p>推出虚拟环境 ： <code>conda deactivate</code></p>
</li>
<li><p>删除虚拟环境 ： <code>conda remove -n your_env_name --all</code></p>
</li>
<li><p>创建时候安装需要的包 ： <code>conda create -n env_name numpy matplotlib python=2.7</code></p>
</li>
<li><p>在离线的时候创建虚拟环境 ： <code>conda create -n env_name --offline python=3.8</code></p>
</li>
<li><p>环境复制 ： <code>conda create --name new_env_name --clone old_env_name</code></p>
</li>
<li><p>查看所有包 : <code>conda list</code></p>
</li>
</ul>
<h2 id="conda-环境打包"><a href="#conda-环境打包" class="headerlink" title="conda 环境打包"></a>conda 环境打包</h2><p>安装需要的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> activate sample</span><br><span class="line">conda install conda-pack</span><br><span class="line">conda isntall -c conda-forge conda-pack</span><br></pre></td></tr></table></figure>

<p>或pip:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install conda-pack</span><br><span class="line"><span class="comment"># 或者源码</span></span><br><span class="line">pip install git+https://github.com/conda/conda-pack.git</span><br></pre></td></tr></table></figure>

<p>打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda-pack</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="comment"># example.tar.gz 即为打包完成的输出文件</span></span><br><span class="line"><span class="built_in">source</span> deactivate</span><br></pre></td></tr></table></figure>

<p>解压与激活：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf example.tar.gz -C myenv</span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的是，打包好的环境不需要系统当中提前安装基础环境，而是在解压激活之后就能够即刻使用。</p>
</blockquote>
<h2 id="关于conda的源"><a href="#关于conda的源" class="headerlink" title="关于conda的源"></a>关于conda的源</h2><p>添加源命令:</p>
<p><code>conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/main/</code></p>
<p>删除源命令：</p>
<p><code>conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</code></p>
<p>换回默认源：</p>
<p><code>conda config --remove-key channels</code></p>
<p>查看已经添加的源:</p>
<p><code>conda config --show-sources</code></p>
<p>移除镜像源:</p>
<p><code>conda config --remove-key channels</code></p>
<p>直接安装镜像源的某package：</p>
<p><code>conda install -c 镜像源地址 package-name</code></p>
<h2 id="pip的源"><a href="#pip的源" class="headerlink" title="pip的源"></a>pip的源</h2><p>换源：</p>
<p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<p>临时源：</p>
<p><code>pip install package -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2022/04/23/hello-world/</url>
    <content><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#FileName: HelloWorld.java  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>   #如果有 <span class="keyword">public</span> 类的话，类名必须和文件同名，注意大小写  </span><br><span class="line">&#123;  </span><br><span class="line">  #Java 入口程序，程序从此入口  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  </span><br><span class="line">  &#123;  </span><br><span class="line">  #向控制台打印一条语句  </span><br><span class="line">    System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                <span class="meta">#main 入口函数  </span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>); <span class="meta">#printf 函数打印  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;               #函数返回值  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>               <span class="comment">//std::cout 要用到的头文件  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                <span class="comment">//标准输入输出头文件  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!--Way 1\n&quot;</span>);    <span class="comment">//printf 语句打印  </span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello,World!--Way 2&quot;</span>);        <span class="comment">//puts 语句  </span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello,&quot;</span> <span class="string">&quot; &quot;</span> <span class="string">&quot;World!--Way 3&quot;</span>); <span class="comment">//字符串拼接  </span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello,World!--Way 4&quot;</span> &lt;&lt; std::endl; <span class="comment">//C++ 教科书上写法  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;                                        <span class="comment">//作为注释  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello,World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">&lt;body&gt;  </span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello,World!&quot;</span>;            <span class="comment">//打印语句  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;The first php program!&quot;</span>;  <span class="comment">//打印语句  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">phpinfo</span>();                 <span class="comment">//phpinfo()系统函数,输出环境信息  </span></span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line">&lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sys.<span class="title function_">puts</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;Hello,World!&#x27;</span> <span class="keyword">from</span> dual;  </span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the first program!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello,World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python之__init__.py</title>
    <url>/2022/04/28/python%E4%B9%8B-init-py/</url>
    <content><![CDATA[<h2 id="神奇的-init"><a href="#神奇的-init" class="headerlink" title="神奇的__init__"></a>神奇的__init__</h2><p>__init__一般在两种情况下会出现，第一种是以在class（类）当中以函数形式出现，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>

<p>第二种情况则是以__init__.py文件的形式出现在文件夹下。两种不同的情况虽然使用了相同名字的定义，但是其作用可以说类似又可以说不同。</p>
<h2 id="def-init-self"><a href="#def-init-self" class="headerlink" title="def __init__(self)"></a><code>def __init__(self)</code></h2><p>__init__属于魔法函数的一种,之所以说是一种其原因是因为魔法函数是一个大家族，常见的：<code>__ str__()、__ new__()、__ unicode__()、__ call__()、__ len__()、__repr__()</code>等等都是魔法函数，</p>
<h3 id="什么是魔法函数？"><a href="#什么是魔法函数？" class="headerlink" title="什么是魔法函数？"></a>什么是魔法函数？</h3><p>魔法函数一种python的高级用法，一般情况下不是很常见，魔法函数允许使用者在定义类的时候将其绑定在其中，一般格式以两个下划线开始并以两个下划线结束。以<code>__init__</code>为例，该函数允许在实例化类的时候给变量申请内存空间并赋予初始值，有时候我们会将其称之为构造函数。</p>
<p>魔法函数具有以下特点：  </p>
<ul>
<li>Python中以双下划线(<strong>xx</strong>)开始和结束的函数（不可自己定义）为魔法函数。</li>
<li>调用类实例化的对象的方法时自动调用魔法函数。</li>
<li>在自己定义的类中，可以实现之前的内置函数。</li>
</ul>
<h3 id="init-是什么？"><a href="#init-是什么？" class="headerlink" title="__init__是什么？"></a><code>__init__</code>是什么？</h3><p><code>__init__</code>函数存在于class当中，可以包含多个参数，但是必须有一个self作为参数，<code>__init__</code>的存在使得函数在初始化的时候就能够给对象当中的参数进行初始化并赋值，在初始化的时候程序会自动调用该函数，于此同事，如果设置了<code>__init__</code>的参数，在实例化的时候如果不给定参数也是错误的。当然，<code>__init__</code>也是作为类的私有函数存在，所以在实例化之后是无法被外部调用的。</p>
<h2 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h2><p><code>__init__</code>函数可以当中构造函数来理解，但是<code>__init__.py</code>却不是那么容易理解。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>常见的说法会将其描述成为：<code>__init__.py</code> 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有<code>__init__.py</code> 文件。  </p>
<hr>
<p>但是直接跳到python模块上来，这样的理解未免太过于快了，以至于很多人不能够理解。因此我打算在这里只说用法方便于理解。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>假设现在有这样一个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">│</span><br><span class="line">├─model</span><br><span class="line">│      info.py   </span><br><span class="line">│</span><br><span class="line">test.py</span><br></pre></td></tr></table></figure>

<p>现在model.py文件当中的代码是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">param</span>):</span><br><span class="line">    <span class="keyword">return</span> param</span><br></pre></td></tr></table></figure>

<p>那么问题来了，我们该怎么去调用model.py文件当中的变量？  </p>
<hr>
<p>以前的方法是<code>from model.model import * </code>,但是如果，下面不止这一个文件呢？万一这个目录下有很多个文件呢？我们再去一个个去调用，未免太过于难受了。<br>但是如果我们在model目录下添加一个<code>__init__.py</code>文件，在文件当中写入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .info <span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line">test = test</span><br></pre></td></tr></table></figure>

<p>然后在<code>test.py</code>文件当中写入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(model.test(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>这样就能够直接调用了。发现端倪了吗？这里我们使用的就是<code>import model</code>,没有指定那一个文件啊，按照一般的想法不应该是<code>import model.__init__</code>吗？<br>这就是所谓的将文件夹变成一个模块的含义，<code>__init__.py</code>文件的存在能够管理该文件夹下面的所有文件，并且通过<code>__init__.py</code>文件导入的形式，在调用文件夹的时候自动调用<code>__init__.py</code>文件下管理文件当中的对象。但是这样的做法有什么含义？用处在于什么？用其他文件不能实现吗？</p>
<hr>
<p>首先，这样能够更加有效的管理文件夹下面的文件，对于使用者来说能够将文件夹当作一个封闭的包使用，不用担心导入存在的路径问题，在封装跟打包的时候也能够保证调用的可靠性。当然其他随便写个文件也能够实现类似的功能，但是使用起来完全没有<code>__init__.py</code>文件方便，并且可能存在未知的导入出错问题。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>python3的ssl模块版本问题</title>
    <url>/2023/10/31/python3%E7%9A%84ssl%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>此模块提供对 Client 端和服务器端网络套接字的传输层安全性(通常称为“安全套接字层”)加密和对等身份验证Function的访问。该模块使用 OpenSSL 库。只要在该平台上安装了 OpenSSL，它就可以在所有现代 Unix 系统，Windows，Mac OS X 以及可能的其他平台上使用。</p>
<blockquote>
<p><strong>Note</strong><br>由于对 os 套接字 API 进行了调用，因此某些行为可能取决于平台。安装的 OpenSSL 版本也可能导致行为变化。例如，TLSv1.1 和 TLSv1.2 随附 openssl 版本 1.0.1.</p>
</blockquote>
<h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>请勿在未阅读Security considerations的情况下使用此模块。这样做可能会导致错误的安全感，因为 ssl 模块的默认设置不一定适合您的应用程序。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>此模块提供了一个类ssl.SSLSocket，该类派生自socket.socket类型，并提供类似于套接字的包装器，该包装器还使用 SSL 对pass套接字的数据进行加密和解密。它支持其他方法，例如getpeercert()(用于检索连接另一侧的证书)和cipher()(用于检索用于安全连接的密码)。</p>
<p>对于更复杂的应用程序，ssl.SSLContext类有助于 Management 设置和证书，然后可以passpass SSLContext.wrap_socket() 方法创建的 SSL 套接字继承这些设置和证书。</p>
<p>在版本 3.5.3 中进行了更改：已更新以支持与 OpenSSL 1.1.0 链接</p>
<p>在版本 3.6 中更改：不建议使用 OpenSSL 0.9.8、1.0.0 和 1.0.1，并且不再支持。将来，ssl 模块将至少需要 OpenSSL 1.0.2 或 1.1.0.</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>错误记录</tag>
      </tags>
  </entry>
  <entry>
    <title>python代码加密</title>
    <url>/2023/02/21/python%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>之前工作中需要使用到对python代码进行加密，因为许多核心代码设计到重要信息，不能暴露给客户。但是python作为一种脚本语言，既要保证运行部署方便又要考虑到代码破译的安全性问题。</p>
<h2 id="编译加密"><a href="#编译加密" class="headerlink" title="编译加密"></a>编译加密</h2><p>编译加密就是常见的将python代码编译成为以后缀<code>.pyc</code>的文件，虽然不影响使用与部署，但是可以被反编译，直接使用uncompyle库进行反编译即可得到结果</p>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>代码混淆在我之前的记录当中提起过，<a href="https://pyob.oxyry.com/">网站</a></p>
<p>优点：</p>
<ul>
<li>简单</li>
<li>不可逆</li>
<li>不影响逻辑</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于项目来说不友好</li>
<li>混淆不可控</li>
<li>逻辑依然可读</li>
</ul>
<h2 id="打包成exe文件"><a href="#打包成exe文件" class="headerlink" title="打包成exe文件"></a>打包成<code>exe</code>文件</h2><p>python可以使用<code>pyinstaller</code>将文件打包成exe文件，但是对于项目部署来说几乎全是缺点：</p>
<ul>
<li>内部路径找不到</li>
<li>资源文件不好打包</li>
<li>部署使用麻烦</li>
<li>难以控制</li>
</ul>
<h2 id="生成使用-Cython"><a href="#生成使用-Cython" class="headerlink" title="生成使用 Cython"></a>生成使用 Cython</h2><p>它的原理：将 .py/.pyx 编译为 .c文件，再将 .c文件编译为 .so(Unix) 或 .pyd(Windows)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Cython</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>不可逆</li>
<li>不影响使用</li>
</ul>
<p>缺点：</p>
<ul>
<li>打包麻烦</li>
<li>维护麻烦</li>
</ul>
<h2 id="PyArmor"><a href="#PyArmor" class="headerlink" title="PyArmor"></a>PyArmor</h2><p>这是一个python代码加密库，不影响项目结构进行加密，支持多种加密方式，部署也不受影响。但是不能调试！是当前觉得最好的加密方法，附上<a href="https://pyarmor.dashingsoft.com/index-zh.html">网站</a>与<a href="https://pyarmor.readthedocs.io/zh/latest/how-to-do.html">教程</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>加密</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>python代码ast基础</title>
    <url>/2024/12/01/python%E4%BB%A3%E7%A0%81ast%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>AST（Abstract Syntax Tree）是一种抽象语法树，它将源代码转换为一种树形结构，用于表示程序的语法结构。在Python中，AST库允许你将源代码转换为AST，然后遍历和操作这个树形结构。这使得你能够更好地理解和维护代码。</p>
<p>Python的AST库提供了以下功能：</p>
<ol>
<li>将源代码转换为AST：使用<code>ast.parse</code>函数将源代码转换为AST。这个函数接受一个字符串参数，即要转换的源代码。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"></span><br><span class="line">source_code = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def add(a, b):</span></span><br><span class="line"><span class="string">    return a + b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">result = add(1, 2)</span></span><br><span class="line"><span class="string">print(result)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tree = ast.parse(source_code)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>遍历AST：使用<code>ast.walk</code>函数遍历AST。这个函数接受一个AST节点作为参数，并返回一个包含所有子节点的列表。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"></span><br><span class="line">tree = ast.parse(source_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> ast.walk(tree):</span><br><span class="line">    <span class="built_in">print</span>(node)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>操作AST：使用各种<code>ast</code>模块中的函数来操作AST。例如，你可以使用<code>ast.Assign</code>来创建一个赋值语句，或者使用<code>ast.Call</code>来创建一个函数调用。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">tree = ast.parse(source_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个赋值语句</span></span><br><span class="line">assign = ast.Assign(targets=[ast.Name(<span class="built_in">id</span>=<span class="string">&#x27;result&#x27;</span>, ctx=ast.Store())], value=ast.Call(func=ast.Name(<span class="built_in">id</span>=<span class="string">&#x27;add&#x27;</span>, ctx=ast.Load()), args=[ast.Num(n=<span class="number">1</span>), ast.Num(n=<span class="number">2</span>)], keywords=[]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将赋值语句添加到AST中</span></span><br><span class="line">tree.body.append(assign)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历AST并打印结果</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> ast.walk(tree):</span><br><span class="line">    <span class="built_in">print</span>(node)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编译和执行AST：使用<code>compile</code>函数将AST编译为字节码，然后使用<code>exec</code>或<code>eval</code>函数执行字节码。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"></span><br><span class="line">tree = ast.parse(source_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译AST为字节码</span></span><br><span class="line">code = <span class="built_in">compile</span>(tree, <span class="string">&#x27;&lt;string&gt;&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行字节码</span></span><br><span class="line"><span class="built_in">exec</span>(code)</span><br></pre></td></tr></table></figure>

<p>总之，Python的AST库提供了一种强大的方法来处理和操作源代码，使得你能够更好地理解和维护代码。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python代码片段(vscode)</title>
    <url>/2022/04/23/python%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-vscode/</url>
    <content><![CDATA[<p>在最新的vscode的python插件更新后，不提供代码片段的功能，因此要自己手添加用户代码片段。使用方法如下：</p>
<ul>
<li>复制下方给出的代码片段</li>
<li>打开vscode</li>
<li>左下角设置-&gt;用户代码片段-&gt;python.json</li>
<li>全部删掉后替换成刚刚复制的内容</li>
</ul>
<p>再次使用后vscode提供代码片段联想功能,输入部分代码后可提供多种代码格式,如下图：<br><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/python%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(vscode)/1.png" alt="1"><br><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/python%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(vscode)/2.png" alt="2"></p>
<p>可根据代码片段书写格式自定义代码片段。<br>代码片段如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="comment">// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and </span></span><br><span class="line">	<span class="comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span></span><br><span class="line">	<span class="comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span></span><br><span class="line">	<span class="comment">// same ids are connected.</span></span><br><span class="line">	<span class="comment">// Example:</span></span><br><span class="line">	<span class="comment">// &quot;Print to console&quot;: &#123;</span></span><br><span class="line">	<span class="comment">// 	&quot;prefix&quot;: &quot;log&quot;,</span></span><br><span class="line">	<span class="comment">// 	&quot;body&quot;: [</span></span><br><span class="line">	<span class="comment">// 		&quot;console.log(&#x27;$1&#x27;);&quot;,</span></span><br><span class="line">	<span class="comment">// 		&quot;$2&quot;</span></span><br><span class="line">	<span class="comment">// 	],</span></span><br><span class="line">	<span class="comment">// 	&quot;description&quot;: &quot;Log output to console&quot;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="attr">&quot;HEADER&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HEADER&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;#!/usr/bin/env python&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;# -*- encoding: utf-8 -*-&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#x27;&#x27;&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;@文件    :$TM_FILENAME&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;@说明    :&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;@时间    :$CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;@作者    :ljw&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;@版本    :1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#x27;&#x27;&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;$0&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;if&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;if $&#123;1:expression&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;2:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an if statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;if/else&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if/else&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;if $&#123;1:condition&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;2:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;else:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an if statement with else&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;elif&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elif&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;elif $&#123;1:expression&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;2:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an elif&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;else&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;else&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;else:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;1:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an else&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;while&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;while&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;while $&#123;1:expression&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;2:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a while loop&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;while/else&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;while/else&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;while $&#123;1:expression&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;2:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;else:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a while loop with else&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;for&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;for&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;for $&#123;1:target_list&#125; in $&#123;2:expression_list&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a for loop&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;for/else&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;for/else&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;for $&#123;1:target_list&#125; in $&#123;2:expression_list&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;else:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a for loop with else&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;try/except&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;try/except&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;try:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;1:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;except $&#123;2:expression&#125; as $&#123;3:identifier&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a try/except statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;try/finally&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;try/finally&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;try:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;1:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;finally:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;2:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a try/finally statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;try/except/else&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;try/except/else&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;try:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;1:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;except $&#123;2:expression&#125; as $&#123;3:identifier&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;else:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;5:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a try/except/else statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;try/except/finally&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;try/except/finally&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;try:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;1:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;except $&#123;2:expression&#125; as $&#123;3:identifier&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;finally:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;5:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a try/except/finally statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;try/except/else/finally&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;try/except/else/finally&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;try:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;1:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;except $&#123;2:expression&#125; as $&#123;3:identifier&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;else:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;5:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;finally:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;6:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a try/except/else/finally statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;with&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;with&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;with $&#123;1:expression&#125; as $&#123;2:target&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a with statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;def&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;def&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;def $&#123;1:funcname&#125;($&#123;2:parameter_list&#125;):&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:docstring&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a function definition&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;def(class method)&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;def(class method)&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;def $&#123;1:funcname&#125;(self, $&#123;2:parameter_list&#125;):&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:docstring&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a class method&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;def(static class method)&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;def(static class method)&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;@staticmethod&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;def $&#123;1:funcname&#125;($&#123;2:parameter_list&#125;):&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:docstring&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a static class method&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;def(abstract class method)&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;def(abstract class method)&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;def $&#123;1:funcname&#125;(self, $&#123;2:parameter_list&#125;):&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:docstring&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\traise NotImplementedError&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an abstract class method&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;class $&#123;1:classname&#125;($&#123;2:object&#125;):&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:docstring&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t\&quot;\&quot;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a class definition&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;lambda&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lambda&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;lambda $&#123;1:parameter_list&#125;: $&#123;2:expression&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a lambda statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;if(main)&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;__main__&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;if __name__ == \&quot;__main__\&quot;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;    $&#123;1:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for a `if __name__ == \&quot;__main__\&quot;: ...` block&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;async/def&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;async/def&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;async def $&#123;1:funcname&#125;($&#123;2:parameter_list&#125;):&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:pass&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an async statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;async/for&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;async/for&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;async for $&#123;1:target&#125; in $&#123;2:iter&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:block&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an async for statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;async/for/else&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;async/for/else&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;async for $&#123;1:target&#125; in $&#123;2:iter&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:block&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;else:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;4:block&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an async for statement with else&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;async/with&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;async/with&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;async with $&#123;1:expr&#125; as $&#123;2:var&#125;:&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;\t$&#123;3:block&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for an async with statement&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;ipdb&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ipdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;import ipdb; ipdb.set_trace()&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for ipdb debug&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;pdb&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;import pdb; pdb.set_trace()&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for pdb debug&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;pudb&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pudb&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;import pudb; pudb.set_trace()&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet for pudb debug&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;add/new/cell&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add/new/cell&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;# %%&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet to add a new cell&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;mark/markdown&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mark/markdown&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;# %% [markdown]&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Code snippet to add a new markdown cell&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>python代码中的特殊注释</title>
    <url>/2025/02/15/python%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h2 id="python代码中的特殊注释"><a href="#python代码中的特殊注释" class="headerlink" title="python代码中的特殊注释"></a>python代码中的特殊注释</h2><ol>
<li><p>**<code># noqa</code>**：</p>
<ul>
<li>用法：<code>some_code = &quot;example&quot;  # noqa</code></li>
<li>功能：告诉<code>flake8</code>等工具忽略当前行的所有警告。</li>
</ul>
</li>
<li><p>**<code># type: ignore</code>**：</p>
<ul>
<li>用法：<code>import some_module  # type: ignore</code></li>
<li>功能：告诉<code>mypy</code>等类型检查器忽略当前行的类型检查警告。</li>
</ul>
</li>
<li><p>**<code># pylint: disable=some-message</code>**：</p>
<ul>
<li>用法：<code>some_code = &quot;example&quot;  # pylint: disable=unused-variable</code></li>
<li>功能：告诉<code>pylint</code>工具忽略特定的警告消息（例如未使用的变量）。</li>
</ul>
</li>
<li><p>**<code># isort: skip</code>**：</p>
<ul>
<li>用法：<code>import some_module  # isort: skip</code></li>
<li>功能：告诉<code>isort</code>工具在自动排序导入语句时跳过当前行。</li>
</ul>
</li>
<li><p><strong><code># fmt: off</code></strong> 和 **<code># fmt: on</code>**：</p>
<ul>
<li>用法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fmt: off</span></span><br><span class="line">some_code = <span class="string">&quot;example&quot;</span></span><br><span class="line"><span class="comment"># fmt: on</span></span><br></pre></td></tr></table></figure></li>
<li>功能：告诉<code>black</code>等代码格式化工具在<code># fmt: off</code>和<code># fmt: on</code>之间的代码不要进行格式化。</li>
</ul>
</li>
<li><p>**<code># todo</code>**：</p>
<ul>
<li>用法：<code># todo: implement this function</code></li>
<li>功能：标记待办事项，一些编辑器或工具可能会识别它以列出待办事项。</li>
</ul>
</li>
<li><p>**<code># fixme</code>**：</p>
<ul>
<li>用法：<code># fixme: handle this exception properly</code></li>
<li>功能：标记需要修复的问题。</li>
</ul>
</li>
<li><p>**<code># ruff: ignore</code>**：</p>
<ul>
<li>用法：<code>some_code = &quot;example&quot;  # ruff: ignore</code></li>
<li>功能：告诉<code>ruff</code>工具忽略当前行的警告。</li>
</ul>
</li>
<li><p><strong><code># type: Any</code></strong> 或其他类型注释：</p>
<ul>
<li>用法：<code>def my_function(param: Any) -&gt; None: pass  # type: (Any) -&gt; None</code></li>
<li>功能：用于类型注释，告诉类型检查器某个变量或函数的返回类型。</li>
</ul>
</li>
<li><p><strong><code># coding: utf-8</code></strong> 或其他编码声明：</p>
<ul>
<li>用法：<code># coding: utf-8</code></li>
<li>功能：指定文件的编码格式，通常放在文件的第一行或第二行。</li>
</ul>
</li>
<li><p>**<code># mypy: ignore-errors</code>**：</p>
<ul>
<li>用法：<code># mypy: ignore-errors</code></li>
<li>功能：告诉<code>mypy</code>忽略文件中的所有类型错误。</li>
</ul>
</li>
<li><p>**<code># mypy: strict</code>**：</p>
<ul>
<li>用法：<code># mypy: strict</code></li>
<li>功能：告诉<code>mypy</code>对文件进行严格类型检查。</li>
</ul>
</li>
<li><p>**<code># pragma: no cover</code>**：</p>
<ul>
<li>用法：<code>def my_function():  # pragma: no cover</code></li>
<li>功能：告诉代码覆盖率工具（如<code>coverage.py</code>）忽略这一行代码。</li>
</ul>
</li>
<li><p>**<code># jshint ignore:line</code>**：</p>
<ul>
<li>用法：<code>var myVar = &#39;value&#39;;  // jshint ignore:line</code></li>
<li>功能：告诉<code>JSHint</code>工具忽略当前行的警告（虽然这是针对JavaScript的，但一些Python工具可能也有类似的约定）。</li>
</ul>
</li>
<li><p><strong><code># isort: off</code></strong> 和 **<code># isort: on</code>**：</p>
<ul>
<li>用法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># isort: off</span></span><br><span class="line"><span class="keyword">import</span> some_module</span><br><span class="line"><span class="comment"># isort: on</span></span><br></pre></td></tr></table></figure></li>
<li>功能：告诉<code>isort</code>工具在<code># isort: off</code>和<code># isort: on</code>之间的代码不要进行导入排序。</li>
</ul>
</li>
<li><p>**<code># type: ignore[attr-defined]</code>**：</p>
<ul>
<li>用法：<code>obj.attr  # type: ignore[attr-defined]</code></li>
<li>功能：告诉<code>mypy</code>等类型检查器忽略特定的属性定义警告。</li>
</ul>
</li>
<li><p>**<code># type: ignore[misc]</code>**：</p>
<ul>
<li>用法：<code>some_code  # type: ignore[misc]</code></li>
<li>功能：告诉<code>mypy</code>等类型检查器忽略特定的杂项警告。</li>
</ul>
</li>
<li><p>**<code># cython: language_level=3</code>**：</p>
<ul>
<li>用法：<code># cython: language_level=3</code></li>
<li>功能：告诉Cython编译器使用Python 3的语言级别。</li>
</ul>
</li>
<li><p>**<code># flake8: noqa</code>**：</p>
<ul>
<li>用法：<code># flake8: noqa</code></li>
<li>功能：告诉<code>flake8</code>工具忽略当前文件的所有警告（通常放在文件的顶部）。</li>
</ul>
</li>
<li><p>**<code># check-arg-names: false</code>**：</p>
<ul>
<li>用法：<code>def my_function(a, b):  # check-arg-names: false</code></li>
<li>功能：告诉某些代码分析工具忽略参数名称检查。</li>
</ul>
</li>
</ol>
<p>这些注释通常用于控制代码分析工具的行为，帮助开发者在特定情况下避免不必要的警告或错误。使用这些注释时，应确保它们的目的是明确的，并且不会隐藏代码中的实际问题。</p>
<h2 id="哪些跟编辑器绑定的特殊注释"><a href="#哪些跟编辑器绑定的特殊注释" class="headerlink" title="哪些跟编辑器绑定的特殊注释"></a>哪些跟编辑器绑定的特殊注释</h2><p>有一些注释或标记是与特定编辑器或IDE绑定的，用于控制编辑器的行为，如代码折叠、任务列表、代码分析等。以下是一些常见的与编辑器绑定的注释：</p>
<ol>
<li><p>**<code># region</code> 和 <code># endregion</code>**：</p>
<ul>
<li>用于定义代码折叠区域。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># region My Region</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"><span class="comment"># endregion</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code># todo</code><strong>、</strong><code># fixme</code><strong>、</strong><code># note</code><strong>、</strong><code># hack</code>**：</p>
<ul>
<li>这些注释用于标记待办事项、需要修复的问题、重要说明或临时解决方案，一些编辑器会自动识别这些标记并提供任务列表视图。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># todo: implement this function</span></span><br><span class="line"><span class="comment"># fixme: handle this exception properly</span></span><br><span class="line"><span class="comment"># note: this is a workaround for a known issue</span></span><br><span class="line"><span class="comment"># hack: temporary solution until a better approach is found</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code># pylint: disable</code></strong> 和 **<code># pylint: enable</code>**：</p>
<ul>
<li>用于在特定代码块中禁用或启用<code>pylint</code>的特定警告。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pylint: disable=unused-variable</span></span><br><span class="line">some_unused_variable = <span class="number">42</span></span><br><span class="line"><span class="comment"># pylint: enable=unused-variable</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code># type: ignore</code>**：</p>
<ul>
<li>用于告诉类型检查器（如<code>mypy</code>）忽略特定行的类型错误。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> some_module  <span class="comment"># type: ignore</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code># isort: skip_file</code>**：</p>
<ul>
<li>用于告诉<code>isort</code>工具忽略整个文件的导入排序。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># isort: skip_file</span></span><br><span class="line"><span class="keyword">import</span> b</span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code># fmt: off</code></strong> 和 **<code># fmt: on</code>**：</p>
<ul>
<li>用于告诉代码格式化工具（如<code>black</code>）在特定代码块中禁用格式化。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fmt: off</span></span><br><span class="line">some_code = <span class="string">&quot;example&quot;</span></span><br><span class="line"><span class="comment"># fmt: on</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code># noinspection</code>**：</p>
<ul>
<li>用于告诉IDE（如PyCharm）忽略特定的代码检查。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># noinspection PyUnresolvedReferences</span></span><br><span class="line"><span class="keyword">import</span> some_module</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code># mypy: ignore-errors</code>**：</p>
<ul>
<li>用于告诉<code>mypy</code>忽略整个文件的类型错误。</li>
<li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mypy: ignore-errors</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些注释通常由特定的编辑器或IDE解释，并用于控制编辑器的行为或提供额外的信息。使用这些注释时，应确保了解它们的用途和影响，并且不会隐藏代码中的实际问题。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数缓存之lru_cache</title>
    <url>/2024/07/25/python%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98%E4%B9%8Blru-cache/</url>
    <content><![CDATA[<h2 id="lru-cache"><a href="#lru-cache" class="headerlink" title="lru_cache"></a><code>lru_cache</code></h2><p><code>lru_cache</code> 是 Python 标准库 <code>functools</code> 模块中的一个装饰器，用于实现缓存功能。它通过缓存函数的返回值来提高函数的执行效率，特别是对于计算密集型函数或具有大量重复输入的函数。</p>
<p><code>lru_cache</code> 的全称是 “Least Recently Used Cache”，即最近最少使用缓存。它使用一个字典来存储函数的返回值，字典的键是函数的参数，值是函数的返回值。当函数被调用时，<code>lru_cache</code> 会首先检查参数是否已经在缓存中，如果在，则直接返回缓存中的值；如果不在，则计算函数的返回值，并将结果存入缓存。</p>
<p><code>lru_cache</code> 有一些可选参数，可以用来控制缓存的大小和过期时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>lru_cache</code> 装饰器将 <code>fibonacci</code> 函数的返回值缓存起来，最多缓存 128 个结果。当 <code>fibonacci</code> 函数被调用时，<code>lru_cache</code> 会首先检查参数是否已经在缓存中，如果在，则直接返回缓存中的值；如果不在，则计算函数的返回值，并将结果存入缓存。</p>
<p>需要注意的是，<code>lru_cache</code> 只能缓存可哈希的参数。如果函数的参数是不可哈希的，如列表或字典，<code>lru_cache</code> 将无法缓存函数的返回值。</p>
<p>另外，<code>lru_cache</code> 不会自动清理缓存。如果缓存中的数据不再需要，需要手动清理缓存。可以使用 <code>cache_clear()</code> 方法来清空缓存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fibonacci.cache_clear()</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><code>lru_cache</code> 可以用于各种场景，以下是一些常见的使用案例：</p>
<ol>
<li><strong>缓存函数结果</strong></li>
</ol>
<p><code>lru_cache</code> 可以用于缓存函数的结果，避免重复计算。这在处理递归函数或计算密集型函数时特别有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">30</span>))  <span class="comment"># 输出: 832040</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>优化性能</strong></li>
</ol>
<p><code>lru_cache</code> 可以用于优化性能，特别是在处理大量重复输入的函数时。通过缓存函数的结果，可以避免重复计算，从而提高函数的执行效率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heavy_computation</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 模拟一个计算密集型函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">1000000</span>))  <span class="comment"># 输出: 499999500000</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>限制缓存大小</strong></li>
</ol>
<p><code>lru_cache</code> 的 <code>maxsize</code> 参数可以用于限制缓存的大小。当缓存满了之后，<code>lru_cache</code> 会自动删除最近最少使用的缓存项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heavy_computation</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 模拟一个计算密集型函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">1000000</span>))  <span class="comment"># 输出: 499999500000</span></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">2000000</span>))  <span class="comment"># 输出: 1999999000000</span></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">3000000</span>))  <span class="comment"># 输出: 2999999000000</span></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">4000000</span>))  <span class="comment"># 输出: 3999999000000</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>lru_cache</code> 的 <code>maxsize</code> 参数被设置为 3，所以最多只能缓存 3 个结果。当第 4 个结果被计算出来时，<code>lru_cache</code> 会自动删除最近最少使用的缓存项。</p>
<ol start="4">
<li><strong>缓存过期</strong>：<code>lru_cache</code> 还可以用于实现缓存过期。通过设置 <code>typed</code> 参数为 <code>True</code>，<code>lru_cache</code> 会将缓存项的类型作为键的一部分，从而实现缓存过期。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">typed=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heavy_computation</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 模拟一个计算密集型函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">1000000</span>))  <span class="comment"># 输出: 499999500000</span></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">1000000</span>))  <span class="comment"># 输出: 499999500000</span></span><br><span class="line"><span class="built_in">print</span>(heavy_computation(<span class="number">2000000</span>))  <span class="comment"># 输出: 1999999000000</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>lru_cache</code> 的 <code>typed</code> 参数被设置为 <code>True</code>，所以 <code>heavy_computation</code> 函数的结果会被缓存两次，一次是 <code>n</code> 为 1000000，一次是 <code>n</code> 为 2000000。当 <code>n</code> 为 1000000 时，<code>lru_cache</code> 会返回缓存中的结果；当 <code>n</code> 为 2000000 时，<code>lru_cache</code> 会重新计算结果，并将结果存入缓存。</p>
<p>总结起来，<code>lru_cache</code> 是一个非常有用的装饰器，可以帮助我们提高函数的执行效率，特别是在处理大量重复输入或计算密集型函数时。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python保存变量</title>
    <url>/2022/08/29/python%E4%BF%9D%E5%AD%98%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>在python程序当中，如果需要涉及到读取体积较大文件或者涉及较为复杂的变量处理的时候，在变量的处理或者序列化的阶段可能非常耗费时间，基于此我们可以提前将变量保存起来形成文件的格式。与原来的读取文本文件的方式不同，变量保存的文件读取之后直接就是包含数据结构与对象类型的变量，并且读取速度也会相应的快很多。</p>
<p>python为不同的情况提供了多种变量的保存方式，有些库自己也提供某些变量的保存方式。以下展示几种python保存变量的方式。</p>
<p>方法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储变量的文件的名字</span></span><br><span class="line">filename = <span class="string">&#x27;shoplist.data&#x27;</span></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">shoplist = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;mango&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>]</span><br><span class="line"><span class="comment"># 以二进制写模式打开目标文件</span></span><br><span class="line">f = <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="comment"># 将变量存储到目标文件中区</span></span><br><span class="line">pickle.dump(shoplist, f)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">del</span> shoplist</span><br><span class="line"><span class="comment"># 以二进制读模式打开目标文件</span></span><br><span class="line">f = <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="comment"># 将文件中的变量加载到当前工作区</span></span><br><span class="line">storedlist = pickle.load(f)</span><br><span class="line"><span class="built_in">print</span>(storedlist)</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当然如果你安了sklearn，保存东西会简单一点。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="comment"># 保存x</span></span><br><span class="line">joblib.dump(x, <span class="string">&#x27;x.pkl&#x27;</span>) </span><br><span class="line"><span class="comment"># 加载x</span></span><br><span class="line">x = joblib.load(<span class="string">&#x27;x.pkl&#x27;</span>) </span><br><span class="line">对于dataframe数据类型，也有自己的保存方法。</span><br></pre></td></tr></table></figure>

<p>方法三：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;写入数据\n&#x27;</span>,df)</span><br><span class="line"><span class="comment"># 使用DataFrame的to_pickle属性就可以生成pickle文件对数据进行永久储存</span></span><br><span class="line">df.to_pickle(<span class="string">&#x27;foo.pkl&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用pandas库的pd.read_pickle读取pickle数据</span></span><br><span class="line">dr = pd.read_pickle(<span class="string">&#x27;foo.pkl&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;读取数据\n&#x27;</span>, dr)</span><br></pre></td></tr></table></figure>

<p>方法四：</p>
<p>numpy保存文件</p>
<p>二进制文件</p>
<ul>
<li>只保存数据不保存形状和元素类型<code>a.tofile(&#39;a.bin)</code></li>
<li>读入时需要指定元素类型<code>b=np.fromfile(&#39;a.bin’,dtype=np.int32)</code></li>
</ul>
<p>npy文件</p>
<ul>
<li>保存：<code>np.save(&#39;a.npy&#39;,a)</code></li>
<li>读取：<code>c=np.load(&#39;a.npy&#39;)</code></li>
</ul>
<p>txt和csv等文件</p>
<ul>
<li>保存：<code>np.savetxt(&#39;a.txt&#39; ,a,fmt=&#39;%d&#39;)</code></li>
<li>读取：<code>np.loadtxt(&#39;a.txt&#39;,dtype=&#39;int&#39;)</code></li>
</ul>
<blockquote>
<p><strong>注意：</strong>并不是所有的变量都能够保存并且落盘，某些变量不能够进行序列化或者本身只包含索引，因此会导致保存失败</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python库parse的使用</title>
    <url>/2025/02/15/python%E5%BA%93parse%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="深入浅出解析-Python-parse-库的使用"><a href="#深入浅出解析-Python-parse-库的使用" class="headerlink" title="深入浅出解析 Python parse 库的使用"></a>深入浅出解析 Python <code>parse</code> 库的使用</h3><p><code>parse</code> 是 Python 中一个强大的字符串解析库，它能够根据指定的格式从字符串中提取出所需的数据。与 Python 内置的字符串格式化功能（如 <code>str.format()</code>）相反，<code>parse</code> 库的作用是从格式化字符串中反向提取数据。</p>
<hr>
<h3 id="1-安装-parse-库"><a href="#1-安装-parse-库" class="headerlink" title="1. 安装 parse 库"></a>1. <strong>安装 <code>parse</code> 库</strong></h3><p>在开始使用 <code>parse</code> 库之前，需要先安装它。可以通过以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install parse</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. <strong>基本用法</strong></h3><p><code>parse</code> 库的核心功能是通过 <code>parse()</code> 函数从字符串中提取数据。其基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">result = parse(format_string, input_string)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>format_string</code>：格式化字符串，用于定义提取数据的模式。</li>
<li><code>input_string</code>：需要解析的输入字符串。</li>
<li><code>result</code>：解析结果，返回一个 <code>Result</code> 对象。如果解析失败，返回 <code>None</code>。</li>
</ul>
<h4 id="示例-1：提取简单数据"><a href="#示例-1：提取简单数据" class="headerlink" title="示例 1：提取简单数据"></a>示例 1：提取简单数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">result = parse(<span class="string">&quot;My name is &#123;&#125;&quot;</span>, <span class="string">&quot;My name is Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="number">0</span>])  <span class="comment"># 输出: Alice</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>format_string</code> 是 <code>&quot;My name is &#123;&#125;&quot;</code>，<code>input_string</code> 是 <code>&quot;My name is Alice&quot;</code>。<code>parse()</code> 函数从输入字符串中提取出 <code>Alice</code>，并将其存储在 <code>result[0]</code> 中。</p>
<hr>
<h3 id="3-提取命名数据"><a href="#3-提取命名数据" class="headerlink" title="3. 提取命名数据"></a>3. <strong>提取命名数据</strong></h3><p><code>parse</code> 库支持通过命名占位符提取数据，提取的结果会以字典形式返回。</p>
<h4 id="示例-2：提取命名数据"><a href="#示例-2：提取命名数据" class="headerlink" title="示例 2：提取命名数据"></a>示例 2：提取命名数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">result = parse(<span class="string">&quot;My name is &#123;name&#125;&quot;</span>, <span class="string">&quot;My name is Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 输出: Alice</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>format_string</code> 中的 <code>&#123;name&#125;</code> 是一个命名占位符。<code>parse()</code> 函数会将提取的数据存储在 <code>result[&quot;name&quot;]</code> 中。</p>
<hr>
<h3 id="4-提取类型化数据"><a href="#4-提取类型化数据" class="headerlink" title="4. 提取类型化数据"></a>4. <strong>提取类型化数据</strong></h3><p><code>parse</code> 库支持通过类型化占位符提取特定类型的数据。常用的类型包括：</p>
<ul>
<li><code>&#123;name:d&#125;</code>：提取整数。</li>
<li><code>&#123;name:f&#125;</code>：提取浮点数。</li>
<li><code>&#123;name:w&#125;</code>：提取单词（以空格分隔的字符串）。</li>
</ul>
<h4 id="示例-3：提取整数和浮点数"><a href="#示例-3：提取整数和浮点数" class="headerlink" title="示例 3：提取整数和浮点数"></a>示例 3：提取整数和浮点数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">result = parse(<span class="string">&quot;I am &#123;age:d&#125; years old and weigh &#123;weight:f&#125; kg&quot;</span>, </span><br><span class="line">               <span class="string">&quot;I am 25 years old and weigh 68.5 kg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="string">&quot;age&quot;</span>])    <span class="comment"># 输出: 25</span></span><br><span class="line"><span class="built_in">print</span>(result[<span class="string">&quot;weight&quot;</span>]) <span class="comment"># 输出: 68.5</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>&#123;age:d&#125;</code> 提取整数，<code>&#123;weight:f&#125;</code> 提取浮点数。</p>
<hr>
<h3 id="5-提取复杂数据"><a href="#5-提取复杂数据" class="headerlink" title="5. 提取复杂数据"></a>5. <strong>提取复杂数据</strong></h3><p><code>parse</code> 库支持更复杂的模式匹配，例如提取日期、时间等。</p>
<h4 id="示例-4：提取日期"><a href="#示例-4：提取日期" class="headerlink" title="示例 4：提取日期"></a>示例 4：提取日期</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">result = parse(<span class="string">&quot;Today is &#123;date:%Y-%m-%d&#125;&quot;</span>, <span class="string">&quot;Today is 2023-10-05&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="string">&quot;date&quot;</span>])  <span class="comment"># 输出: datetime.date(2023, 10, 5)</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>&#123;date:%Y-%m-%d&#125;</code> 提取日期，并将其转换为 <code>datetime.date</code> 对象。</p>
<hr>
<h3 id="6-自定义提取模式"><a href="#6-自定义提取模式" class="headerlink" title="6. 自定义提取模式"></a>6. <strong>自定义提取模式</strong></h3><p><code>parse</code> 库允许用户通过正则表达式自定义提取模式。</p>
<h4 id="示例-5：自定义提取模式"><a href="#示例-5：自定义提取模式" class="headerlink" title="示例 5：自定义提取模式"></a>示例 5：自定义提取模式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> parse, with_pattern</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="meta">@with_pattern(<span class="params"><span class="string">r&quot;\d+&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_number</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(text)</span><br><span class="line"></span><br><span class="line">result = parse(<span class="string">&quot;The number is &#123;number:Number&#125;&quot;</span>, </span><br><span class="line">               <span class="string">&quot;The number is 42&quot;</span>, &#123;<span class="string">&quot;Number&quot;</span>: parse_number&#125;)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="string">&quot;number&quot;</span>])  <span class="comment"># 输出: 42</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>parse_number</code> 是一个自定义的解析函数，用于提取整数。通过 <code>with_pattern</code> 装饰器将其注册为 <code>Number</code> 类型。</p>
<hr>
<h3 id="7-处理解析失败"><a href="#7-处理解析失败" class="headerlink" title="7. 处理解析失败"></a>7. <strong>处理解析失败</strong></h3><p>如果 <code>parse()</code> 函数无法解析输入字符串，会返回 <code>None</code>。可以通过检查返回值来处理解析失败的情况。</p>
<h4 id="示例-6：处理解析失败"><a href="#示例-6：处理解析失败" class="headerlink" title="示例 6：处理解析失败"></a>示例 6：处理解析失败</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">result = parse(<span class="string">&quot;My name is &#123;&#125;&quot;</span>, <span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解析失败&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(result[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python当中的range_map</title>
    <url>/2023/05/30/python%E5%BD%93%E4%B8%AD%E7%9A%84range-map/</url>
    <content><![CDATA[<p>在python当中的字典能让使用者快速找到对应的数据值，但是如果想要实现这样的一个字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_<span class="built_in">dict</span> = &#123;</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>):<span class="string">&quot;a&quot;</span>,</span><br><span class="line">    [<span class="number">5</span>,<span class="number">10</span>):<span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能让操作者在仅知道一个数值就可以索引到范围对应的那个value，如<code>_dict[3]</code>输出<code>&quot;a&quot;</code>该怎么做呢？</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>可以借助<code>python</code>库<code>bisect</code>对字典进行重写解决该问题，<code>bisect</code>相关信息就不过多阐述了，简单来说就是通过排序算法，定位指定值在范围内的位置，再通过索引找到位置。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> MutableMapping</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RangeBisection</span>(<span class="title class_ inherited__">MutableMapping</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">map</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self._upper = []</span><br><span class="line">        self._lower = []</span><br><span class="line">        self._values = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.update(<span class="built_in">map</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._values)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, point_or_range</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(point_or_range, <span class="built_in">tuple</span>):</span><br><span class="line">            low, high = point_or_range</span><br><span class="line">            i = bisect_right(self._upper, high)</span><br><span class="line">            point = low</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            point = point_or_range</span><br><span class="line">            i = bisect_right(self._upper, point)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(self._values) <span class="keyword">or</span> self._lower[i] &gt; point:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(point_or_range)</span><br><span class="line">        <span class="keyword">return</span> self._values[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, r, value</span>):</span><br><span class="line">        lower, upper = r</span><br><span class="line">        i = bisect_right(self._upper, upper)</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(self._values) <span class="keyword">and</span> self._lower[i] &lt; upper:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;No overlaps permitted&#x27;</span>)</span><br><span class="line">        self._upper.insert(i, upper)</span><br><span class="line">        self._lower.insert(i, lower)</span><br><span class="line">        self._values.insert(i, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, r</span>):</span><br><span class="line">        lower, upper = r</span><br><span class="line">        i = bisect_right(self._upper, upper)</span><br><span class="line">        <span class="keyword">if</span> self._upper[i] != upper <span class="keyword">or</span> self._lower[i] != lower:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Range not in map&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> self._upper[i]</span><br><span class="line">        <span class="keyword">del</span> self._lower[i]</span><br><span class="line">        <span class="keyword">del</span> self._values[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">zip</span>(self._lower, self._upper)</span><br><span class="line"></span><br><span class="line">d = RangeBisection(&#123;</span><br><span class="line">    (<span class="number">0.0</span>, <span class="number">0.1</span>): <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    (<span class="number">0.1</span>, <span class="number">0.3</span>): <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    (<span class="number">0.3</span>, <span class="number">0.55</span>): <span class="string">&quot;c&quot;</span>,</span><br><span class="line">    (<span class="number">0.55</span>, <span class="number">0.7</span>): <span class="string">&quot;d&quot;</span>,</span><br><span class="line">    (<span class="number">0.7</span>, <span class="number">1.0</span>): <span class="string">&quot;e&quot;</span>,&#125;)</span><br><span class="line">d[<span class="number">0.0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python当中的回调函数是个啥？</title>
    <url>/2022/11/08/python%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p>在编程过程当中，一直在使用回调函数，但是自己却一直没有去深究回调函数究竟是个啥东西！因为使用的时候用就完事了。现在来深究一下！</p>
<h2 id="回调函数的定义"><a href="#回调函数的定义" class="headerlink" title="回调函数的定义"></a>回调函数的定义</h2><p>回调函数就是一个被作为参数传递的函数。在C语言中，回调函数只能使用函数指针实现，在C++、Python、ECMAScript等更现代的编程语言中还可以使用仿函数或匿名函数。</p>
<p>百度百科解释其机制:</p>
<ul>
<li>定义一个回调函数；</li>
<li>提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；</li>
<li>当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</li>
</ul>
<p>简单来理解就是在最开始初始化一个函数，当需要使用到这个函数的时候调用这个函数指针对事件进行处理。这个解释其实也不简单，因为如果你使用的是python，没有指针会很难理解。</p>
<p>由于在python中已经没有指针的概念，所以函数名字将作为参数传递给另一个函数作为参数，在事件触发的时候调用。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">callbcak_func</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="built_in">print</span>(*args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">caller</span>(<span class="params">args, func</span>):</span><br><span class="line">    func(args)</span><br><span class="line"></span><br><span class="line">caller((<span class="number">1</span>,<span class="number">2</span>), callbcak_func)</span><br></pre></td></tr></table></figure>

<p>软件模块之间总是存在着一定的接口,从调用方式上,可以把他们分为三类: 同步调用、回调和异步调用。</p>
<ul>
<li>同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；</li>
<li>回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；</li>
<li>异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口.</li>
</ul>
<p>回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title>python打包成exe后的路径在哪里？</title>
    <url>/2024/12/01/python%E6%89%93%E5%8C%85%E6%88%90exe%E5%90%8E%E7%9A%84%E8%B7%AF%E5%BE%84%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="项目目录路径的获取"><a href="#项目目录路径的获取" class="headerlink" title="项目目录路径的获取"></a>项目目录路径的获取</h2><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>这段Python代码的目的是确定项目目录的路径，它通过检查sys模块的frozen属性来判断当前脚本是被直接运行还是被打包成了可执行文件。这个属性在PyInstaller等打包工具中被设置为True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">getattr</span>(sys, <span class="string">&quot;frozen&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">    PROJ_PATH = os.path.normpath(os.path.join(</span><br><span class="line">        sys.executable,</span><br><span class="line">        os.pardir,  <span class="comment"># 上一级目录(..)</span></span><br><span class="line">    ))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    PROJ_PATH = os.path.normpath(os.path.join(</span><br><span class="line">        os.path.abspath(__file__),  <span class="comment"># 当前文件的绝对路径</span></span><br><span class="line">        os.pardir,  <span class="comment"># 上一级目录(..)</span></span><br><span class="line">        os.pardir,  <span class="comment"># 上一级目录(..)</span></span><br><span class="line">    ))</span><br><span class="line"><span class="built_in">getattr</span>(sys, <span class="string">&quot;frozen&quot;</span>, <span class="literal">False</span>)：尝试获取sys模块的frozen属性，如果不存在则默认为<span class="literal">False</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sys.executable</code>：如果脚本被打包成了可执行文件，sys.executable是可执行文件的路径。</li>
<li><code>os.path.normpath(path)</code>：规范化路径，去除路径中的冗余部分，如多余的分隔符和上级目录引用（..）。</li>
<li><code>os.path.join(path, *paths)</code>：将多个路径组合成一个路径。</li>
<li><code>os.pardir</code>：是一个常量，代表上级目录（..）。</li>
<li><code>os.path.abspath(__file__)</code>：获取当前文件的绝对路径。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据校验</title>
    <url>/2022/04/24/python%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="什么是数据校验？"><a href="#什么是数据校验？" class="headerlink" title="什么是数据校验？"></a>什么是数据校验？</h2><p>在实际的开发过程当中，我们往往会面临很多需要数据对接的情况，这时候一个函数可能需要处理一个或者多个数据参数，也就是说函数的参数面临着多且不确定性，参数本身不确定性还伴随着在传递过程当中是否符合规范的问题。以python函数为例，以下是随意写法和标准写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随意</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> a&gt;b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">elif</span> a&lt;b:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建议的标准写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a:<span class="built_in">int</span>=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">        b:<span class="built_in">int</span>=<span class="number">0</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这里描述函数的功能</span></span><br><span class="line"><span class="string">    :param a: 参数描述</span></span><br><span class="line"><span class="string">    :param b: 参数描述</span></span><br><span class="line"><span class="string">    :returns: 返回描述</span></span><br><span class="line"><span class="string">    :raises keyError: 可能的错误捕获描述</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> a&gt;b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">elif</span> a&lt;b:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>除此之外还有<code>def exmaple2(required_arg, *arg, **kwarg):</code>这样的写法，这些写法都是在极力是的python的函数与参数信息更加明确，让调用函数的时候能够清楚的知道函数的作用。<br>由于需求的复杂逐步增加，因此数据接口从原先的单纯的写法升级为固定规则，需要一些额外的协助手段才能够帮助使用者规范接口，<code>pydantic</code>库的出现极大程度的解决了这些问题。</p>
<h2 id="pydantic库的基础"><a href="#pydantic库的基础" class="headerlink" title="pydantic库的基础"></a>pydantic库的基础</h2><h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><h4 id="schema基本定义方法"><a href="#schema基本定义方法" class="headerlink" title="schema基本定义方法"></a>schema基本定义方法</h4><p>pydantic库的数据定义方式是通过BaseModel类来进行定义的，所有基于pydantic的数据类型本质上都是一个BaseModel类，它最基本的使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br></pre></td></tr></table></figure>

<h4 id="基本的schema实例化方法"><a href="#基本的schema实例化方法" class="headerlink" title="基本的schema实例化方法"></a>基本的schema实例化方法</h4><p>调用时，我们只需要对其进行实例化即可，实例化方法有以下几种：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接传值</span></span><br><span class="line">p = Person(name=<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.json()) <span class="comment"># &#123;&quot;name&quot;: &quot;Tom&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过字典传入</span></span><br><span class="line">p = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">p = Person(**p)</span><br><span class="line"><span class="built_in">print</span>(p.json()) <span class="comment"># &#123;&quot;name&quot;: &quot;Tom&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过其他的实例化对象传入</span></span><br><span class="line">p2 = Person.copy(p)</span><br><span class="line"><span class="built_in">print</span>(p2.json()) <span class="comment"># &#123;&quot;name&quot;: &quot;Tom&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当传入值错误的时候，pydantic就会抛出报错，例如：<code>Person(person=&quot;Tom&quot;)</code> ;pydantic会抛出异常;另一方面，如果传入值多于定义值时，BaseModel也会自动对其进行过滤。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person(name=<span class="string">&quot;Tom&quot;</span>, gender=<span class="string">&quot;man&quot;</span>, age=<span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(p.json()) <span class="comment"># &#123;&quot;name&quot;: &quot;Tom&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，额外的参数gender与age都被自动过滤了。通过这种方式，数据的传递将会更为安全，但是，同样的，这也要求我们在前期的schema定义中必须要尽可能地定义完全。此外，pydantic在数据传输时会直接进行数据类型转换，因此，如果数据传输格式错误，但是可以通过转换变换为正确的数据类型是，数据传输也可以成功，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person(name=<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(p.json()) <span class="comment"># &#123;&quot;name&quot;: &quot;123&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="pydantic基本数据类型"><a href="#pydantic基本数据类型" class="headerlink" title="pydantic基本数据类型"></a>pydantic基本数据类型</h4><p>下面，我们来看一下pydantic中的一些常用的基本类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span>, <span class="type">Sequence</span>, <span class="type">Set</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    a: <span class="built_in">int</span> <span class="comment"># 整型</span></span><br><span class="line">    b: <span class="built_in">float</span> <span class="comment"># 浮点型</span></span><br><span class="line">    c: <span class="built_in">str</span> <span class="comment"># 字符串</span></span><br><span class="line">    d: <span class="built_in">bool</span> <span class="comment"># 布尔型</span></span><br><span class="line">    e: <span class="type">List</span>[<span class="built_in">int</span>] <span class="comment"># 整型列表</span></span><br><span class="line">    f: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] <span class="comment"># 字典型，key为str，value为int</span></span><br><span class="line">    g: <span class="type">Set</span>[<span class="built_in">int</span>] <span class="comment"># 集合</span></span><br><span class="line">    h: <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] <span class="comment"># 元组</span></span><br></pre></td></tr></table></figure>

<p>以上都是基础的使用，在实际使用过程当中，可以参考官方文档，会给出更加详细的写法。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>数据校验常常使用在需要被绑定在一起的复杂数据之上，也用于数据传递的校验，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span>  <span class="comment"># 无默认值，必填字段</span></span><br><span class="line">    name = <span class="string">&#x27;John Doe&#x27;</span>  <span class="comment"># 有默认值，选填字段</span></span><br><span class="line">    signup_ts: <span class="type">Optional</span>[datetime] = <span class="literal">None</span>  <span class="comment"># 选填字段</span></span><br><span class="line">    friends: <span class="type">List</span>[<span class="built_in">int</span>] = []  <span class="comment"># 列表中的元素是int类型或者是可以转换成int类型的其他类型</span></span><br><span class="line"></span><br><span class="line">error_data = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;a123&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;signup_ts&#x27;</span>: <span class="string">&#x27;2017-06-01 12:22&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;friends&#x27;</span>: [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    User(**error_data)</span><br><span class="line"><span class="keyword">except</span> ValidationError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.json())</span><br></pre></td></tr></table></figure>

<p>这个案例展示了数据在接受错误参数的时候进行的自动校验，这样在数据十分复杂的情况下的时候就能够及时的判定数据是否传输异常而不是去一个个检查数据的状态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个规范性的问题，不需要太多总结，反而需要足够的代码经验去填补这方面经验的缺失。个人也注意到这个问题，因此写下一篇超短的文章记录一下。<br>最后附上官网地址，只有全英文的：<a href="https://pydantic-docs.helpmanual.io/">https://pydantic-docs.helpmanual.io/</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>python海象语法</title>
    <url>/2022/05/22/python%E6%B5%B7%E8%B1%A1%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在我的工作当中，无意间接触到了一个别人写的一段代码,像这样：<code>if (n := len(a)) &gt; 10:</code>，凭借我的直觉，我能够轻易的读懂这段代码，但是我却从来没见过，于是我搜了一下，才知道这是python3.8的新语法，叫做海象语法，因为冒号像眼睛，等号像牙齿，所以被成为海象语法。</p>
<h2 id="海象语法"><a href="#海象语法" class="headerlink" title="海象语法"></a>海象语法</h2><p>官方给出了几个案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 赋值表达式有助于避免调用 len（） 两次</span></span><br><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;List is too long (<span class="subst">&#123;n&#125;</span> elements, expected &lt;= 10)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次用于测试是否发生了匹配，另一次用于提取子组</span></span><br><span class="line">discount = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">if</span> (mo := re.search(<span class="string">r&#x27;(\d+)% discount&#x27;</span>, advertisement)):</span><br><span class="line">    discount = <span class="built_in">float</span>(mo.group(<span class="number">1</span>)) / <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Loop over fixed length blocks</span></span><br><span class="line"><span class="keyword">while</span> (block := f.read(<span class="number">256</span>)) != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    process(block)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中表达式正文中还需要在筛选条件中计算的值</span></span><br><span class="line">[clean_name.title() <span class="keyword">for</span> name <span class="keyword">in</span> names</span><br><span class="line"> <span class="keyword">if</span> (clean_name := normalize(<span class="string">&#x27;NFC&#x27;</span>, name)) <span class="keyword">in</span> allowed_names]</span><br></pre></td></tr></table></figure>

<p>在原来的python语言当中，需要判断的时候不能够将表达式赋值给变量，因此在进行判断操作之前，必须首先对判断变量进行赋值，而海象运算符使用得当可以极大程度的减少对于冗余代码的使用，免去过多的赋值操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该写点什么，还是算吧！</p>
]]></content>
      <categories>
        <category>海象语法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的logging库记录</title>
    <url>/2022/10/17/python%E7%9A%84logging%E5%BA%93%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在最近的工作当中，需要使用到python的一个常见库叫做<code>logging</code>,这个库可以用于项目的日志记录，但是在我使用的过程当中却需要多个log对象分别输出到不同的日志文件当中的时候，我使用以下代码失败了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,</span><br><span class="line">                    datefmt=<span class="string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,</span><br><span class="line">                    filename=<span class="string">&#x27;test.log&#x27;</span>,</span><br><span class="line">                    filemode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log = logging</span><br><span class="line">log.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,</span><br><span class="line">                    datefmt=<span class="string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,</span><br><span class="line">                    filename=<span class="string">&#x27;test2.log&#x27;</span>,</span><br><span class="line">                    filemode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log = logging</span><br><span class="line">log.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>按照我浅薄的理解，这应该是两个对象才对，但是为啥最后只有一个日志文件生成，第二个对象并没有生成日志文件呢？</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>根据官方的解释：</p>
<blockquote>
<p>根据<code>basicConfig</code>源码可以发现只有当“<code>handlers</code>”的长度为0时才会进行日志信息配置，否则跳过该配置步骤。那么在步骤1中root已经自动进行了日志信息配置，“<code>handlers</code>”的长度不为0，则步骤2中的“<code>logging.basicConfig</code>”并没有达到日志信息配置的作用。</p>
</blockquote>
<p>那么有没有什么办法可以解决呢？</p>
<hr>
<p>解决没办法配置的问题的答案当然是有的，那就是在python3.8及之后在basicConfig中新增了force参数，当“force=True”时可以强制进行日志信息重新设置。也就是如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,</span><br><span class="line">                    datefmt=<span class="string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,</span><br><span class="line">                    filename=<span class="string">&#x27;test.log&#x27;</span>,</span><br><span class="line">                    filemode=<span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">                    force=<span class="literal">True</span>) <span class="comment"># 这个参数是重点</span></span><br></pre></td></tr></table></figure>

<p>但是这还是有问题，因为这个仅仅支持重新配置，并不支持将对象保存起来因此如果代码写成了下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,</span><br><span class="line">                    datefmt=<span class="string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,</span><br><span class="line">                    filename=<span class="string">&#x27;test.log&#x27;</span>,</span><br><span class="line">                    filemode=<span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">                    force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">log1 = logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,</span><br><span class="line">                    datefmt=<span class="string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,</span><br><span class="line">                    filename=<span class="string">&#x27;test2.log&#x27;</span>,</span><br><span class="line">                    force=<span class="literal">True</span>,</span><br><span class="line">                    filemode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log2 = logging</span><br><span class="line">log1.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">log2.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行之后就会发现，虽然是两个对象，也生成了两个日志文件，但是却只能往一个文件里面输入日志信息，也就是最后指定的那个文件。</p>
<h2 id="后续疑问"><a href="#后续疑问" class="headerlink" title="后续疑问"></a>后续疑问</h2><p>假设就是需要同时存在两个不同的log对象，用于写入不同的日志文件该怎么办？如果是上述方法，也不可能需要写的时候立马修改吧。在学习中我发现另一种方法能够解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NG_DIC = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="comment"># 日志输出格式</span></span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&quot;[%(levelname)s][%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&quot;</span></span><br><span class="line">                      <span class="string">&quot;[%(message)s]&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&quot;[%(levelname)s] [%(asctime)s] [%(name)s] [%(filename)s:%(lineno)d] [%(message)s]&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="comment"># 日志文件名</span></span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: <span class="string">&quot;log.log&quot;</span>,</span><br><span class="line">            <span class="comment"># 日志文件的最大值,这里我们设置15M</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">15</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="comment"># 日志文件的数量,设置最大日志数量为10</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="comment"># 日志格式</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 当匹配不到logger就会到这条规则</span></span><br><span class="line">        <span class="string">&#x27;tasks&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&quot;file&quot;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">False</span>,  <span class="comment"># 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&quot;file&quot;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">False</span>,  <span class="comment"># 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logging.config.dictConfig(LOGGING_DIC)</span><br><span class="line">logger1 = logging.getLogger(<span class="string">&#x27;tasks&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;123123123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用字典配置的方法可以解决需要创建多个log对象的问题。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>python的match语法与海象语法</title>
    <url>/2024/12/01/python%E7%9A%84match%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%B5%B7%E8%B1%A1%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="python的match语法与海象语法"><a href="#python的match语法与海象语法" class="headerlink" title="python的match语法与海象语法"></a>python的match语法与海象语法</h1><h2 id="match语法"><a href="#match语法" class="headerlink" title="match语法"></a>match语法</h2><p>match语法是python3.10引入的，用于替代if-elif-else的语法，使代码更加简洁易读。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    match status:</span><br><span class="line">        case <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bad request&quot;</span></span><br><span class="line">        case <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        case <span class="number">418</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a teapot&quot;</span></span><br><span class="line">        case _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Something is wrong with the internet&quot;</span></span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    <span class="keyword">if</span> status == <span class="number">400</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bad request&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> status == <span class="number">404</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> status == <span class="number">418</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a teapot&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Something is wrong with the internet&quot;</span></span><br></pre></td></tr></table></figure>
<p>match语法的好处是可以在一个语句中匹配多个条件，而不需要使用多个if-elif-else语句。因此，match语法可以使代码更加简洁易读。</p>
<h2 id="海象语法"><a href="#海象语法" class="headerlink" title="海象语法"></a>海象语法</h2><p>海象语法是python3.8引入的，用于在表达式中赋值，使代码更加简洁易读。可以在if、while、for等语句中使用。案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<p>海象语法在循环中也可以使用，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br></pre></td></tr></table></figure>
<p>海象语法的好处是可以在表达式中直接赋值，而不需要先赋值再使用。因此，海象语法可以使代码更加简洁易读。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现range_map</title>
    <url>/2024/12/01/python%E5%AE%9E%E7%8E%B0range-map/</url>
    <content><![CDATA[<h1 id="自定义RangeBisection：实现Python中的高效Range-Map"><a href="#自定义RangeBisection：实现Python中的高效Range-Map" class="headerlink" title="自定义RangeBisection：实现Python中的高效Range Map"></a>自定义RangeBisection：实现Python中的高效Range Map</h1><p>在Python编程中，我们经常需要处理和存储一系列的范围数据，例如在文件处理、数据库索引或者任何需要范围查询的场景中。然而，Python标准库中并没有直接提供一个专门的“range map”数据结构来高效地处理这些需求。为了填补这一空白，我们可以自定义一个<code>RangeBisection</code>类，它不仅能够存储范围数据，还能在对数时间内完成查找操作，同时确保范围之间不会重叠。本文将详细介绍如何实现这样一个高效的<code>RangeBisection</code>类。</p>
<h2 id="RangeBisection类的核心理念"><a href="#RangeBisection类的核心理念" class="headerlink" title="RangeBisection类的核心理念"></a>RangeBisection类的核心理念</h2><p><code>RangeBisection</code>类的设计初衷是为了提供一个能够快速索引和检索范围的映射（Map）。在这个类中，每个范围由一个下限和一个上限定义，并且每个范围都可以关联一个值。这个类的核心优势在于：</p>
<ul>
<li><strong>高效的查找性能</strong>：通过二分查找算法，可以在O(logN)时间内完成对范围的查找。</li>
<li><strong>范围不重叠</strong>：在插入新范围时，会检查并防止范围重叠，确保数据的一致性。</li>
<li><strong>动态的数据更新</strong>：支持动态地添加、删除和更新范围，适应不断变化的数据需求。</li>
</ul>
<h2 id="RangeBisection类的实现"><a href="#RangeBisection类的实现" class="headerlink" title="RangeBisection类的实现"></a>RangeBisection类的实现</h2><p>以下是<code>RangeBisection</code>类的实现代码，它展示了如何手动实现一个range map：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_right</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> MutableMapping</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RangeBisection</span>(<span class="title class_ inherited__">MutableMapping</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的Range Map，用于存储和检索非重叠的范围。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">map</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self._upper = []</span><br><span class="line">        self._lower = []</span><br><span class="line">        self._values = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.update(<span class="built_in">map</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._values)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, point_or_range</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(point_or_range, <span class="built_in">tuple</span>):</span><br><span class="line">            low, high = point_or_range</span><br><span class="line">            i = bisect_right(self._upper, high)</span><br><span class="line">            point = low</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            point = point_or_range</span><br><span class="line">            i = bisect_right(self._upper, point)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(self._values) <span class="keyword">or</span> self._lower[i] &gt; point:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(point_or_range)</span><br><span class="line">        <span class="keyword">return</span> self._values[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, r, value</span>):</span><br><span class="line">        lower, upper = r</span><br><span class="line">        i = bisect_right(self._upper, upper)</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(self._values) <span class="keyword">and</span> self._lower[i] &lt; upper:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;No overlaps permitted&#x27;</span>)</span><br><span class="line">        self._upper.insert(i, upper)</span><br><span class="line">        self._lower.insert(i, lower)</span><br><span class="line">        self._values.insert(i, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, r</span>):</span><br><span class="line">        lower, upper = r</span><br><span class="line">        i = bisect_right(self._upper, upper)</span><br><span class="line">        <span class="keyword">if</span> self._upper[i] != upper <span class="keyword">or</span> self._lower[i] != lower:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Range not in map&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> self._upper[i]</span><br><span class="line">        <span class="keyword">del</span> self._lower[i]</span><br><span class="line">        <span class="keyword">del</span> self._values[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">zip</span>(self._lower, self._upper)</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><code>__init__</code>方法初始化三个列表：<code>_upper</code>、<code>_lower</code>和<code>_values</code>，分别存储范围的上限、下限和关联的值。如果提供了初始映射，将使用<code>update</code>方法更新实例。</li>
</ul>
<h3 id="获取项"><a href="#获取项" class="headerlink" title="获取项"></a>获取项</h3><ul>
<li><code>__getitem__</code>方法允许通过点或范围来检索值。如果传入的是范围，则找到该范围对应的值；如果是点，则找到包含该点的范围的值。</li>
</ul>
<h3 id="设置项"><a href="#设置项" class="headerlink" title="设置项"></a>设置项</h3><ul>
<li><code>__setitem__</code>方法用于添加或更新范围。它首先检查是否有重叠的范围，如果没有，则将新范围插入到正确的位置。</li>
</ul>
<h3 id="删除项"><a href="#删除项" class="headerlink" title="删除项"></a>删除项</h3><ul>
<li><code>__delitem__</code>方法用于删除指定的范围。如果指定的范围不存在于映射中，将引发<code>IndexError</code>。</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li><code>__iter__</code>方法允许迭代<code>RangeBisection</code>实例中的所有范围，返回一个由范围下限和上限组成的元组。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过自定义<code>RangeBisection</code>类，我们能够在Python中实现一个高效的range map，它不仅能够快速地存储和检索范围数据，还能确保范围之间不会重叠。这个类的应用场景非常广泛，特别是在需要处理大量范围数据的场合。希望本文能够帮助你理解<code>RangeBisection</code>类的实现原理，并在你的项目中有效地应用它。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python的坑记录</title>
    <url>/2022/10/16/python%E7%9A%84%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>在阅读别人博客的时候看到别人记录了一个python的坑，我觉得可能是一个今后会发生的一个错误，因此记录下来。直接上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=[]</span>):</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>打印出来的结果是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1]</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>这是因为, 作为默认参数, python在启动时就会将变量 L 建立, 我们在函数 f 内对 L 处理就会导致后来调用的 L 已经是修改过的 L 了, 我们可以通过打印 L 的内存地址来验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=[]</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(L))</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(L))</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4513289600</span><br><span class="line">4513289600</span><br><span class="line">[1]</span><br><span class="line">4513289600</span><br><span class="line">4513289600</span><br><span class="line">[1, 2]</span><br><span class="line">4513289600</span><br><span class="line">4513289600</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单来说，被声明的默认参数成了一个全局变量</p>
</blockquote>
<p>当然, python的文档中也给出了一个推荐的方法:</p>
<blockquote>
<p>If you don’t want the default to be shared between subsequent calls, you can write the function like this instead:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的基类object当中包含那些常用的内置方法</title>
    <url>/2024/07/25/python%E7%9A%84%E5%9F%BA%E7%B1%BBobject%E5%BD%93%E4%B8%AD%E5%8C%85%E5%90%AB%E9%82%A3%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>在 Python 中，<code>object</code> 类是所有类的基类。它定义了一些内置方法，这些方法在所有对象中都可用。以下是一些常见的 <code>object</code> 类的内置方法及其作用：</p>
<ol>
<li><p><code>__init__(self, ...)</code></p>
<ul>
<li><strong>作用</strong>: 构造函数，用于初始化对象。当创建对象时，这个方法会被自动调用。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__del__(self)</code></p>
<ul>
<li><strong>作用</strong>: 析构函数，当对象被销毁时，这个方法会被调用。注意，Python 的垃圾回收机制会自动处理对象的销毁，所以这个方法通常不需要手动调用。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Object is being destroyed&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="keyword">del</span> obj  <span class="comment"># 或者 obj = None</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__str__(self)</code></p>
<ul>
<li><strong>作用</strong>: 返回对象的字符串表示，当使用 <code>print()</code> 函数或 <code>str()</code> 函数时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;MyClass object with value: <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.value = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(obj)  <span class="comment"># 输出: MyClass object with value: 10</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__repr__(self)</code></p>
<ul>
<li><strong>作用</strong>: 返回对象的“官方”字符串表示，通常用于调试。如果 <code>__repr__</code> 没有被定义，Python 会调用 <code>__str__</code>。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;MyClass(value=<span class="subst">&#123;self.value&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.value = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(obj))  <span class="comment"># 输出: MyClass(value=10)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__eq__(self, other)</code></p>
<ul>
<li><strong>作用</strong>: 比较两个对象是否相等，当使用 <code>==</code> 运算符时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, MyClass):</span><br><span class="line">            <span class="keyword">return</span> self.value == other.value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">10</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1 == obj2)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__ne__(self, other)</code></p>
<ul>
<li><strong>作用</strong>: 比较两个对象是否不相等，当使用 <code>!=</code> 运算符时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__eq__(other)</span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">10</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1 != obj2)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__lt__(self, other)</code></p>
<ul>
<li><strong>作用</strong>: 比较两个对象是否小于，当使用 <code>&lt;</code> 运算符时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, MyClass):</span><br><span class="line">            <span class="keyword">return</span> self.value &lt; other.value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">10</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1 &lt; obj2)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__le__(self, other)</code></p>
<ul>
<li><strong>作用</strong>: 比较两个对象是否小于或等于，当使用 <code>&lt;=</code> 运算符时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, MyClass):</span><br><span class="line">            <span class="keyword">return</span> self.value &lt;= other.value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">10</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1 &lt;= obj2)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__gt__(self, other)</code></p>
<ul>
<li><strong>作用</strong>: 比较两个对象是否大于，当使用 <code>&gt;</code> 运算符时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, MyClass):</span><br><span class="line">            <span class="keyword">return</span> self.value &gt; other.value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">20</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1 &gt; obj2)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__ge__(self, other)</code></p>
<ul>
<li><strong>作用</strong>: 比较两个对象是否大于或等于，当使用 <code>&gt;=</code> 运算符时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ge__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, MyClass):</span><br><span class="line">            <span class="keyword">return</span> self.value &gt;= other.value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">20</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1 &gt;= obj2)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="11">
<li><p><code>__hash__(self)</code></p>
<ul>
<li><strong>作用</strong>: 返回对象的哈希值，当对象需要被用作字典的键或集合的元素时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self.value)</span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">10</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(obj1))  <span class="comment"># 输出: 哈希值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(obj2))  <span class="comment"># 输出: 哈希值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__bool__(self)</code></p>
<ul>
<li><strong>作用</strong>: 返回对象的布尔值，当使用 <code>bool()</code> 函数时，会调用这个方法。如果没有定义 <code>__bool__</code>，Python 会尝试调用 <code>__len__</code> 方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass()</span><br><span class="line">obj1.value = <span class="number">10</span></span><br><span class="line">obj2 = MyClass()</span><br><span class="line">obj2.value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(obj1))  <span class="comment"># 输出: True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(obj2))  <span class="comment"># 输出: False</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__len__(self)</code></p>
<ul>
<li><strong>作用</strong>: 返回对象的长度，当使用 <code>len()</code> 函数时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.values)</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(obj))  <span class="comment"># 输出: 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__getitem__(self, key)</code></p>
<ul>
<li><strong>作用</strong>: 当使用索引操作符 <code>[]</code> 获取对象中的元素时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> self.values[key]</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(obj[<span class="number">1</span>])  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__setitem__(self, key, value)</code></p>
<ul>
<li><strong>作用</strong>: 当使用索引操作符 <code>[]</code> 设置对象中的元素时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self.values[key] = value</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">obj[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(obj.values)  <span class="comment"># 输出: [1, 10, 3]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__delitem__(self, key)</code></p>
<ul>
<li><strong>作用</strong>: 当使用索引操作符 <code>[]</code> 删除对象中的元素时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">del</span> self.values[key]</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> obj[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(obj.values)  <span class="comment"># 输出: [1, 3]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__iter__(self)</code></p>
<ul>
<li><strong>作用</strong>: 返回一个迭代器对象，当使用 <code>for</code> 循环遍历对象时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.values)</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 1 2 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__next__(self)</code></p>
<ul>
<li><strong>作用</strong>: 返回迭代器的下一个元素，当使用 <code>next()</code> 函数时，会调用这个方法。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, values</span>):</span><br><span class="line">        self.values = values</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &lt; <span class="built_in">len</span>(self.values):</span><br><span class="line">            result = self.values[self.index]</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">obj = MyClass([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 1 2 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="补充-function"><a href="#补充-function" class="headerlink" title="补充 function"></a>补充 <code>function</code></h2><p>在 Python 中，函数也是对象，它们是 <code>function</code> 类的实例。你可以使用一些内置函数和方法来获取函数的基本信息。以下是一些常用的方法：</p>
<ol>
<li><p><code>__name__</code></p>
<ul>
<li><strong>作用</strong>: 返回函数的名称。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__name__)  <span class="comment"># 输出: my_function</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__doc__</code></p>
<ul>
<li><strong>作用</strong>: 返回函数的文档字符串（docstring），即函数的注释。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This is a docstring.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__doc__)  <span class="comment"># 输出: This is a docstring.</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__annotations__</code></p>
<ul>
<li><strong>作用</strong>: 返回函数参数和返回值的注解字典。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">param1: <span class="built_in">int</span>, param2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__annotations__)  <span class="comment"># 输出: &#123;&#x27;param1&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;param2&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;return&#x27;: &lt;class &#x27;bool&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__code__</code></p>
<ul>
<li><strong>作用</strong>: 返回一个 <code>code</code> 对象，包含了函数的编译代码。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__code__)  <span class="comment"># 输出: &lt;code object my_function at 0x...&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__defaults__</code></p>
<ul>
<li><strong>作用</strong>: 返回一个元组，包含了函数的默认参数值。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">param1, param2=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__defaults__)  <span class="comment"># 输出: (10,)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__code__.co_varnames</code></p>
<ul>
<li><strong>作用</strong>: 返回一个列表，包含了函数的局部变量名。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">param1, param2</span>):</span><br><span class="line">    local_var = <span class="number">10</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__code__.co_varnames)  <span class="comment"># 输出: (&#x27;param1&#x27;, &#x27;param2&#x27;, &#x27;local_var&#x27;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>__code__.co_argcount</code></p>
<ul>
<li><strong>作用</strong>: 返回函数的参数数量（不包括默认参数）。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">param1, param2</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__code__.co_argcount)  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>inspect.signature()</code></p>
<ul>
<li><strong>作用</strong>: 返回一个 <code>Signature</code> 对象，包含了函数的参数信息。</li>
<li><strong>示例</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">param1, param2=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sig = inspect.signature(my_function)</span><br><span class="line"><span class="built_in">print</span>(sig)  <span class="comment"># 输出: (param1, param2=10)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python进程基础</title>
    <url>/2022/08/01/python%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>在学习python进程相关知识的时候，查询各种网站或者博客，对于进程的解释都没有那么全面，有时候仅给出部分案例，导致代码有时候爆出一些莫名其妙的错误，因此写下这篇基础文章。</p>
<h2 id="python-的三种进程模式"><a href="#python-的三种进程模式" class="headerlink" title="python 的三种进程模式"></a>python 的三种进程模式</h2><p>在python当中进程被分为三种模式，不同的模式有不同的约束条件，也有不同的运行场景，需要依据情况而定：</p>
<table>
<thead>
<tr>
<th><code>fork</code></th>
<th><code>spawn</code></th>
<th><code>forkserver</code></th>
</tr>
</thead>
<tbody><tr>
<td>拷贝几乎程序拥有的所有资源</td>
<td>需要从启动函数处传入程序运行的必要资源</td>
<td>需要从启动函数处传入程序运行的必要资源</td>
</tr>
<tr>
<td>支持文件对象/线程锁等传参</td>
<td>不支持文件对象/线程锁等传参</td>
<td>不支持文件对象/线程锁等传参</td>
</tr>
<tr>
<td>unix</td>
<td>unix/win</td>
<td>部分unix</td>
</tr>
<tr>
<td>快</td>
<td>慢</td>
<td>—</td>
</tr>
<tr>
<td>任意位置创建</td>
<td>main函数开始</td>
<td>main函数开始</td>
</tr>
</tbody></table>
<blockquote>
<p>注：main函数指:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>并非指代函数名为main函数的函数。</p>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a><code>fork</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(ele) <span class="comment"># 不需要传参，创建进程的时候会拷贝资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    ele = []</span><br><span class="line"></span><br><span class="line">    res = multiprocessing.Process(target=task)</span><br><span class="line">    res.start()</span><br></pre></td></tr></table></figure>

<h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a><code>spawn</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">ele</span>):</span><br><span class="line">    <span class="built_in">print</span>(ele) <span class="comment"># 需要传参,否则会报错，但是不能传递文件对象/线程锁等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    ele = []</span><br><span class="line"></span><br><span class="line">    res = multiprocessing.Process(target=task,args=(ele,))</span><br><span class="line">    res.start()</span><br></pre></td></tr></table></figure>

<h3 id="forkserver"><a href="#forkserver" class="headerlink" title="forkserver"></a><code>forkserver</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">ele</span>):</span><br><span class="line">    <span class="built_in">print</span>(ele) <span class="comment"># 需要传参,否则会报错，但是不能传递文件对象/线程锁等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;forkserver&quot;</span>)</span><br><span class="line">    ele = []</span><br><span class="line"></span><br><span class="line">    res = multiprocessing.Process(target=task,args=(ele,))</span><br><span class="line">    res.start()</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>进程创建的时候提到了mmain函数，这里补充一下什么是main函数，在程序运行的过程当中main函数扮演的什么角色。</p>
<h3 id="name-是个啥？"><a href="#name-是个啥？" class="headerlink" title="__name__是个啥？"></a><code>__name__</code>是个啥？</h3><ul>
<li><code>__name__</code>是一个python的内置函数</li>
<li>__name__是python的一个内置类属性，它天生就存在于一个 python 程序中</li>
<li>直接运行python程序时，__name__的值为<code>&quot;__main__&quot;</code></li>
<li>而在其它程序中导入.py文件运行时，__name__的值为文件名，即模块名</li>
</ul>
<h3 id="if-name-quot-main-quot-的作用"><a href="#if-name-quot-main-quot-的作用" class="headerlink" title="if  __name__ == &quot;__main__&quot;的作用"></a><code>if  __name__ == &quot;__main__&quot;</code>的作用</h3><p>最简单的情况：运行当前的module（Py文件）时，因为__name__为”<strong>main</strong>“，所以__main__下方的代码会被顺序执行到。除了这种情况，还有就是在B文件导入A文件的时候，<code>if  __name__ == &quot;__main__&quot;</code>条件下的代码模块不会被一同导入执行。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>python类型注释</title>
    <url>/2022/05/08/python%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<p>我找到一些来自于官方的关于python类型注释的资源，我将其复制下来，用于个人收藏。良好的类型注释习惯能让代码的可读性大大增强，同时也能够保证后续加入的人员能够快速理解与使用。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Python 3.6 在 PEP 526 中引入了用于注释变量的语法，我们在大多数示例中都使用它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is how you declare the type of a variable type in Python 3.6</span></span><br><span class="line">age: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You don&#x27;t need to initialize a variable to annotate it</span></span><br><span class="line">a: <span class="built_in">int</span>  <span class="comment"># Ok (no value at runtime until assigned)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The latter is useful in conditional branches</span></span><br><span class="line">child: <span class="built_in">bool</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    child = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    child = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Set</span>, <span class="type">Dict</span>, <span class="type">Tuple</span>, <span class="type">Optional</span></span><br><span class="line"><span class="comment"># For simple built-in types, just use the name of the type</span></span><br><span class="line">x: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line">x: <span class="built_in">float</span> = <span class="number">1.0</span></span><br><span class="line">x: <span class="built_in">bool</span> = <span class="literal">True</span></span><br><span class="line">x: <span class="built_in">str</span> = <span class="string">&quot;test&quot;</span></span><br><span class="line">x: <span class="built_in">bytes</span> = <span class="string">b&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For collections, the type of the collection item is in brackets</span></span><br><span class="line"><span class="comment"># (Python 3.9+)</span></span><br><span class="line">x: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>]</span><br><span class="line">x: <span class="built_in">set</span>[<span class="built_in">int</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># In Python 3.8 and earlier, the name of the collection type is</span></span><br><span class="line"><span class="comment"># capitalized, and the type is imported from the &#x27;typing&#x27; module</span></span><br><span class="line">x: <span class="type">List</span>[<span class="built_in">int</span>] = [<span class="number">1</span>]</span><br><span class="line">x: <span class="type">Set</span>[<span class="built_in">int</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># For mappings, we need the types of both keys and values</span></span><br><span class="line">x: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>] = &#123;<span class="string">&quot;field&quot;</span>: <span class="number">2.0</span>&#125;  <span class="comment"># Python 3.9+</span></span><br><span class="line">x: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>] = &#123;<span class="string">&quot;field&quot;</span>: <span class="number">2.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># For tuples of fixed size, we specify the types of all the elements</span></span><br><span class="line">x: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">float</span>] = (<span class="number">3</span>, <span class="string">&quot;yes&quot;</span>, <span class="number">7.5</span>)  <span class="comment"># Python 3.9+</span></span><br><span class="line">x: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">float</span>] = (<span class="number">3</span>, <span class="string">&quot;yes&quot;</span>, <span class="number">7.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For tuples of variable size, we use one type and ellipsis</span></span><br><span class="line">x: <span class="built_in">tuple</span>[<span class="built_in">int</span>, ...] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># Python 3.9+</span></span><br><span class="line">x: <span class="type">Tuple</span>[<span class="built_in">int</span>, ...] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Optional[] for values that could be None</span></span><br><span class="line">x: <span class="type">Optional</span>[<span class="built_in">str</span>] = some_function()</span><br><span class="line"><span class="comment"># Mypy understands a value can&#x27;t be None in an if-statement</span></span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(x.upper())</span><br><span class="line"><span class="comment"># If a value can never be None due to some invariants, use an assert</span></span><br><span class="line"><span class="keyword">assert</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(x.upper())</span><br></pre></td></tr></table></figure>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Python 3 支持函数声明的注释语法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span>, Iterator, <span class="type">Union</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is how you annotate a function definition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringify</span>(<span class="params">num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># And here&#x27;s how you specify multiple arguments</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">num1: <span class="built_in">int</span>, num2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add default value for an argument after the type annotation</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">num1: <span class="built_in">int</span>, my_float: <span class="built_in">float</span> = <span class="number">3.5</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> num1 + my_float</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is how you annotate a callable (function) value</span></span><br><span class="line">x: <span class="type">Callable</span>[[<span class="built_in">int</span>, <span class="built_in">float</span>], <span class="built_in">float</span>] = f</span><br><span class="line"></span><br><span class="line"><span class="comment"># A generator function that yields ints is secretly just a function that</span></span><br><span class="line"><span class="comment"># returns an iterator of ints, so that&#x27;s how we annotate it</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; Iterator[<span class="built_in">int</span>]:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can of course split a function annotation over multiple lines</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_email</span>(<span class="params">address: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">list</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               sender: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">               cc: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               bcc: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               subject=<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="params">               body: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">               </span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># An argument can be declared positional-only by giving it a name</span></span><br><span class="line"><span class="comment"># starting with two underscores:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quux</span>(<span class="params">__x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">quux(<span class="number">3</span>)  <span class="comment"># Fine</span></span><br><span class="line">quux(__x=<span class="number">3</span>)  <span class="comment"># Error</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂情况"><a href="#复杂情况" class="headerlink" title="复杂情况"></a>复杂情况</h2><p>from typing import Union, Any, Optional, cast</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># To find out what type mypy infers for an expression anywhere in</span></span><br><span class="line"><span class="comment"># your program, wrap it in reveal_type().  Mypy will print an error</span></span><br><span class="line"><span class="comment"># message with the type; remove it again before running the code.</span></span><br><span class="line">reveal_type(<span class="number">1</span>)  <span class="comment"># -&gt; Revealed type is &quot;builtins.int&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Union when something could be one of a few types</span></span><br><span class="line">x: <span class="built_in">list</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]] = [<span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;fun&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Any if you don&#x27;t know the type of something or it&#x27;s too</span></span><br><span class="line"><span class="comment"># dynamic to write a type for</span></span><br><span class="line">x: <span class="type">Any</span> = mystery_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you initialize a variable with an empty container or &quot;None&quot;</span></span><br><span class="line"><span class="comment"># you may have to help mypy a bit by providing a type annotation</span></span><br><span class="line">x: <span class="built_in">list</span>[<span class="built_in">str</span>] = []</span><br><span class="line">x: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This makes each positional arg and each keyword arg a &quot;str&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, *args: <span class="built_in">str</span>, **kwargs: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    request = make_request(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> self.do_api_query(request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a &quot;type: ignore&quot; comment to suppress errors on a given line,</span></span><br><span class="line"><span class="comment"># when your code confuses mypy or runs into an outright bug in mypy.</span></span><br><span class="line"><span class="comment"># Good practice is to comment every &quot;ignore&quot; with a bug link</span></span><br><span class="line"><span class="comment"># (in mypy, typeshed, or your own code) or an explanation of the issue.</span></span><br><span class="line">x = confusing_function()  <span class="comment"># type: ignore  # https://github.com/python/mypy/issues/1167</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;cast&quot; is a helper function that lets you override the inferred</span></span><br><span class="line"><span class="comment"># type of an expression. It&#x27;s only for mypy -- there&#x27;s no runtime check.</span></span><br><span class="line">a = [<span class="number">4</span>]</span><br><span class="line">b = cast(<span class="built_in">list</span>[<span class="built_in">int</span>], a)  <span class="comment"># Passes fine</span></span><br><span class="line">c = cast(<span class="built_in">list</span>[<span class="built_in">str</span>], a)  <span class="comment"># Passes fine (no runtime check)</span></span><br><span class="line">reveal_type(c)  <span class="comment"># -&gt; Revealed type is &quot;builtins.list[builtins.str]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># -&gt; [4]; the object is not cast</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you want dynamic attributes on your class, have it override &quot;__setattr__&quot;</span></span><br><span class="line"><span class="comment"># or &quot;__getattr__&quot; in a stub or in your source code.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &quot;__setattr__&quot; allows for dynamic assignment to names</span></span><br><span class="line"><span class="comment"># &quot;__getattr__&quot; allows for dynamic access to names</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="comment"># This will allow assignment to any A.x, if x is the same type as &quot;value&quot;</span></span><br><span class="line">    <span class="comment"># (use &quot;value: Any&quot; to allow arbitrary types)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name: <span class="built_in">str</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This will allow access to any A.x, if x is compatible with the return type</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line"></span><br><span class="line">a.foo = <span class="number">42</span>  <span class="comment"># Works</span></span><br><span class="line">a.bar = <span class="string">&#x27;Ex-parrot&#x27;</span>  <span class="comment"># Fails type checking</span></span><br></pre></td></tr></table></figure>

<h2 id="标准“鸭子类型”"><a href="#标准“鸭子类型”" class="headerlink" title="标准“鸭子类型”"></a>标准“鸭子类型”</h2><p>在典型的Python代码中，许多可以将列表或字典作为参数的函数只需要它们的参数以某种方式“类似列表”或“类似字典”。“类似列表”或“类似字典”（或类似的东西）的特定含义被称为“鸭子类型”，并且在惯用Python中常见的几种鸭子类型是标准化的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Mapping, MutableMapping, <span class="type">Sequence</span>, Iterable</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Iterable for generic iterables (anything usable in &quot;for&quot;),</span></span><br><span class="line"><span class="comment"># and Sequence where a sequence (supporting &quot;len&quot; and &quot;__getitem__&quot;) is</span></span><br><span class="line"><span class="comment"># required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">ints: Iterable[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> ints]</span><br><span class="line"></span><br><span class="line">f(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mapping describes a dict-like object (with &quot;__getitem__&quot;) that we won&#x27;t</span></span><br><span class="line"><span class="comment"># mutate, and MutableMapping one (with &quot;__setitem__&quot;) that we might</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">my_mapping: Mapping[<span class="built_in">int</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    my_mapping[<span class="number">5</span>] = <span class="string">&#x27;maybe&#x27;</span>  <span class="comment"># if we try this, mypy will throw an error...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(my_mapping.keys())</span><br><span class="line"></span><br><span class="line">f(&#123;<span class="number">3</span>: <span class="string">&#x27;yes&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;no&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">my_mapping: MutableMapping[<span class="built_in">int</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="built_in">set</span>[<span class="built_in">str</span>]:</span><br><span class="line">    my_mapping[<span class="number">5</span>] = <span class="string">&#x27;maybe&#x27;</span>  <span class="comment"># ...but mypy is OK with this.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(my_mapping.values())</span><br><span class="line"></span><br><span class="line">f(&#123;<span class="number">3</span>: <span class="string">&#x27;yes&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;no&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="comment"># You can optionally declare instance variables in the class body</span></span><br><span class="line">    attr: <span class="built_in">int</span></span><br><span class="line">    <span class="comment"># This is an instance variable with a default value</span></span><br><span class="line">    charge_percent: <span class="built_in">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The &quot;__init__&quot; method doesn&#x27;t return anything, so it gets return</span></span><br><span class="line">    <span class="comment"># type &quot;None&quot; just like any other method that doesn&#x27;t return anything</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For instance methods, omit type for &quot;self&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_method</span>(<span class="params">self, num: <span class="built_in">int</span>, str1: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> num * str1</span><br><span class="line"></span><br><span class="line"><span class="comment"># User-defined classes are valid as types in annotations</span></span><br><span class="line">x: MyClass = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can use the ClassVar annotation to declare a class variable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    seats: ClassVar[<span class="built_in">int</span>] = <span class="number">4</span></span><br><span class="line">    passengers: ClassVar[<span class="built_in">list</span>[<span class="built_in">str</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can also declare the type of an attribute in &quot;__init__&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.items: <span class="built_in">list</span>[<span class="built_in">str</span>] = []</span><br></pre></td></tr></table></figure>

<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Match, IO</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;typing.Match&quot; describes regex matches from the re module</span></span><br><span class="line">x: Match[<span class="built_in">str</span>] = re.match(<span class="string">r&#x27;[0-9]+&#x27;</span>, <span class="string">&quot;15&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use IO[] for functions that should accept or return any</span></span><br><span class="line"><span class="comment"># object that comes from an open() call (IO[] does not</span></span><br><span class="line"><span class="comment"># distinguish between reading, writing or other modes)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sys_IO</span>(<span class="params">mode: <span class="built_in">str</span> = <span class="string">&#x27;w&#x27;</span></span>) -&gt; IO[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> sys.stdout</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> sys.stdin</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> sys.stdout</span><br><span class="line"></span><br><span class="line"><span class="comment"># Forward references are useful if you want to reference a class before</span></span><br><span class="line"><span class="comment"># it is defined</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">foo: A</span>) -&gt; <span class="built_in">int</span>:  <span class="comment"># This will fail</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you use the string literal &#x27;A&#x27;, it will pass as long as there is a</span></span><br><span class="line"><span class="comment"># class of that name later on in the file</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">foo: <span class="string">&#x27;A&#x27;</span></span>) -&gt; <span class="built_in">int</span>:  <span class="comment"># Ok</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python进程基本使用</title>
    <url>/2022/08/01/python%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="p-start-与-p-join"><a href="#p-start-与-p-join" class="headerlink" title="p.start() 与 p.join()"></a><code>p.start()</code> 与 <code>p.join()</code></h3><ul>
<li><code>p.start()</code>:当前进程准备就绪，等待被CPU调度，简单理解也就是启动进程</li>
<li><code>p.join()</code>:等待当前进程的任务执行完毕后再向下继续执行</li>
</ul>
<p>代码如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">ele</span>):</span><br><span class="line">    <span class="built_in">print</span>(ele)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行中&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    ele = []</span><br><span class="line"></span><br><span class="line">    res = multiprocessing.Process(target=task,args=(ele,))</span><br><span class="line">    res.start()</span><br><span class="line">    res.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;继续执行&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>res.join()</code>的出现会使得程序在执行完子进程之后再继续执行主进程，当然，上述案例已经让程序按顺序执行了，进程意义不大了。</p>
<h3 id="p-daemon-bool-守护进程（必须放置在start之前）"><a href="#p-daemon-bool-守护进程（必须放置在start之前）" class="headerlink" title="p.daemon = bool,守护进程（必须放置在start之前）"></a><code>p.daemon = bool</code>,守护进程（必须放置在start之前）</h3><ul>
<li><code>p.daemon = True</code>,设置为守护进程，主进程执行完毕后子进程也将被自动关闭。</li>
<li><code>p.daemon = Flase</code>,设置为非守护进程，主进程等待子进程执行结束之后，主进程才会被关闭结束。</li>
</ul>
<h3 id="获取进程的信息"><a href="#获取进程的信息" class="headerlink" title="获取进程的信息"></a>获取进程的信息</h3><ul>
<li><code>os.getpid</code>与<code>os.getppid</code>:获取进程与父进程的pid</li>
<li><code>len(threading.enumerate())</code>:获取进程下线程个数</li>
<li><code>p.name = &quot;第一个进程&quot;</code>:设置进程名字</li>
<li><code>multiprocessing.current_process().name</code>:获取当前进程的名字</li>
</ul>
<h3 id="自定义进程类"><a href="#自定义进程类" class="headerlink" title="自定义进程类"></a>自定义进程类</h3><p>可以直接讲线程需要做的事情写run方法当中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcess</span>(multiprocessing.Process):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    p = MyProcess(args=(<span class="string">&quot;info&quot;</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;继续执行&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="CPU个数"><a href="#CPU个数" class="headerlink" title="CPU个数"></a>CPU个数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multiprocessing.cpu_count()</span><br></pre></td></tr></table></figure>

<h2 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h2><p>数据共享分为三种情况</p>
<ul>
<li>第一种情况是进程方式选择为<code>fork</code>模式，子进程拷贝了主进程的资源与数据，但是拷贝了已经是完全一个新的变量了，子进程改变并不能导致主进程改变，但是可以共享<code>文件对象对象</code>，实现多个进程同时写入一个文件当中。</li>
<li>第二种情况是接入第三方数据共享平台，如多个进程操控同一个数据库或者同一个文件，通过修改第三方的数据进程数据共享。</li>
<li>最后一种情况是创建一个数据共享对象实现数据共享，案例如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing、</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">key,value</span>):</span><br><span class="line">    dic[key]=value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享字典</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = multiprocessing.Manager()</span><br><span class="line">    dic = m.<span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">         p = multiprocessing.Process(target=task,args=(i,<span class="number">100</span>))</span><br><span class="line">         p.start()</span><br><span class="line">         p.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">args</span>):</span><br><span class="line">    q.put(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享队列</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task,args=(i,))</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line">    v1 = q.get()</span><br><span class="line">    <span class="built_in">print</span>(v1)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>python连接远程服务器</title>
    <url>/2022/09/25/python%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>python连接远程服务器有很多实现方法，但是在我使用的时候却要要求做成服务的形式，连接信息用后端返回的形式。实现方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ssh_tunnel</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">survival_detection</span>(<span class="params">self</span>):</span><br><span class="line">        interval_time = <span class="built_in">int</span>(time.time()) - self.start_time</span><br><span class="line">        <span class="keyword">if</span> interval_time &gt; <span class="number">10800</span>:  <span class="comment"># No operation for more than three hours</span></span><br><span class="line">            self.close_connect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host_ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, user: <span class="built_in">str</span>, pwd: <span class="built_in">str</span></span>):</span><br><span class="line">        self.host_ip = host_ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.pwd = pwd</span><br><span class="line">        self.connect_obj = <span class="literal">None</span></span><br><span class="line">        self.start_time = <span class="number">9000000000</span>  <span class="comment"># The default startup time is very large</span></span><br><span class="line"></span><br><span class="line">        self.sched = BackgroundScheduler()</span><br><span class="line">        self.sched.add_job(self.survival_detection,</span><br><span class="line">                           trigger=<span class="string">&quot;interval&quot;</span>, hours=<span class="number">3</span>)</span><br><span class="line">        self.sched.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">creat_connect</span>(<span class="params">self</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;建立连接&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.connect_obj != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: <span class="number">1</span>, <span class="string">&quot;info&quot;</span>: <span class="string">&quot;&gt;&gt;&gt;&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            trans = paramiko.Transport((self.host_ip, self.port))</span><br><span class="line">            trans.start_client()</span><br><span class="line">            trans.auth_password(self.user, self.pwd)</span><br><span class="line">            channel = trans.open_session(timeout=<span class="number">1200</span>)  <span class="comment"># </span></span><br><span class="line">            channel.get_pty()  <span class="comment"># Acquire terminal</span></span><br><span class="line">            channel.invoke_shell()  <span class="comment"># Activate terminal</span></span><br><span class="line">            <span class="keyword">while</span> channel.recv_ready() == <span class="literal">True</span>:</span><br><span class="line">                time.sleep(<span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            result = channel.recv(<span class="number">10240</span>)</span><br><span class="line">            create_str = result.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            self.connect_obj = channel</span><br><span class="line">            self.start_time = <span class="built_in">int</span>(time.time())</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: <span class="number">1</span>, <span class="string">&quot;info&quot;</span>: create_str&#125;</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;info&quot;</span>: <span class="string">&quot;Remote connection failed！&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute_cmd</span>(<span class="params">self, commd_str: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;执行命令&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.connect_obj == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;info&quot;</span>: <span class="string">&quot;Remote connection failed！&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.connect_obj.send(commd_str + <span class="string">&quot;\n&quot;</span>)  <span class="comment"># type:ignore /Execute command</span></span><br><span class="line">            <span class="keyword">while</span> self.connect_obj.recv_ready() == <span class="literal">True</span>:  <span class="comment"># type:ignore /Result acquisition</span></span><br><span class="line">                time.sleep(<span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            result = self.connect_obj.recv(<span class="number">10240</span>)  <span class="comment"># type:ignore</span></span><br><span class="line">            result = result.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            _result = result[::-<span class="number">1</span>] <span class="comment"># These three lines of code are dealing with some redundant characters. Comments do not affect the overall operation, but only the aesthetics</span></span><br><span class="line">            _<span class="built_in">str</span> = result[<span class="built_in">len</span>(result)-_result.index(<span class="string">&#x27;\r&#x27;</span>)-<span class="number">1</span>::]</span><br><span class="line">            result = result.replace(_<span class="built_in">str</span>*<span class="number">2</span>, _<span class="built_in">str</span>)</span><br><span class="line">            self.start_time = <span class="built_in">int</span>(time.time())  <span class="comment"># Lifetime of each execution refresh</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: <span class="number">1</span>, <span class="string">&quot;info&quot;</span>: result.replace(commd_str.strip()+<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)&#125;</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;info&quot;</span>: <span class="string">&quot;Remote connection failed！&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_connect</span>(<span class="params">self</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">        <span class="keyword">if</span> self.connect_obj == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;info&quot;</span>: <span class="string">&quot;Remote connection failed！&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.connect_obj.close()</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: <span class="number">1</span>, <span class="string">&quot;info&quot;</span>: <span class="string">&#x27;Connection closed!&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: -<span class="number">1</span>, <span class="string">&quot;info&quot;</span>: <span class="string">&quot;Connection closing failed！&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = ssh_tunnel(host_ip=<span class="string">&#x27;*.*.*.*&#x27;</span>,</span><br><span class="line">                      port=<span class="number">22</span>, user=<span class="string">&#x27;root&#x27;</span>, pwd=<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    res = test.creat_connect()</span><br><span class="line">    <span class="built_in">print</span>(res.get(<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;&#x27;</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    commd_str = <span class="built_in">input</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> commd_str != <span class="string">&#x27;-1&#x27;</span>:</span><br><span class="line">        res = test.execute_cmd(commd_str + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res.get(<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;&#x27;</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        commd_str = <span class="built_in">input</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    test.close_connect()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>进程锁与进程池</title>
    <url>/2022/08/08/python%E8%BF%9B%E7%A8%8B%E9%94%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>如果多个进程抢占去对某一个共同的对象的操作的时候，为了防止操作产生冲突，这个时候就可以通过锁的操作来避免。</p>
<h2 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h2><p>以下展示没有使用锁的案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Value,Array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">n,</span>):</span><br><span class="line">    n.value = n.value + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num = Value(<span class="string">&#x27;i&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        p = Process(target=test_func,args=(num,))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(num.value)</span><br></pre></td></tr></table></figure>

<p>当改变<code>time.sleep()</code>的时间，就会发现每一次打印的结果都不一样，是因为多个进程在操作同一个对象的原因，在实际的工作当中，多个进程操作同一个对象是非常危险的时候，很有可能导致数据错乱或者数据不同步的情况发生。但是有两种情况列外，就是在操作队列与管道的时候，这两种数据结构由于自身的性质，只能排队被操作，因此不用担心可能出现的错误。</p>
<p>想要保证操作对象时候数据不会被其他进程串改，需要保证在一个进程操作的时候，其他进程不能够访问该对象，即当前进程锁住该对象。操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">for_fun</span>(<span class="params">lock</span>):</span><br><span class="line">    lock.acquire() <span class="comment"># 加锁</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    lock.release() <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    p = Process(target=for_fun(), args=(lock, ))</span><br></pre></td></tr></table></figure>

<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><blockquote>
<p>为什么要有进程池的概念？</p>
</blockquote>
<p>在实际的需求当中，往往需要创建多个进程，但是进程也不能够随意创建，进程太多不方便管理的同时还会降低效率，因此诞生了进程池，进程池这个对象维护了一个进程管理器，在这个进程池当中，进程是恒定的，被事先设置过。进程池会稳定维护四个进程，并且当任务传递过来后，进程池会接纳所有任务并且让任务等待也存在于进程池当中，不会因为进程不够用而阻塞程序的正常运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor,ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行&quot;</span>,num)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pool.submit(task,ele)</span><br></pre></td></tr></table></figure>

<p>在进程池当中，进程都被进程池管理，如果想要进程在执行完毕后再做其他操作可以使用回调函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;进程池 回调函数 回调函数会把任务函数的结果作为参数执行&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d 进程 work&quot;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">return</span> time.time()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">res</span>):</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;处理回调结果：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(res)))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 在进程池中的每个任务执行完毕时，执行回调函数</span></span><br><span class="line">        <span class="comment"># 使用callback回调函数时，会把工作任务func方法的返回结果传给callback方法进行处理</span></span><br><span class="line">        res = pool.apply_async(func=work, callback=call)</span><br><span class="line">    pool.close()  <span class="comment"># 必须等进程池关闭后，才能使用join()方法</span></span><br><span class="line">    pool.join()  <span class="comment"># 主进程等待子进程结束</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main end&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果进程池当中要使用进程锁。则需要基于Manager钟的Lock和RLock来实现。</p>
</blockquote>
<p>这篇写得草率了，唉！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>python错误：libpython3.6m.so.1.0</title>
    <url>/2023/10/31/python%E9%94%99%E8%AF%AF%EF%BC%9Alibpython3-6m-so-1-0/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libpython3.6m.so.1.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>在linux(centos)中编译安装python完成后，运行python3或python3 -V命令时，可能会报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libpython3.6m.so.1.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>centos系统默认加载/usr/lib,/lib下面库文件，python默认安装到非此类文件夹。(引自<a href="https://blog.csdn.net/learner198461/article/details/54598895">https://blog.csdn.net/learner198461/article/details/54598895</a>)</p>
<p>解决办法</p>
<p>将python3安装目录的lib目录下的文件libpython3.6m.so.1.0复制到/usr/lib/目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/python3/lib/libpython3.6m.so.1.0 /usr/lib/</span><br></pre></td></tr></table></figure>

<p>将目录/usr/lib/添加到/etc/ld.so.conf.d/目录下的python3.6.conf文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/lib&quot;</span> &gt; /etc/ld.so.conf.d/python3.6.conf</span><br></pre></td></tr></table></figure>

<p>运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<p>再运行 python3 或python3 -V，发现没有上述错误了</p>
<h2 id="或"><a href="#或" class="headerlink" title="或"></a>或</h2><p>将python3安装目录的lib目录下的文件libpython3.6m.so.1.0复制到/usr/lib64/目录下即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/python3/lib/libpython3.6m.so.1.0 /usr/lib64</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>错误记录</tag>
      </tags>
  </entry>
  <entry>
    <title>（fastapi一）安装与简单使用</title>
    <url>/2022/05/01/%EF%BC%88fastapi%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>由于自己已经使用过很久的fastapi了，但是到现在为止依然不能够非常熟练，多数时候依然会自己造轮子，走不少弯路，因此打算开始对fastapi进行系列总结。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于fastapi的启动需要<code>uvicorn</code>的配合，因此官方提供两种安装方式，第一种是全部安装，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install fastapi[all]</span><br></pre></td></tr></table></figure>

<p>第二种是分开安装即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install fastapi</span><br><span class="line">pip install uvicorn[standard]</span><br></pre></td></tr></table></figure>

<p>如果安装太慢的话，添加一个临时源吧，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspide</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>fastapi服务创建有两种方式，第一种是通过代码启动，第二种是在命令行启动，如果你需要调试代码，建议你使用第一种，当然，某些编辑器提供直接的调试启动方法，但是需要注意配置启动函数与启动对象。这里给出两种启动方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn <span class="comment"># 必须添加这个库</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(app=<span class="string">&#x27;main:app&#x27;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">8000</span>, reload=<span class="literal">True</span>, debug=<span class="literal">True</span>)<span class="comment"># 启动命令</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件目录下的命令行中输入以下命令：</span></span><br><span class="line"><span class="comment"># uvicorn main:app --host &#x27;0.0.0.0&#x27; --port 8080 --reload</span></span><br></pre></td></tr></table></figure>
<p>uvicorn参数解释:  </p>
<ul>
<li>main: 指定主程序文件main.py文件, 如果main.py文件改成test.py 则命令也需要改为uvicorn test:app</li>
<li>app：在main.py中使用app = FastAPI()创建的对象</li>
<li>–host：远程主机ip，如果是本地则可以不要这个参数</li>
<li>–host：端口号</li>
<li>–reload：在修改源代码后程序会自动重新加载不用退出重新启动</li>
</ul>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>在启动之初，fastapi提供一些关于swagger界面的配置信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI(</span><br><span class="line">    title=<span class="string">&quot;My Super Project&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;This is a very fancy project, with auto docs for the API and everything&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;2.5.0&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>():</span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, access_log=<span class="literal">False</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>同时支持对跨域的配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可跨域访问的域名</span></span><br><span class="line">origins = [</span><br><span class="line">    <span class="string">&quot;http://localhost&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://localhost:8080&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#可跨域访问的基本请求设置</span></span><br><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    allow_origins=origins,</span><br><span class="line">    allow_credentials=<span class="literal">True</span>,</span><br><span class="line">    allow_methods=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">    allow_headers=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多详细的配置可以查看FastAPI的源码进行查看。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title>（fastapi三）中间件</title>
    <url>/2022/05/31/%EF%BC%88fastapi%E4%B8%89%EF%BC%89%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>blog_img/fastapi系列/（fastapi一）安装与简单使用/封面.jpg<br>“中间件”是一个函数,它在每个请求被特定的路径操作处理之前,以及在每个响应返回之前工作.</p>
<ul>
<li>它接收你的应用程序的每一个请求.  </li>
<li>然后它可以对这个请求做一些事情或者执行任何需要的代码.  </li>
<li>然后它将请求传递给应用程序的其他部分 (通过某种路径操作).  </li>
<li>然后它获取应用程序生产的响应 (通过某种路径操作).  </li>
<li>它可以对该响应做些什么或者执行任何需要的代码.  </li>
<li>然后它返回这个 响应.  </li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.middleware(<span class="params"><span class="string">&quot;http&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">add_process_time_header</span>(<span class="params">request: Request, call_next</span>):</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    response = <span class="keyword">await</span> call_next(request)</span><br><span class="line">    process_time = time.time() - start_time</span><br><span class="line">    response.headers[<span class="string">&quot;X-Process-Time&quot;</span>] = <span class="built_in">str</span>(process_time)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>request：项目接受的请求，可以获取请求信息  </li>
<li>call_next：将 request 传递给相应的 路径操作.然后它将返回由相应的路径操作生成的 response.</li>
<li> response.headers[“X-Process-Time”]：修改返回头信息</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>中间件能够在每一个请求接受之前对请求进行操作，捕获请求的信息，并对请求或者返回信息进行修改。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title>（fastapi七）websocket</title>
    <url>/2022/11/11/%EF%BC%88fastapi%E4%B8%83%EF%BC%89websocket/</url>
    <content><![CDATA[<p>记录两段基础代码，分别来自官网与互联网。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, WebSocket</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> HTMLResponse</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;Chat&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;WebSocket Chat&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;button&gt;Send&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;ul id=&#x27;messages&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;script&gt;</span></span><br><span class="line"><span class="string">            var ws = new WebSocket(&quot;ws://localhost:8000/ws&quot;);</span></span><br><span class="line"><span class="string">            ws.onmessage = function(event) &#123;</span></span><br><span class="line"><span class="string">                var messages = document.getElementById(&#x27;messages&#x27;)</span></span><br><span class="line"><span class="string">                var message = document.createElement(&#x27;li&#x27;)</span></span><br><span class="line"><span class="string">                var content = document.createTextNode(event.data)</span></span><br><span class="line"><span class="string">                message.appendChild(content)</span></span><br><span class="line"><span class="string">                messages.appendChild(message)</span></span><br><span class="line"><span class="string">            &#125;;</span></span><br><span class="line"><span class="string">            function sendMessage(event) &#123;</span></span><br><span class="line"><span class="string">                var input = document.getElementById(&quot;messageText&quot;)</span></span><br><span class="line"><span class="string">                ws.send(input.value)</span></span><br><span class="line"><span class="string">                input.value = &#x27;&#x27;</span></span><br><span class="line"><span class="string">                event.preventDefault()</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    <span class="keyword">return</span> HTMLResponse(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.websocket(<span class="params"><span class="string">&quot;/ws&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">websocket_endpoint</span>(<span class="params">websocket: WebSocket</span>):</span><br><span class="line">    <span class="keyword">await</span> websocket.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = <span class="keyword">await</span> websocket.receive_text()</span><br><span class="line">        <span class="keyword">await</span> websocket.send_text(<span class="string">f&quot;Message text was: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, WebSocket, WebSocketDisconnect</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 存放激活的ws连接对象</span></span><br><span class="line">        self.active_connections: <span class="type">List</span>[WebSocket] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, ws: WebSocket</span>):</span><br><span class="line">        <span class="comment"># 等待连接</span></span><br><span class="line">        <span class="keyword">await</span> ws.accept()</span><br><span class="line">        <span class="comment"># 存储ws连接对象</span></span><br><span class="line">        self.active_connections.append(ws)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">disconnect</span>(<span class="params">self, ws: WebSocket</span>):</span><br><span class="line">        <span class="comment"># 关闭时 移除ws对象</span></span><br><span class="line">        self.active_connections.remove(ws)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_personal_message</span>(<span class="params">message: <span class="built_in">str</span>, ws: WebSocket</span>):</span><br><span class="line">        <span class="comment"># 发送个人消息</span></span><br><span class="line">        <span class="keyword">await</span> ws.send_text(message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">broadcast</span>(<span class="params">self, message: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="comment"># 广播消息</span></span><br><span class="line">        <span class="keyword">for</span> connection <span class="keyword">in</span> self.active_connections:</span><br><span class="line">            <span class="keyword">await</span> connection.send_text(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">manager = ConnectionManager()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.websocket(<span class="params"><span class="string">&quot;/ws/&#123;user&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">websocket_endpoint</span>(<span class="params">websocket: WebSocket, user: <span class="built_in">str</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> manager.connect(websocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> manager.broadcast(<span class="string">f&quot;用户<span class="subst">&#123;user&#125;</span>进入聊天室&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = <span class="keyword">await</span> websocket.receive_text()</span><br><span class="line">            <span class="keyword">await</span> manager.send_personal_message(<span class="string">f&quot;你说了: <span class="subst">&#123;data&#125;</span>&quot;</span>, websocket)</span><br><span class="line">            <span class="keyword">await</span> manager.broadcast(<span class="string">f&quot;用户:<span class="subst">&#123;user&#125;</span> 说: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> WebSocketDisconnect:</span><br><span class="line">        manager.disconnect(websocket)</span><br><span class="line">        <span class="keyword">await</span> manager.broadcast(<span class="string">f&quot;用户-<span class="subst">&#123;user&#125;</span>-离开&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    <span class="comment"># 官方推荐是用命令后启动 uvicorn main:app --host=127.0.0.1 --port=8010 --reload</span></span><br><span class="line">    uvicorn.run(app=<span class="string">&#x27;main:app&#x27;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">8010</span>, reload=<span class="literal">True</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>fastapi</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>（fastapi二）参数校验</title>
    <url>/2022/05/08/%EF%BC%88fastapi%E4%BA%8C%EF%BC%89%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>现在有一个实际的问题，我们在完成某一个项目的时候，如果说用户非要从接口传递一些非法参数或者某些人想要搞破坏，传递恶意的参数。如果参数直接与数据库相关，恶意传入一些参数会直接影响到数据库的正常运行，所以我们该怎么处理这些非法参数呢？写个函数验证？但是接口那么多，无穷尽也。但是fastapi提供了一些优雅的解决方式！</p>
<h2 id="额外的校验"><a href="#额外的校验" class="headerlink" title="额外的校验"></a>额外的校验</h2><p>下面是一段代码：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/router/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需求是限制参数<code>q</code>的长度</p>
</blockquote>
<h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><p>官方提供了一个库叫做Query,这个库可以非常简单的做校验，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/router/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, max_length=<span class="number">50</span></span>)</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>我们直接从源码上看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Query</span>(<span class="params">  <span class="comment"># noqa: N802</span></span></span><br><span class="line"><span class="params">    default: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params">    *,</span></span><br><span class="line"><span class="params">    alias: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    title: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    gt: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    ge: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    lt: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    le: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    min_length: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    max_length: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    regex: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    example: <span class="type">Any</span> = Undefined,</span></span><br><span class="line"><span class="params">    examples: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    deprecated: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    include_in_schema: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    **extra: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Any</span>:</span><br></pre></td></tr></table></figure>

<p>其实根据翻译就能够得出这些参数大概是什么意思，如<code>gt、ge、lt、le</code>分别是大于、大于等于、小于、小于等于。但是其中有一个功能却十分强大，即<code>regex</code>。</p>
<p>是的，参数校验可以使用正则表达式，在官方给定的案例中，我们可以看到正则表达式的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params"></span></span><br><span class="line"><span class="params">    q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, min_length=<span class="number">3</span>, max_length=<span class="number">50</span>, regex=<span class="string">&quot;^fixedquery$&quot;</span></span>)</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<p>这个指定的正则表达式通过以下规则检查接收到的参数值：</p>
<ul>
<li>^：以该符号之后的字符开头，符号之前没有字符。</li>
<li>fixedquery: 值精确地等于 fixedquery。</li>
<li>$: 到此结束，在 fixedquery 之后没有更多字符。</li>
</ul>
<p>当然，别名参数<code>alias</code>也是十分有用的，如果你不想让调用函数的人通过参数揣测你的接口含义，你可以通过给参数命别名的方式来混淆别人对函数的判断，从而保证函数的安全。当然，别名也可以使得参数更加规范，或许？</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title>（fastapi五）后台执行程序</title>
    <url>/2022/07/17/%EF%BC%88fastapi%E4%BA%94%EF%BC%89%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>在web开发过程当中，总会需要一种情况，就是用户发送完请求之后只需要确认自己已经发送了指令，并不着急等待最终结果的返回，仅仅需要一个响应状态，如果这个时候程序要等待执行完毕后返回结果，肯定是不合理的，因此fastapi提供一种自己的后台程序处理方法。</p>
<h2 id="BackgroundTasks"><a href="#BackgroundTasks" class="headerlink" title="BackgroundTasks"></a>BackgroundTasks</h2><p>代码案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> BackgroundTasks, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_notification</span>(<span class="params">email: <span class="built_in">str</span>, message=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> email_file:</span><br><span class="line">        content = <span class="string">f&quot;notification for <span class="subst">&#123;email&#125;</span>: <span class="subst">&#123;message&#125;</span>&quot;</span></span><br><span class="line">        email_file.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/send-notification/&#123;email&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_notification</span>(<span class="params">email: <span class="built_in">str</span>, background_tasks: BackgroundTasks</span>):</span><br><span class="line">    background_tasks.add_task(write_notification, email, message=<span class="string">&quot;some notification&quot;</span>) <span class="comment"># 执行后台任务</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Notification sent in the background&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>结合依赖注入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> BackgroundTasks, Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_log</span>(<span class="params">message: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, mode=<span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        log.write(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_query</span>(<span class="params">background_tasks: BackgroundTasks, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        message = <span class="string">f&quot;found query: <span class="subst">&#123;q&#125;</span>\n&quot;</span></span><br><span class="line">        background_tasks.add_task(write_log, message)</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/send-notification/&#123;email&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_notification</span>(<span class="params">email: <span class="built_in">str</span>, </span></span><br><span class="line"><span class="params">                            background_tasks: BackgroundTasks, </span></span><br><span class="line"><span class="params">                            q: <span class="built_in">str</span> = Depends(<span class="params">get_query</span>)</span>):</span><br><span class="line">    message = <span class="string">f&quot;message to <span class="subst">&#123;email&#125;</span>\n&quot;</span></span><br><span class="line">    background_tasks.add_task(write_log, message)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Message sent&quot;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title>（fastapi六）fastapi当中的多进程方案</title>
    <url>/2022/08/29/%EF%BC%88fastapi%E5%85%AD%EF%BC%89fastapi%E5%BD%93%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在使用python创建web服务过程当中，往往有时候需要使用到多进程，这个时候就会出现以下一些问题：</p>
<ul>
<li>多进程怎么管理？</li>
<li>python创建进程拷贝资源导致占用太多怎么办？</li>
<li>进程之间数据怎么通信？</li>
<li>出现某些变量无法被序列化的时候进程通信怎么办？</li>
<li>共享内存的时候数据传输问题？</li>
</ul>
<p>以上问题是我个人在使用fastapi的时候遇到的，问题在于我想要使用fastapi结合某些机器学习的模型为别人提供服务，由于机器学习的模型太过于庞大并且每一次计算都相当的耗费计算资源，因此想要使用多进程的方式进行解决。以下是解决问题的过程！</p>
<h2 id="直接使用fastapi的多进程"><a href="#直接使用fastapi的多进程" class="headerlink" title="直接使用fastapi的多进程"></a>直接使用fastapi的多进程</h2><p>没错fastapi自己也有多进程，只需要在启动的时候添加一个wokers参数就可以了，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">uvicorn.run(app=<span class="string">&#x27;main:app&#x27;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">8000</span>, reload=<span class="literal">True</span>, debug=<span class="literal">True</span>,works=<span class="number">2</span>)<span class="comment"># 启动命令</span></span><br></pre></td></tr></table></figure>

<p>用起来确实可以，但是一启动就炸了，这个多进程本质上多个fastapi一起启动的用法，在我启动之后我就发现了事情的不对，内存占用飙升，因为我第一次开了16个进程，多进程诶！！不过分吧，然后就炸了。</p>
<h3 id="使用python的多进程"><a href="#使用python的多进程" class="headerlink" title="使用python的多进程"></a>使用python的多进程</h3><p>我后来打算直接使用python的多进程，使用倒是没问题，但是我发现把开多进程的位置放在那个地方很有讲究，因为按照程序的设计，我想要的是每一次一个请求分配一个进程才合理，所以如果函数调用太深入，进程越靠后越慢，几乎没啥乱用，并且效率还会更低。并且然后更离谱的事情就出现了，在使用原生的多进程的时候，CPU倒是不会停留在一个CPU上了，但是每次跑满的也只有一个CPU，我日他仙人，这跟没有什么区别。</p>
<p>再就是进程创建使用的是fork模式，直接拷贝父进程的所有资源，我不出意外的内存又炸了。</p>
<h3 id="使用线程池加共享内存"><a href="#使用线程池加共享内存" class="headerlink" title="使用线程池加共享内存"></a>使用线程池加共享内存</h3><p>线程池是我后来想的，害怕请求太多内存炸了，想搞个线程池，然后加上一段共享内存，不久能够保证子进程内存不会激增，又能够保证多个进程数量被控制么。当时觉得简直机智！我才用python自己的进程池还有<code>Manager.dict()</code>保存一些较大的变量，比如机器学习的模型之类的。</p>
<p>但是，但是，但是……真正上手的时候发现，我需要等待进程的返回结果啊，我把进程池声明一个全局变量的话我该怎么去拿到子进程的结果呢？我还要等待进程？没办法，先妥协一下，把进程池改成多进程，每个路由下发一个进程。然后又是坑爹的事情，<code>onnx模型</code>属于复杂模型，不能够被序列化，报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">can‘t pickle onnxruntime.capi.onnxruntime_pybind11_state.InferenceSession objects</span><br></pre></td></tr></table></figure>

<p>所以从一个进程共享到另一个进程的时候报错了。我内心是崩溃的！因为没办法进程共享内存的话，意味着每一个子进程都要占用相当多的资源，这根本不可取。</p>
<h2 id="最后的办法"><a href="#最后的办法" class="headerlink" title="最后的办法"></a>最后的办法</h2><p>最后使用了一种看起来复杂的办法，就是自己创建一个多进程的对象，在多进程对象当中注册一个共享内存的对象，在使用的时候一切都在对象内部发生，注册的对象也能够正常调用，也不会发生复杂模型在共享的时候序列化问题了。</p>
<p>部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app.selfmodel.bo_zh <span class="keyword">import</span> main_t</span><br><span class="line"><span class="keyword">from</span> cnocr <span class="keyword">import</span> CnOcr  <span class="comment"># type:ignore</span></span><br><span class="line"><span class="keyword">from</span> cnstd <span class="keyword">import</span> CnStd  <span class="comment"># type:ignore yum install mesa-libGL -y</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> managers</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> app.ocr_cn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> app.selftranslation <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> app.translation <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> utils.tools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> setting.setting <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GlobalObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ocr_std = CnStd()</span><br><span class="line">        self.model_dict = self.create_model_dict()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_model_dict</span>(<span class="params">self</span>):</span><br><span class="line">        model_dict = &#123;<span class="string">&quot;Helsinki-NLP/opus-mt-en-zh&quot;</span>: get_var(<span class="string">&quot;utils/save_var/opus_mt_en_zh.bin&quot;</span>)&#125; <span class="comment"># 这是被序列化之后保存在本地的模型</span></span><br><span class="line">        <span class="keyword">return</span> model_dict</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getStd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.ocr_std</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_model</span>(<span class="params">self, model_list</span>):</span><br><span class="line">        models = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> model_list:</span><br><span class="line">            models.append(self.model_dict.get(i))</span><br><span class="line">        <span class="keyword">return</span> models</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ocr</span>(<span class="params">self, path</span>):</span><br><span class="line">        res_cn, soc_cn = ocr_std(path, self) <span class="comment"># 遇到不能够序列化的时候可以传递整个对象到到函数当中去，就可以避免这个问题了</span></span><br><span class="line">        <span class="keyword">return</span> res_std, soc_std</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyManager</span>(managers.BaseManager):</span><br><span class="line">    <span class="keyword">pass</span><span class="comment"># 自定义多进程类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc_callback</span>(<span class="params">res</span>):</span><br><span class="line">    res_dict[res.result()[<span class="string">&#x27;task_id&#x27;</span>]] = res.result()[<span class="string">&#x27;res&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> res_dict <span class="comment"># 需要一个全局变量用于捕捉结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc_worker_ocr</span>(<span class="params">gobj, task_id, path: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;task_id&quot;</span>: task_id, <span class="string">&quot;res&quot;</span>: gobj.ocr(path)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc_worker_standTran</span>(<span class="params">gobj, task_id, tran_dict</span>):</span><br><span class="line">    models = gobj.get_model(tran_dict.get(<span class="string">&quot;model_name_list&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;task_id&quot;</span>: task_id, <span class="string">&quot;res&quot;</span>: tran_distribution(models, tran_dict)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc_worker_default</span>(<span class="params">task_id</span>):</span><br><span class="line">    <span class="keyword">return</span> task_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerExecutor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 在Manager中注册自定义类（GlobalObject是我的自定义类, 类内部分别包含普通模型与复杂模型两种）</span></span><br><span class="line">        MyManager.register(<span class="string">&quot;GlobalObject&quot;</span>, GlobalObject)</span><br><span class="line">        manager = MyManager()</span><br><span class="line">        manager.start()</span><br><span class="line">        <span class="comment"># 创建共享对象</span></span><br><span class="line">        self.global_object = manager.GlobalObject()  <span class="comment"># type: ignore</span></span><br><span class="line">        <span class="comment"># 这里不仅可以是ProcessPoolExecutor，也可以是多进程Process或者进程池Pool，各自用法略有不同</span></span><br><span class="line">        _cpu_cunt = multiprocessing.cpu_count() <span class="keyword">if</span> cpu_cunt == <span class="literal">None</span> <span class="keyword">else</span> cpu_cunt <span class="comment"># 配置文件获取两个进程池占用比例以及CPU总数信息</span></span><br><span class="line">        self.executor = ProcessPoolExecutor(<span class="built_in">round</span>(_cpu_cunt*ocr_cunt)) <span class="comment"># 这里可以开展多个进程池，进程池不会互相干扰</span></span><br><span class="line">        self.executor_trans = ProcessPoolExecutor(<span class="built_in">round</span>(_cpu_cunt*tran_cunt))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">self, task_id, task_type, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span>(task_type == <span class="string">&quot;OcrManager&quot;</span>):</span><br><span class="line">            future = self.executor.submit(</span><br><span class="line">                proc_worker_ocr, self.global_object, task_id, path=kwargs.get(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">elif</span>(task_type == <span class="string">&quot;TranManager&quot;</span>):</span><br><span class="line">            future = self.executor_trans.submit(</span><br><span class="line">                proc_worker_standTran, self.global_object, task_id, tran_dict=kwargs.get(<span class="string">&quot;tran_dict&quot;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            future = self.executor.submit(proc_worker_default, task_id)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">executor = ServerExecutor()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>子进程本身需要从主进程获取自己所需要的资源，如果子进程获取太多就会导致一个问题，进程太多资源抢占导致内存交换问题，程序会直接崩溃。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>（fastapi四）文件传输</title>
    <url>/2022/06/07/%EF%BC%88fastapi%E5%9B%9B%EF%BC%89%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h2 id="StreamingResponse"><a href="#StreamingResponse" class="headerlink" title="StreamingResponse"></a>StreamingResponse</h2><p>先看案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> StreamingResponse</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fake_video_streamer</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">b&quot;some fake video bytes&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(fake_video_streamer())</span><br></pre></td></tr></table></figure>

<p>该方法在返回过程当时会将数据以流的形式进行返回,官方对此描述：采用异步生成器或普通生成器/迭代器，然后流式传输响应主体。在作用与文件返回的时候可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> StreamingResponse</span><br><span class="line"></span><br><span class="line">some_file_path = <span class="string">&quot;large-video-file.mp4&quot;</span></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterfile</span>():  <span class="comment"># (1)</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(some_file_path, mode=<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file_like:  <span class="comment"># (2)</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> file_like  <span class="comment"># (3)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(iterfile(), media_type=<span class="string">&quot;video/mp4&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="FileResponse"><a href="#FileResponse" class="headerlink" title="FileResponse"></a>FileResponse</h2><p>与其他响应类型相比，接受不同的参数集进行实例化：  </p>
<ul>
<li>path - 要流式传输的文件的文件路径。  </li>
<li>headers - 任何自定义响应头，传入字典类型。  </li>
<li>media_type - 给出媒体类型的字符串。如果未设置，则文件名或路径将用于推断媒体类型。  </li>
<li>filename - 如果给出，它将包含在响应的 Content-Disposition 中。  </li>
</ul>
<p>文件响应将包含适当的 Content-Length，Last-Modified 和 ETag 的响应头。 使用案例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line">some_file_path = <span class="string">&quot;large-video-file.mp4&quot;</span></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">return</span> FileResponse(some_file_path)</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>两种都是文件传输的一种方式，但是相对于<code>FileResponse</code>,如果面临文件较大的话不推荐使用，虽然该方法可以增加文件大小的容量，但是大文件传输与返回更推荐使用<code>StreamingResponse</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/2022/11/07/docker-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><a href="http://link.hhtjim.com/163/523658940.mp3">http://link.hhtjim.com/163/523658940.mp3</a></p>
<h2 id="关于docker"><a href="#关于docker" class="headerlink" title="关于docker"></a>关于docker</h2><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<blockquote>
<p>翻简单来说就是可以可以打包环境而不需要打包整个虚拟机，只要其他电脑上有dockers，开发者就能让自己的项目在各种条件下执行起来</p>
</blockquote>
<h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><p>使用脚本安装 Docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum update</span><br><span class="line">$ curl -fsSL https://get.docker.com/ | sh</span><br><span class="line">$ sudo service docker start</span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h2><p>docker的镜像其实就是模板，跟我们常见的ISO镜像类似，是一个样板。使用镜像常见的应用或者系统，称之为一个容器。镜像是docker容器运行时的只读模板，镜像可以用来创建docker容器。</p>
<p>Docker 利用容器来运行应用，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令的格式：</span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">-a, --attach=[] 登录容器（以docker run -d启动的容器）</span><br><span class="line">-c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用</span><br><span class="line">--cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">--cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">--cidfile=&quot;&quot; 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</span><br><span class="line">--cpuset=&quot;&quot; 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</span><br><span class="line">-d, --detach=false 指定容器运行于前台还是后台</span><br><span class="line">--device=[] 添加主机设备给容器，相当于设备直通</span><br><span class="line">--dns=[] 指定容器的dns服务器</span><br><span class="line">--dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</span><br><span class="line">-e, --env=[] 指定环境变量，容器中可以使用该环境变量</span><br><span class="line">--entrypoint=&quot;&quot; 覆盖image的入口点</span><br><span class="line">--env-file=[] 指定环境变量文件，文件格式为每行一个环境变量</span><br><span class="line">--expose=[] 指定容器暴露的端口，即修改镜像的暴露端口</span><br><span class="line">-h, --hostname=&quot;&quot; 指定容器的主机名</span><br><span class="line">-i, --interactive=false 打开STDIN，用于控制台交互</span><br><span class="line">--link=[] 指定容器间的关联，使用其他容器的IP、env等信息</span><br><span class="line">--lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用</span><br><span class="line">-m, --memory=&quot;&quot; 指定容器的内存上限</span><br><span class="line">--name=&quot;&quot; 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</span><br><span class="line">--net=&quot;bridge&quot; 容器网络设置</span><br><span class="line">-P, --publish-all=false 指定容器暴露的端口</span><br><span class="line">-p, --publish=[] 指定容器暴露的端口</span><br><span class="line">--privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities</span><br><span class="line">--restart=&quot;&quot; 指定容器停止后的重启策略</span><br><span class="line">--rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</span><br><span class="line">--sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span><br><span class="line">-t, --tty=false 分配tty设备，该可以支持终端登录</span><br><span class="line">-u, --user=&quot;&quot; 指定容器的用户</span><br><span class="line">-v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录</span><br><span class="line">--volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录</span><br><span class="line">-w, --workdir=&quot;&quot; 指定容器的工作目录</span><br></pre></td></tr></table></figure>

<h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<p>Dockerfiel 包含两个常用的命令：</p>
<ul>
<li>FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</li>
<li>RUN：用于执行后面跟着的命令行命令。</li>
</ul>
<p>接着就能执行命令，构建镜像了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t 镜像名称 .     <span class="comment"># 后面的. 指的是当前文件夹 (其实是Dockerfile存放的文件夹)</span></span><br></pre></td></tr></table></figure>

<h2 id="dockercompose"><a href="#dockercompose" class="headerlink" title="dockercompose"></a>dockercompose</h2><p>Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。</p>
<p>Compose 通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p>
<blockquote>
<p>但是,Compose与Docker有兼容性问题，因此需要查询相关表对照表才可以正常使用</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-数据目录更改</title>
    <url>/2025/03/23/docker-%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E6%9B%B4%E6%94%B9/</url>
    <content><![CDATA[<p>将 Docker 的存储目录从默认位置（通常是 /var/lib/docker）更改到指定的目录（例如 /data/docker）是确保程序稳定运行的必要操作。以下介绍如何在 Linux 系统上更改 Docker 的存储目录。</p>
<h2 id="步骤-1：停止-Docker-服务"><a href="#步骤-1：停止-Docker-服务" class="headerlink" title="步骤 1：停止 Docker 服务"></a>步骤 1：停止 Docker 服务</h2><p>在更改存储目录之前，必须先停止 Docker 服务，以避免数据损坏。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br></pre></td></tr></table></figure>
<h2 id="步骤-2：备份现有数据（可选）"><a href="#步骤-2：备份现有数据（可选）" class="headerlink" title="步骤 2：备份现有数据（可选）"></a>步骤 2：备份现有数据（可选）</h2><p>如果你已经有一些数据（如镜像、容器等）在默认的 Docker 存储目录中，建议先备份这些数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -a /var/lib/docker /var/lib/docker_backup</span><br></pre></td></tr></table></figure>
<h2 id="步骤-3：创建新的存储目录"><a href="#步骤-3：创建新的存储目录" class="headerlink" title="步骤 3：创建新的存储目录"></a>步骤 3：创建新的存储目录</h2><p>创建一个新目录，用于存储 Docker 的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /data/docker</span><br></pre></td></tr></table></figure>
<h2 id="步骤-4：更改-Docker-的存储目录"><a href="#步骤-4：更改-Docker-的存储目录" class="headerlink" title="步骤 4：更改 Docker 的存储目录"></a>步骤 4：更改 Docker 的存储目录</h2><p>Docker 使用 daemon.json 文件来配置存储目录。如果该文件不存在，需要创建它。<br>创建或编辑 daemon.json 文件<br>如果 /etc/docker/daemon.json 文件不存在，可以使用以下命令创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<p>如果文件已经存在，直接编辑它。<br>添加或修改 data-root 配置<br>在 daemon.json 文件中，添加或修改以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data-root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/data/docker&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h2 id="步骤-5：更改目录权限"><a href="#步骤-5：更改目录权限" class="headerlink" title="步骤 5：更改目录权限"></a>步骤 5：更改目录权限</h2><p>确保 Docker 服务对新目录有适当的读写权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R root:docker /data/docker</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 711 /data/docker</span><br></pre></td></tr></table></figure>
<h2 id="步骤-6：重新启动-Docker-服务"><a href="#步骤-6：重新启动-Docker-服务" class="headerlink" title="步骤 6：重新启动 Docker 服务"></a>步骤 6：重新启动 Docker 服务</h2><p>重新启动 Docker 服务，使配置生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="步骤-7：验证更改"><a href="#步骤-7：验证更改" class="headerlink" title="步骤 7：验证更改"></a>步骤 7：验证更改</h2><p>验证 Docker 是否正在使用新的存储目录。<br>检查 Docker 的存储目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker info | grep <span class="string">&quot;Docker Root Dir&quot;</span></span><br></pre></td></tr></table></figure>
<p>输出应该显示为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Docker Root Dir: /data/docker</span><br></pre></td></tr></table></figure>

<p>测试 Docker 功能<br>拉取一个镜像并运行一个容器，确保一切正常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull hello-world</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意事项</strong></p>
<ul>
<li>数据迁移（如果需要）<br>如果你之前在默认目录中有数据，并且希望将这些数据迁移到新目录，可以手动移动数据：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> /var/lib/docker/* /data/docker/</span><br></pre></td></tr></table></figure>
然后重新启动 Docker 服务。</li>
<li>磁盘空间<br>确保 /data 目录有足够的磁盘空间来存储 Docker 数据。</li>
<li>权限问题<br>如果在更改目录后遇到权限问题，检查 /data/docker 目录的权限，并确保 Docker 服务可以访问它。</li>
<li>系统重启<br>如果系统重启后 Docker 服务没有自动启动，检查 systemd 配置：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-容器网络通信问题</title>
    <url>/2025/03/23/docker-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h3><p>在Docker容器化部署中，你是否遇到过以下问题？  </p>
<ol>
<li>容器IP地址动态变化（如 <code>172.17.0.2</code>、<code>172.18.0.5</code>），硬编码IP导致服务频繁断连  </li>
<li>端口映射混乱（如 <code>9001:9000</code>），维护文档难以跟踪实际服务端口  </li>
<li>多容器通信需手动维护IP列表，扩容时配置复杂度指数级上升  </li>
</ol>
<p>这些问题本质源于对Docker网络模型的误解。</p>
<hr>
<h2 id="一、问题根源分析"><a href="#一、问题根源分析" class="headerlink" title="一、问题根源分析"></a><strong>一、问题根源分析</strong></h2><h3 id="1-Docker默认网络的局限性"><a href="#1-Docker默认网络的局限性" class="headerlink" title="1. Docker默认网络的局限性"></a><strong>1. Docker默认网络的局限性</strong></h3><ul>
<li>**默认网桥<code>bridge</code>**：所有容器共享同一网段，但 <strong>无内置DNS服务</strong>，只能通过IP通信  </li>
<li><strong>IP动态分配</strong>：容器重启或重建后IP可能变化，导致依赖IP的配置失效  </li>
<li><strong>端口映射暴露过多</strong>：<code>-p</code>参数将容器端口映射到宿主机，易引发端口冲突  </li>
</ul>
<h3 id="2-传统解决方案的缺陷"><a href="#2-传统解决方案的缺陷" class="headerlink" title="2. 传统解决方案的缺陷"></a><strong>2. 传统解决方案的缺陷</strong></h3><ul>
<li><strong>静态IP绑定</strong>：通过<code>--ip</code>固定IP，但违背容器动态伸缩的设计理念  </li>
<li><strong>Host网络模式</strong>：容器直接使用宿主机网络，丧失隔离性，安全隐患大  </li>
<li><strong>手动维护IP列表</strong>：通过脚本或配置文件记录IP，维护成本高且易出错  </li>
</ul>
<hr>
<h2 id="二、标准化解决方案"><a href="#二、标准化解决方案" class="headerlink" title="二、标准化解决方案"></a><strong>二、标准化解决方案</strong></h2><h3 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a><strong>核心原则</strong></h3><p>✅ <strong>以容器名代替IP</strong>：利用Docker内置DNS实现服务发现<br>✅ <strong>网络隔离</strong>：通过自定义网络划分服务边界<br>✅ <strong>端口解耦</strong>：容器间通信使用内部端口，对外暴露最小化  </p>
<hr>
<h3 id="方案实施步骤"><a href="#方案实施步骤" class="headerlink" title="方案实施步骤"></a><strong>方案实施步骤</strong></h3><h4 id="1-创建自定义网络"><a href="#1-创建自定义网络" class="headerlink" title="1. 创建自定义网络"></a><strong>1. 创建自定义网络</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建自定义桥接网络，启用DNS和容器名解析</span></span><br><span class="line">docker network create --driver bridge --subnet 10.10.0.0/24 my_network</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关键参数</strong>：  <ul>
<li><code>--driver bridge</code>：使用桥接模式（默认）  </li>
<li><code>--subnet</code>：指定子网范围，避免与默认网络冲突  </li>
<li><code>--gateway</code>：可选，指定网关IP  </li>
</ul>
</li>
</ul>
<h4 id="2-启动容器并加入自定义网络"><a href="#2-启动容器并加入自定义网络" class="headerlink" title="2. 启动容器并加入自定义网络"></a><strong>2. 启动容器并加入自定义网络</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动MySQL容器，指定网络和别名</span></span><br><span class="line">docker run -d --name mysql \</span><br><span class="line">  --network my_network \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  mysql:8.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Web应用容器，连接同一网络</span></span><br><span class="line">docker run -d --name webapp \</span><br><span class="line">  --network my_network \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  nginx:alpine</span><br></pre></td></tr></table></figure>

<h4 id="3-容器间通信方式"><a href="#3-容器间通信方式" class="headerlink" title="3. 容器间通信方式"></a><strong>3. 容器间通信方式</strong></h4><ul>
<li><strong>使用容器名直接访问</strong>：  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python连接MySQL示例</span></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line">conn = mysql.connector.connect(</span><br><span class="line">    host=<span class="string">&quot;mysql&quot;</span>,    <span class="comment"># 直接使用容器名</span></span><br><span class="line">    user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">    password=<span class="string">&quot;secret&quot;</span>,</span><br><span class="line">    database=<span class="string">&quot;mydb&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><strong>Shell测试</strong>：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入webapp容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it webapp sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试访问MySQL</span></span><br><span class="line">ping mysql          <span class="comment"># 应能解析到正确IP</span></span><br><span class="line">telnet mysql 3306   <span class="comment"># 测试端口连通性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-Docker-Compose统一编排"><a href="#4-Docker-Compose统一编排" class="headerlink" title="4. Docker Compose统一编排"></a><strong>4. Docker Compose统一编排</strong></h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_network</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">secret</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">10.10</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>一键启动</strong>：<code>docker-compose up -d</code>  </li>
<li><strong>自动实现</strong>：网络创建、DNS解析、依赖顺序控制  </li>
</ul>
<hr>
<h2 id="三、高级优化技巧"><a href="#三、高级优化技巧" class="headerlink" title="三、高级优化技巧"></a><strong>三、高级优化技巧</strong></h2><h3 id="1-网络分层架构"><a href="#1-网络分层架构" class="headerlink" title="1. 网络分层架构"></a><strong>1. 网络分层架构</strong></h3><table>
<thead>
<tr>
<th>网络类型</th>
<th>使用场景</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>前端网络</td>
<td>面向公网的服务</td>
<td>Nginx、API网关</td>
</tr>
<tr>
<td>后端网络</td>
<td>内部微服务通信</td>
<td>MySQL、Redis</td>
</tr>
<tr>
<td>管理网络</td>
<td>监控/日志收集</td>
<td>Prometheus、ELK</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建多层级网络</span></span><br><span class="line">docker network create frontend</span><br><span class="line">docker network create backend</span><br><span class="line">docker network create monitor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器接入多个网络</span></span><br><span class="line">docker network connect frontend nginx</span><br><span class="line">docker network connect backend nginx</span><br></pre></td></tr></table></figure>

<h3 id="2-服务别名（Alias）"><a href="#2-服务别名（Alias）" class="headerlink" title="2. 服务别名（Alias）"></a><strong>2. 服务别名（Alias）</strong></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml片段</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cache.prod</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">redis-v6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其他容器可通过<code>cache.prod</code>或<code>redis-v6</code>访问同一服务  </li>
</ul>
<h3 id="3-反向代理统一入口"><a href="#3-反向代理统一入口" class="headerlink" title="3. 反向代理统一入口"></a><strong>3. 反向代理统一入口</strong></h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nginx配置示例</span></span><br><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> webapp1:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server</span> webapp2:<span class="number">80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对外暴露80端口，内部自动负载均衡  </li>
</ul>
<hr>
<h2 id="四、常见问题解答"><a href="#四、常见问题解答" class="headerlink" title="四、常见问题解答"></a><strong>四、常见问题解答</strong></h2><p><strong>Q1：宿主机如何访问容器服务？</strong>  </p>
<ul>
<li>方法1：通过<code>docker inspect</code>查询映射端口，访问<code>localhost:映射端口</code>  </li>
<li>方法2：将宿主机加入Docker网络（需配置<code>host.docker.internal</code>解析）  </li>
</ul>
<p><strong>Q2：跨主机容器如何通信？</strong>  </p>
<ul>
<li>方案1：使用Overlay网络（Swarm模式）  </li>
<li>方案2：Calico/Flannel等第三方网络插件  </li>
</ul>
<p><strong>Q3：如何监控网络流量？</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看容器实时流量</span></span><br><span class="line">docker stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tcpdump抓包</span></span><br><span class="line">docker <span class="built_in">exec</span> -it webapp tcpdump -i eth0 port 80</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、方案对比"><a href="#五、方案对比" class="headerlink" title="五、方案对比"></a><strong>五、方案对比</strong></h2><table>
<thead>
<tr>
<th>方案</th>
<th>易用性</th>
<th>可维护性</th>
<th>扩展性</th>
<th>安全性</th>
</tr>
</thead>
<tbody><tr>
<td>硬编码IP</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>默认桥接网络</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>自定义网络+DNS</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Kubernetes Service</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>通过自定义网络与Docker DNS的深度整合，开发者可以：  </p>
<ol>
<li>彻底摆脱IP硬编码，实现<strong>服务发现自动化</strong>  </li>
<li>通过网络分层实现<strong>流量隔离与安全管控</strong>  </li>
<li>结合Docker Compose达到<strong>基础设施即代码（IaC）</strong>  </li>
</ol>
<blockquote>
<p><strong>“优秀的架构不是解决问题，而是让问题不再出现。”</strong> 掌握Docker网络模型，让容器化部署真正实现弹性与可维护性。</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>单节点k8s安装部署文档</title>
    <url>/2025/03/23/k8s-%E5%8D%95%E8%8A%82%E7%82%B9k8s%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="在-Ubuntu-中使用阿里源部署单节点-Kubernetes-集群"><a href="#在-Ubuntu-中使用阿里源部署单节点-Kubernetes-集群" class="headerlink" title="在 Ubuntu 中使用阿里源部署单节点 Kubernetes 集群"></a>在 Ubuntu 中使用阿里源部署单节点 Kubernetes 集群</h2><p>本教程是在 Ubuntu 操作系统中使用阿里云镜像源部署单节点 Kubernetes 集群。将使用 kubeadm 工具进行部署。</p>
<p><strong>前提条件:</strong></p>
<ul>
<li>已安装 Docker (本教程省略 Docker 安装步骤)</li>
<li>Ubuntu 操作系统 (当前版本：<code>Linux shumo-ai 5.11.0-27-generic #29~20.04.1-Ubuntu SMP Wed Aug 11 15:58:17 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</code>)</li>
<li>官方建议至少 2GB RAM 和 2 CPU 核心</li>
<li>稳定的网络连接(当前教程为联网教程)</li>
<li>root 或具有 sudo 权限的用户</li>
</ul>
<p><strong>步骤 1: 更新系统并安装依赖</strong></p>
<ol>
<li><p>更新系统软件包列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li>
<li><p>安装必要的依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>步骤 2: 添加阿里云 Kubernetes 镜像源</strong></p>
<ol>
<li><p>添加阿里云 Kubernetes 镜像源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li>
<li><p>更新软件包列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>步骤 3: 安装 kubeadm、kubelet 和 kubectl</strong></p>
<ol>
<li><p>安装 kubeadm、kubelet 和 kubectl：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure></li>
<li><p>设置 kubelet 开机自启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>步骤 4: 初始化 Kubernetes 控制平面</strong></p>
<ol>
<li><p>初始化 Kubernetes 控制平面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --image-repository registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>如果遇到报错，可以添加参数<code>--v=5</code>输出详细报错内容，根据报错内容进行排查。</p>
</blockquote>
<p>   此命令将输出类似以下内容：</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>按照输出提示，执行以下命令配置 kubectl：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>步骤 5: 安装 Pod 网络插件</strong></p>
<ol>
<li><p>安装 Calico 网络插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.14/manifests/calico.yaml</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>步骤 6: 移除 Master 节点污点</strong></p>
<p>默认情况下，Kubernetes Master 节点会打上污点，防止普通 Pod 调度到该节点。对于单节点集群，我们需要移除该污点：</p>
<ol>
<li><p>查看节点名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure></li>
<li><p>移除污点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes &lt;node-name&gt; node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;node-name&gt;</code> 替换为实际的节点名称。</p>
</li>
</ol>
<p><strong>步骤 7: 验证集群状态</strong></p>
<ol>
<li><p>查看节点状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<p>输出应显示节点状态为 <code>Ready</code>。</p>
</li>
<li><p>查看 Pod 状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure>

<p>输出应显示所有 Pod 状态为 <code>Running</code> 或 <code>Completed</code>。</p>
</li>
</ol>
<p><strong>如果没有问题，目前就已经安装好了</strong></p>
<p><strong>官方注意事项:</strong></p>
<p>在许多教程中，并不推荐单节点部署，因此需要注意以下几点：</p>
<ul>
<li>单节点不利于实际生产环境，生产环境建议使用多节点集群。</li>
<li>单节点集群存在单点故障风险，建议在生产环境中使用高可用方案。</li>
<li>您可以根据需要选择其他 Pod 网络插件，例如 Flannel、Weave Net 等。</li>
</ul>
<p><strong>参考文档:</strong></p>
<ul>
<li>Kubernetes 官方文档: <a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a></li>
<li>阿里云 Kubernetes 镜像源: <a href="https://mirrors.aliyun.com/kubernetes/apt/">https://mirrors.aliyun.com/kubernetes/apt/</a></li>
<li>Calico 网络插件: <a href="https://docs.projectcalico.org/">https://docs.projectcalico.org/</a></li>
</ul>
<h3 id="补充注意事项"><a href="#补充注意事项" class="headerlink" title="补充注意事项"></a>补充注意事项</h3><h4 id="注意事项一：单独下载镜像或查看下载的镜像列表"><a href="#注意事项一：单独下载镜像或查看下载的镜像列表" class="headerlink" title="注意事项一：单独下载镜像或查看下载的镜像列表"></a>注意事项一：单独下载镜像或查看下载的镜像列表</h4><p>在执行 <code>sudo kubeadm init --image-repository registry.aliyuncs.com/google_containers</code> 时，如果网络较差，或者希望预先下载镜像，或者想了解具体下载了哪些镜像，可以按照以下步骤操作：</p>
<ol>
<li><p><strong>查看需要下载的镜像列表</strong><br>使用以下命令可以查看 <code>kubeadm</code> 初始化时需要下载的镜像列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config images list --image-repository registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure></li>
<li><p><strong>手动下载镜像</strong><br>如果网络较差，可以手动下载这些镜像。使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>
<p>该命令会拉取所有需要的镜像到本地。</p>
</li>
<li><p><strong>验证镜像是否下载成功</strong><br>使用以下命令查看已下载的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crictl images</span><br></pre></td></tr></table></figure>
<p>确保所有需要的镜像都已下载完成。</p>
</li>
<li><p><strong>继续初始化集群</strong><br>镜像下载完成后，可以继续执行初始化命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --image-repository registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="注意事项二：加载自定义镜像的命令-ctr-n-k8s-io-images-import"><a href="#注意事项二：加载自定义镜像的命令-ctr-n-k8s-io-images-import" class="headerlink" title="注意事项二：加载自定义镜像的命令 ctr -n k8s.io images import"></a>注意事项二：加载自定义镜像的命令 <code>ctr -n k8s.io images import</code></h4><p>在 Kubernetes 中，容器运行时（如 containerd）负责管理镜像。如果您有自定义的镜像文件（通常是 <code>.tar</code> 格式），可以使用 <code>ctr</code> 命令将其加载到容器运行时中。</p>
<ol>
<li><p><strong>为什么使用 <code>ctr -n k8s.io images import</code>？</strong>  </p>
<ul>
<li><code>ctr</code> 是 containerd 的命令行工具，用于管理容器和镜像。</li>
<li><code>-n k8s.io</code> 指定了命名空间，Kubernetes 使用的 containerd 命名空间是 <code>k8s.io</code>。</li>
<li><code>images import</code> 是用于导入镜像的命令。</li>
</ul>
</li>
<li><p><strong>如何使用该命令</strong><br>假设您有一个自定义镜像文件 <code>my-custom-image.tar</code>，可以使用以下命令导入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ctr -n k8s.io images import my-custom-image.tar</span><br></pre></td></tr></table></figure></li>
<li><p><strong>验证镜像是否导入成功</strong><br>使用以下命令查看已导入的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ctr -n k8s.io images list</span><br></pre></td></tr></table></figure>
<p>确保您的自定义镜像已成功加载。</p>
</li>
<li><p><strong>在 Kubernetes 中使用自定义镜像</strong><br>在 Pod 的 YAML 文件中，可以直接引用自定义镜像的名称和标签。</p>
</li>
</ol>
<hr>
<h4 id="注意事项三：CRI-集成插件被禁止的情况及处理方法"><a href="#注意事项三：CRI-集成插件被禁止的情况及处理方法" class="headerlink" title="注意事项三：CRI 集成插件被禁止的情况及处理方法"></a>注意事项三：CRI 集成插件被禁止的情况及处理方法</h4><p>CRI（Container Runtime Interface）是 Kubernetes 与容器运行时（如 containerd、CRI-O）之间的接口。CRI 集成插件（如 <code>cri-tools</code>）可能会在某些情况下被禁止，以下是可能的原因及处理方法：</p>
<ol>
<li><p><strong>CRI 集成插件被禁止的常见原因</strong>  </p>
<ul>
<li><strong>容器运行时未正确配置</strong>：如果容器运行时（如 containerd）未正确配置或未启动，CRI 插件可能无法正常工作。</li>
<li><strong>Kubernetes 版本与 CRI 版本不兼容</strong>：某些 Kubernetes 版本可能需要特定版本的 CRI 插件。</li>
<li><strong>安全策略限制</strong>：某些安全策略（如 SELinux、AppArmor）可能会限制 CRI 插件的运行。</li>
<li><strong>网络问题</strong>：如果节点无法访问所需的镜像仓库或网络配置错误，CRI 插件可能无法拉取镜像。</li>
</ul>
</li>
<li><p><strong>处理方法</strong>  </p>
<ul>
<li><p><strong>检查容器运行时状态</strong><br>确保容器运行时（如 containerd）已正确安装并运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status containerd</span><br></pre></td></tr></table></figure>
<p>如果未运行，可以启动并设置开机自启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now containerd</span><br></pre></td></tr></table></figure></li>
<li><p><strong>检查 Kubernetes 与 CRI 的兼容性</strong><br>确保 Kubernetes 版本与 CRI 插件版本兼容。可以参考 Kubernetes 官方文档中的版本兼容性列表。</p>
</li>
<li><p><strong>检查安全策略</strong><br>如果启用了 SELinux 或 AppArmor，确保它们未阻止 CRI 插件的运行。可以尝试临时禁用 SELinux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br></pre></td></tr></table></figure>
<p>如果问题解决，可以调整安全策略以允许 CRI 插件运行。</p>
</li>
<li><p><strong>检查网络配置</strong><br>确保节点可以访问所需的镜像仓库。可以尝试手动拉取镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crictl pull &lt;image-name&gt;</span><br></pre></td></tr></table></figure>
<p>如果网络有问题，检查节点的 DNS 配置和防火墙规则。</p>
</li>
<li><p><strong>重新初始化集群</strong><br>如果问题仍然存在，可以尝试清理集群并重新初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm reset</span><br><span class="line">sudo kubeadm init --image-repository registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="离线下载方案"><a href="#离线下载方案" class="headerlink" title="离线下载方案"></a>离线下载方案</h2><p>基于以上教程与<a href="https://kubernetes.io/releases/download/">官网提供的下载安装包</a>可以实现离线安装部署，注意镜像版本对应关系。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>docker更换国内源</title>
    <url>/2023/03/06/docker-%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<p>由于Docker的官方默认源在海外，导致了国内服务器使用Docker默认源拉取镜像速度不理想，甚至直接失败等问题，造成了不小的困扰。</p>
<p>解决方式很简单，可以使用国内提供的docker镜像源加速:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网易163</span></span><br><span class="line">https://hub-mirror.c.163.com</span><br><span class="line"><span class="comment"># 中国科学技术大学</span></span><br><span class="line">https://docker.mirrors.ustc.edu.cn</span><br><span class="line"><span class="comment"># 阿里云</span></span><br><span class="line">https://&lt;你的ID&gt;.mirror.aliyuncs.com</span><br><span class="line"><span class="comment"># 腾讯云内网</span></span><br><span class="line">https://mirror.ccs.tencentyun.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>下面以网易163源为实例</p>
<h2 id="一、适用于基于-Ubuntu-操作系统的实例："><a href="#一、适用于基于-Ubuntu-操作系统的实例：" class="headerlink" title="一、适用于基于 Ubuntu 操作系统的实例："></a>一、适用于基于 Ubuntu 操作系统的实例：</h2><p>1、执行以下命令，打开 <code>/etc/default/docker</code> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/default/docker</span><br></pre></td></tr></table></figure>

<p>2、按 i 切换至编辑模式，添加以下内容，并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&quot;--registry-mirror=https://hub-mirror.c.163.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>3、执行以下命令，重启 Docker 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="二、适用于基于-CentOS-RHEL-Rocky-操作系统的实例："><a href="#二、适用于基于-CentOS-RHEL-Rocky-操作系统的实例：" class="headerlink" title="二、适用于基于 CentOS/RHEL/Rocky 操作系统的实例："></a>二、适用于基于 CentOS/RHEL/Rocky 操作系统的实例：</h2><p>1、执行以下命令，打开 /etc/docker/daemon.json 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>2、按 i 切换至编辑模式，添加以下内容，并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;https://hub-mirror.c.163.com&quot;</span></span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、执行以下命令，重启 Docker 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>容器</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python进行mysql数据迁移</title>
    <url>/2025/03/23/mysql-%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8Cmysql%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>Alembic是一个数据库管理工具，用于管理数据库迁移。它允许你创建、应用和撤销数据库迁移，以便在数据库结构发生变化时保持版本控制。任何有关数据库变动都需要使用这个库来进行操作。这是一个python库，版本已经记录在项目下的requirements.txt文件当中。</p>
<h2 id="新增字段操作如下"><a href="#新增字段操作如下" class="headerlink" title="新增字段操作如下"></a>新增字段操作如下</h2><p>在使用 Alembic 进行数据库迁移时，你需要通过 Alembic 的迁移脚本来实现对表结构的修改，同时确保原始数据不会被删除。以下是基于你的需求，使用 Alembic 添加一个新字段 <code>usr_id</code> 并设置默认值为 <code>0</code> 的详细步骤：</p>
<h3 id="1-初始化-Alembic-环"><a href="#1-初始化-Alembic-环" class="headerlink" title="1. 初始化 Alembic 环"></a>1. 初始化 Alembic 环</h3><p>境如果你还没有初始化 Alembic，需要先在项目中初始化它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alembic init alembic</span><br></pre></td></tr></table></figure>
<p>这会在项目中创建一个 <code>alembic</code> 文件夹，其中包含 Alembic 的配置文件和迁移脚本模板。</p>
<h3 id="2-配置-Alembic"><a href="#2-配置-Alembic" class="headerlink" title="2. 配置 Alembic"></a>2. 配置 Alembic</h3><p>编辑 <code>alembic.ini</code> 文件，确保其中的 <code>sqlalchemy.url</code> 配置正确指向你的数据库：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">sqlalchemy.url</span> = mysql+pymysql://username:password@host:port/dbname</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如：sqlalchemy.url = mysql+pymysql://root:<a href="mailto:&#49;&#50;&#x33;&#x34;&#53;&#x36;&#x40;&#49;&#50;&#x37;&#x2e;&#48;&#x2e;&#x30;&#46;&#49;">&#49;&#50;&#x33;&#x34;&#53;&#x36;&#x40;&#49;&#50;&#x37;&#x2e;&#48;&#x2e;&#x30;&#46;&#49;</a>:3306/BAIZHAN_DEV</p>
</blockquote>
<p>将 <code>username</code>、<code>password</code>、<code>host</code>、<code>port</code> 和 <code>dbname</code> 替换为你的数据库连接信息。</p>
<h3 id="3-编辑-env-py"><a href="#3-编辑-env-py" class="headerlink" title="3. 编辑 env.py"></a>3. 编辑 <code>env.py</code></h3><p>在 <code>alembic/env.py</code> 文件中，确保 <code>target_metadata</code> 指向你的 SQLAlchemy Base 元数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> logging.config <span class="keyword">import</span> fileConfig</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> engine_from_config, pool</span><br><span class="line"><span class="keyword">from</span> alembic <span class="keyword">import</span> context</span><br><span class="line"><span class="keyword">from</span> db.mysql_db <span class="keyword">import</span> Base  <span class="comment"># 替换为你的 Base 模型的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this is the Alembic Config object, which provides</span></span><br><span class="line"><span class="comment"># access to the values within the .ini file in use.</span></span><br><span class="line">config = context.config</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interpret the config file for Python logging.</span></span><br><span class="line"><span class="comment"># This line sets up loggers basically.</span></span><br><span class="line">fileConfig(config.config_file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add your model&#x27;s MetaData object here</span></span><br><span class="line"><span class="comment"># for &#x27;autogenerate&#x27; support</span></span><br><span class="line">target_metadata = Base.metadata</span><br><span class="line"></span><br><span class="line"><span class="comment"># other values from the config, defined by the needs of env.py,</span></span><br><span class="line"><span class="comment"># can be acquired:</span></span><br><span class="line"><span class="comment"># my_important_option = config.get_main_option(&quot;my_important_option&quot;)</span></span><br><span class="line"><span class="comment"># ... etc.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_migrations_offline</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Run migrations in &#x27;offline&#x27; mode.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This configures the context with just a URL</span></span><br><span class="line"><span class="string">    and not an Engine, though an Engine is acceptable</span></span><br><span class="line"><span class="string">    here as well.  By skipping the Engine creation</span></span><br><span class="line"><span class="string">    we don&#x27;t even need a DBAPI to be available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Calls to.execute context() here emit the given string to the</span></span><br><span class="line"><span class="string">    script output.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = config.get_main_option(<span class="string">&quot;sqlalchemy.url&quot;</span>)</span><br><span class="line">    context.configure(</span><br><span class="line">        url=url,</span><br><span class="line">        target_metadata=target_metadata,</span><br><span class="line">        literal_binds=<span class="literal">True</span>,</span><br><span class="line">        dialect_opts=&#123;<span class="string">&quot;paramstyle&quot;</span>: <span class="string">&quot;named&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> context.begin_transaction():</span><br><span class="line">        context.run_migrations()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_migrations_online</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Run migrations in &#x27;online&#x27; mode.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In this scenario we need to create an Engine</span></span><br><span class="line"><span class="string">    and associate a connection with the context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    connectable = engine_from_config(</span><br><span class="line">        config.get_section(config.config_ini_section),</span><br><span class="line">        prefix=<span class="string">&quot;sqlalchemy.&quot;</span>,</span><br><span class="line">        poolclass=pool.NullPool,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> connectable.connect() <span class="keyword">as</span> connection:</span><br><span class="line">        context.configure(connection=connection, target_metadata=target_metadata)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> context.begin_transaction():</span><br><span class="line">            context.run_migrations()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> context.is_offline_mode():</span><br><span class="line">    run_migrations_offline()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    run_migrations_online()</span><br></pre></td></tr></table></figure>

<h3 id="4-更新模型定义"><a href="#4-更新模型定义" class="headerlink" title="4. 更新模型定义"></a>4. 更新模型定义</h3><p>在你的 SQLAlchemy 模型中，新的添加字段 <code>usr_id</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YourModel</span>(<span class="title class_ inherited__">Base</span>):  <span class="comment"># 替换为你的模型类</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;your_table_name&quot;</span>  <span class="comment"># 替换为你的表名</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 其他字段</span></span><br><span class="line">    usr_id = Column(Integer, default=<span class="number">0</span>)  <span class="comment"># 新增字段</span></span><br></pre></td></tr></table></figure>

<h3 id="5-生成迁移脚本"><a href="#5-生成迁移脚本" class="headerlink" title="5. 生成迁移脚本"></a>5. 生成迁移脚本</h3><p>运行以下命令生成迁移脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alembic revision --autogenerate -m <span class="string">&quot;Add usr_id field&quot;</span></span><br></pre></td></tr></table></figure>
<p>这会根据模型的变化自动生成一个迁移脚本。</p>
<h3 id="6-检查迁移脚本"><a href="#6-检查迁移脚本" class="headerlink" title="6. 检查迁移脚本"></a>6. 检查迁移脚本</h3><p>Alembic 生成的迁移脚本位于 <code>alembic/versions</code> 文件夹中。打开生成的脚本文件，确保内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Add usr_id field</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Revision ID: &lt;revision_id&gt;</span></span><br><span class="line"><span class="string">Revises: &lt;previous_revision_id&gt;</span></span><br><span class="line"><span class="string">Create Date: &lt;create_date&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> alembic <span class="keyword">import</span> op</span><br><span class="line"><span class="keyword">import</span> sqlalchemy <span class="keyword">as</span> sa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># revision identifiers, used by Alembic.</span></span><br><span class="line">revision = <span class="string">&#x27;&lt;revision_id&gt;&#x27;</span></span><br><span class="line">down_revision = <span class="string">&#x27;&lt;previous_revision_id&gt;&#x27;</span></span><br><span class="line">branch_labels = <span class="literal">None</span></span><br><span class="line">depends_on = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upgrade</span>():</span><br><span class="line">    <span class="comment"># ### commands auto generated by Alembic - please adjust! ###</span></span><br><span class="line">    op.add_column(<span class="string">&#x27;your_table_name&#x27;</span>, sa.Column(<span class="string">&#x27;usr_id&#x27;</span>, sa.Integer(), server_default=<span class="string">&#x27;0&#x27;</span>, nullable=<span class="literal">False</span>))</span><br><span class="line">    <span class="comment"># ### end Alembic commands ###</span></span><br><span class="line">    <span class="comment"># 如果有默认值server_default=&#x27;0&#x27;需要自己手动添加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downgrade</span>():</span><br><span class="line">    <span class="comment"># ### commands auto generated by Alembic - please adjust! ###</span></span><br><span class="line">    op.drop_column(<span class="string">&#x27;your_table_name&#x27;</span>, <span class="string">&#x27;usr_id&#x27;</span>)</span><br><span class="line">    <span class="comment"># ### end Alembic commands ###</span></span><br></pre></td></tr></table></figure>

<h3 id="7-应用迁移"><a href="#7-应用迁移" class="headerlink" title="7. 应用迁移"></a>7. 应用迁移</h3><p>运行以下命令将迁移应用到数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alembic upgrade <span class="built_in">head</span></span><br></pre></td></tr></table></figure>

<h3 id="8-验证结果"><a href="#8-验证结果" class="headerlink" title="8. 验证结果"></a>8. 验证结果</h3><ul>
<li>检查数据库表结构，确认 <code>usr_id</code> 字段已添加。</li>
<li>确保表中的现有数据未被删除。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>备份数据库</strong>：在执行迁移之前，建议备份数据库，以防万一出现问题。</li>
<li><strong>测试迁移</strong>：在开发环境或测试环境中测试迁移脚本，确保一切正常后再应用到生产环境。</li>
<li><strong>默认值处理</strong>：在迁移脚本中，<code>server_default=&#39;0&#39;</code> 确保新字段在现有数据中填充默认值 <code>0</code>。</li>
</ol>
<h2 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h2><p>删除字段只需要简单修改命令即可，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alembic revision --autogenerate -m <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段命令会自动生成一个空白脚本，然后手动加入删除代码,示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">upgrade</span>():</span><br><span class="line">    op.drop_column(<span class="string">&#x27;modeltest&#x27;</span>, <span class="string">&#x27;content2&#x27;</span>)  <span class="comment"># 删除字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downgrade</span>():</span><br><span class="line">    op.add_column(<span class="string">&#x27;modeltest&#x27;</span>, sa.Column(<span class="string">&#x27;content2&#x27;</span>, sa.Text(), nullable=<span class="literal">True</span>))  <span class="comment"># 如果需要回滚，重新添加字段</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>数据迁移</tag>
        <tag>Alembic</tag>
      </tags>
  </entry>
  <entry>
    <title>pyhon包的离线更新与迁移</title>
    <url>/2025/03/23/pyhon%E5%8C%85%E7%9A%84%E7%A6%BB%E7%BA%BF%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="如何使用-Conda-和-Pip-离线下载-Python-包"><a href="#如何使用-Conda-和-Pip-离线下载-Python-包" class="headerlink" title="如何使用 Conda 和 Pip 离线下载 Python 包"></a>如何使用 Conda 和 Pip 离线下载 Python 包</h2><p>在某些情况下，可能需要在没有网络连接的环境中安装 Python 包，例如在公司内网或安全环境中。为了实现这一目标，可以使用 Conda 和 Pip 提供的离线下载功能，提前将所需的包下载到本地，然后在目标环境中进行安装。以下是一个简单的指南，帮助你在离线环境中高效地管理 Python 包。</p>
<hr>
<h3 id="第一步：离线下载包"><a href="#第一步：离线下载包" class="headerlink" title="第一步：离线下载包"></a>第一步：离线下载包</h3><h4 id="使用-Pip-下载"><a href="#使用-Pip-下载" class="headerlink" title="使用 Pip 下载"></a>使用 Pip 下载</h4><p>Pip 提供了一个非常方便的选项来离线下载包及其依赖。你可以使用以下命令下载指定的包及其依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip download package_name</span><br></pre></td></tr></table></figure>

<p>如果你有一个 <code>requirements.txt</code> 文件，包含多个包的依赖，可以使用以下命令一次性下载所有包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip download -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>这会将所有包及其依赖下载到当前目录。你也可以指定下载路径，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip download -r requirements.txt -d /path/to/download</span><br></pre></td></tr></table></figure>

<p>这样，所有下载的 <code>.whl</code> 文件和 <code>.tar.gz</code> 文件都会保存到指定的目录中。</p>
<hr>
<h4 id="使用-Conda-下载"><a href="#使用-Conda-下载" class="headerlink" title="使用 Conda 下载"></a>使用 Conda 下载</h4><p>Conda 也支持离线下载包。从 Conda 4.6 版本开始，<code>conda install</code> 命令支持 <code>--download-only</code> 选项，可以直接下载包而不安装。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install --download-only package_name</span><br></pre></td></tr></table></figure>

<p>这会将包下载到 Conda 的缓存目录中，通常是 <code>~/.conda/pkgs</code> 或 <code>C:\Users\&lt;username&gt;\.conda\pkgs</code>（Windows）。</p>
<p>你也可以将下载的包保存到指定的目录中，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install --download-only -p /path/to/offline_pkgs &lt;包名&gt;</span><br></pre></td></tr></table></figure>

<p>这会将包下载到指定的目录中。</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>使用 <code>--download-only</code> 时，Conda 会将包下载到缓存目录，但不会自动清理。如果需要手动清理缓存，可以使用以下命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda clean --packages</span><br></pre></td></tr></table></figure></li>
<li>如果需要下载多个包，可以将它们列在 <code>requirements.txt</code> 文件中，然后逐个下载：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> $(<span class="built_in">cat</span> requirements.txt); <span class="keyword">do</span></span><br><span class="line">    conda install --download-only <span class="variable">$pkg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第二步：将下载的包传输到目标环境"><a href="#第二步：将下载的包传输到目标环境" class="headerlink" title="第二步：将下载的包传输到目标环境"></a>第二步：将下载的包传输到目标环境</h3><p>将下载好的包（<code>.whl</code> 文件或 <code>.tar.gz</code> 文件）复制到目标机器的某个目录中。例如，你可以将它们放在 <code>/path/to/offline_packages</code> 目录中。</p>
<hr>
<h3 id="第三步：在离线环境中安装包"><a href="#第三步：在离线环境中安装包" class="headerlink" title="第三步：在离线环境中安装包"></a>第三步：在离线环境中安装包</h3><h4 id="使用-Pip-安装"><a href="#使用-Pip-安装" class="headerlink" title="使用 Pip 安装"></a>使用 Pip 安装</h4><p>在离线环境中，你可以使用 <code>pip install</code> 命令安装下载的包。为了确保只从本地目录中查找包，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --no-index --find-links=/path/to/offline_packages package_name</span><br></pre></td></tr></table></figure>

<p>如果你有一个 <code>requirements.txt</code> 文件，可以使用以下命令安装所有依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --no-index --find-links=/path/to/offline_packages -r requirements.txt</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="使用-Conda-安装"><a href="#使用-Conda-安装" class="headerlink" title="使用 Conda 安装"></a>使用 Conda 安装</h4><p>对于 Conda 下载的包，可以直接从缓存目录中安装。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install --offline --use-local package_name</span><br></pre></td></tr></table></figure>

<p>或者，你可以直接指定包的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install /path/to/offline_packages/package_name</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li>如果使用 Conda 的 <code>--offline</code> 选项，确保目标环境中已经存在所需的包。否则，Conda 会尝试从网络中下载。</li>
<li>如果需要安装多个包，建议将它们全部下载到同一个目录中，然后使用 <code>--use-local</code> 选项。</li>
</ul>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>兼容性检查</strong><br>确保下载的包与目标环境中的 Python 版本和操作系统兼容。例如，某些包可能仅支持特定的 Python 版本或操作系统架构。</p>
</li>
<li><p><strong>依赖管理</strong><br>如果包有依赖，确保下载所有必要的依赖文件。使用 <code>pip download -r requirements.txt</code> 或逐个下载 Conda 包可以自动处理依赖关系。</p>
</li>
<li><p><strong>缓存清理</strong><br>如果你使用 Conda 下载包，Conda 会将包保存在缓存目录中。你可以定期清理缓存以释放空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda clean --all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>离线环境准备</strong><br>在离线环境中安装包时，确保目标机器上已经安装了 Conda 或 Pip，并且 Python 环境已经正确配置。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用 Pip 和 Conda 提供的离线下载功能，可以轻松地在没有网络连接的环境中管理和安装 Python 包。<code>pip download</code> 和 <code>conda install --download-only</code> 命令提供了强大的工具，提前准备所需的包，从而在离线环境中节省时间和精力。有些包更新真尼玛草了！</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>conda</tag>
        <tag>错误记录</tag>
        <tag>pip</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>RAG-更好的读取文本文件</title>
    <url>/2025/03/23/RAG-%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>以下实现综合考虑了文件检测、内存管理、编码处理、并发控制等关键因素，支持智能选择读取策略：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>, <span class="type">Optional</span>, <span class="type">Callable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileParser</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    智能文本文件解析器，具备以下特性：</span></span><br><span class="line"><span class="string">    - 自动编码检测与容错处理</span></span><br><span class="line"><span class="string">    - 动态内存管理的大文件处理</span></span><br><span class="line"><span class="string">    - 自适应并发策略选择</span></span><br><span class="line"><span class="string">    - 文件完整性校验</span></span><br><span class="line"><span class="string">    - 资源监控与保护</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                 file_path: <span class="built_in">str</span>, </span></span><br><span class="line"><span class="params">                 max_memory_ratio: <span class="built_in">float</span> = <span class="number">0.3</span>,</span></span><br><span class="line"><span class="params">                 chunk_size: <span class="built_in">int</span> = <span class="number">1024</span>*<span class="number">1024</span>,</span></span><br><span class="line"><span class="params">                 encoding_threshold: <span class="built_in">int</span> = <span class="number">1024</span>*<span class="number">1024</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        file_path: 文件路径</span></span><br><span class="line"><span class="string">        max_memory_ratio: 允许使用的最大内存比例（0-1）</span></span><br><span class="line"><span class="string">        chunk_size: 大文件分块读取尺寸（字节）</span></span><br><span class="line"><span class="string">        encoding_threshold: 编码检测最大读取字节数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.file_path = file_path</span><br><span class="line">        self.max_memory = psutil.virtual_memory().total * max_memory_ratio</span><br><span class="line">        self.chunk_size = chunk_size</span><br><span class="line">        self.encoding_threshold = encoding_threshold</span><br><span class="line">        self._encoding = <span class="literal">None</span></span><br><span class="line">        self._file_size = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exists</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查文件是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> os.path.exists(self.file_path)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取文件大小（字节）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._file_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._file_size = os.path.getsize(self.file_path)</span><br><span class="line">        <span class="keyword">return</span> self._file_size</span><br><span class="line"></span><br><span class="line"><span class="meta">    @lru_cache(<span class="params">maxsize=<span class="number">32</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detect_encoding</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;智能编码检测（带缓存）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                raw_data = f.read(<span class="built_in">min</span>(self.size, self.encoding_threshold))</span><br><span class="line">                result = chardet.detect(raw_data)</span><br><span class="line">                <span class="keyword">return</span> result[<span class="string">&#x27;encoding&#x27;</span>] <span class="keyword">or</span> <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;编码检测失败: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_memory_safe</span>(<span class="params">self, required_mem: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;内存安全检查&quot;&quot;&quot;</span></span><br><span class="line">        available = psutil.virtual_memory().available</span><br><span class="line">        <span class="keyword">return</span> required_mem &lt; <span class="built_in">min</span>(self.max_memory, available)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_read</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                        callback: <span class="type">Optional</span>[<span class="type">Callable</span>] = <span class="literal">None</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;协程方式读取（适合IO密集型）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.size &gt; <span class="number">1e6</span> <span class="keyword">and</span> <span class="keyword">not</span> self._memory_safe(self.size*<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">raise</span> MemoryError(<span class="string">&quot;文件过大且内存不足&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self._encoding = self.detect_encoding()</span><br><span class="line">        lines = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> asyncio.Lock():</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.file_path, <span class="string">&#x27;r&#x27;</span>, </span><br><span class="line">                     encoding=self._encoding, </span><br><span class="line">                     errors=<span class="string">&#x27;replace&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">if</span> self.size &gt; self.chunk_size:</span><br><span class="line">                    <span class="comment"># 大文件分块读取</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        chunk = <span class="keyword">await</span> asyncio.to_thread(f.read, self.chunk_size)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> callback:</span><br><span class="line">                            <span class="keyword">await</span> callback(chunk)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            lines.extend(chunk.splitlines())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 小文件直接读取</span></span><br><span class="line">                    content = <span class="keyword">await</span> asyncio.to_thread(f.read)</span><br><span class="line">                    lines = content.splitlines()</span><br><span class="line">        <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiprocess_read</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                         workers: <span class="built_in">int</span> = <span class="literal">None</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;多进程读取（适合CPU密集型处理）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> workers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            workers = <span class="built_in">min</span>(os.cpu_count(), <span class="number">4</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">with</span> ProcessPoolExecutor(max_workers=workers) <span class="keyword">as</span> executor:</span><br><span class="line">            futures = []</span><br><span class="line">            results = []</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> chunk <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: f.read(self.chunk_size), <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">                    futures.append(</span><br><span class="line">                        executor.submit(</span><br><span class="line">                            self._process_chunk,</span><br><span class="line">                            chunk,</span><br><span class="line">                            self.detect_encoding()</span><br><span class="line">                        ))</span><br><span class="line">            <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">                results.extend(future.result())</span><br><span class="line">            <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_chunk</span>(<span class="params">chunk: <span class="built_in">bytes</span>, encoding: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;多进程分块处理&quot;&quot;&quot;</span></span><br><span class="line">        text = chunk.decode(encoding, errors=<span class="string">&#x27;replace&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> text.splitlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">            mode: <span class="built_in">str</span> = <span class="string">&#x27;auto&#x27;</span>,</span></span><br><span class="line"><span class="params">            progress: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="type">Union</span>[<span class="built_in">list</span>, <span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主读取方法</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        mode: auto|async|multiprocess</span></span><br><span class="line"><span class="string">        progress: 显示进度提示</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.exists:</span><br><span class="line">            <span class="keyword">raise</span> FileNotFoundError(<span class="string">f&quot;文件不存在: <span class="subst">&#123;self.file_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        required_mem = self.size * <span class="number">2</span>  <span class="comment"># 预估内存需求</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._memory_safe(required_mem):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;auto&#x27;</span>:</span><br><span class="line">                mode = <span class="string">&#x27;async&#x27;</span> <span class="keyword">if</span> self.size &gt; <span class="number">1e6</span> <span class="keyword">else</span> <span class="string">&#x27;multiprocess&#x27;</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;async&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> asyncio.run(self.async_read())</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;multiprocess&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.multiprocess_read()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 常规读取</span></span><br><span class="line">            self._encoding = self.detect_encoding()</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.file_path, <span class="string">&#x27;r&#x27;</span>, </span><br><span class="line">                     encoding=self._encoding,</span><br><span class="line">                     errors=<span class="string">&#x27;replace&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">if</span> self.size &gt; self.chunk_size:</span><br><span class="line">                    lines = []</span><br><span class="line">                    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                        lines.append(line.strip())</span><br><span class="line">                        <span class="keyword">if</span> progress <span class="keyword">and</span> <span class="built_in">len</span>(lines) % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;\r已读取 <span class="subst">&#123;<span class="built_in">len</span>(lines)&#125;</span> 行&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> lines</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> f.read().splitlines()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下是增强功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate_file</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;文件完整性校验&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.file_path, <span class="string">&#x27;r&#x27;</span>, </span><br><span class="line">                     encoding=self.detect_encoding()) <span class="keyword">as</span> f:</span><br><span class="line">                f.read(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert_line_endings</span>(<span class="params">self, target: <span class="built_in">str</span> = <span class="string">&#x27;\n&#x27;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;统一换行符格式&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.file_path, <span class="string">&#x27;r+&#x27;</span>, </span><br><span class="line">                 encoding=self.detect_encoding()) <span class="keyword">as</span> f:</span><br><span class="line">            content = f.read().replace(<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>).replace(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            f.seek(<span class="number">0</span>)</span><br><span class="line">            f.write(content.replace(<span class="string">&#x27;\n&#x27;</span>, target))</span><br><span class="line">            f.truncate()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">batch_process</span>(<span class="params">cls, </span></span><br><span class="line"><span class="params">                     file_list: <span class="built_in">list</span>, </span></span><br><span class="line"><span class="params">                     max_concurrency: <span class="built_in">int</span> = <span class="number">8</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;批量处理文件&quot;&quot;&quot;</span></span><br><span class="line">        semaphore = asyncio.Semaphore(max_concurrency)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_process</span>(<span class="params">file_path</span>):</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">                parser = cls(file_path)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> parser.async_read()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> asyncio.gather(*[_process(f) <span class="keyword">for</span> f <span class="keyword">in</span> file_list])</span><br></pre></td></tr></table></figure>

<p><strong>核心设计要点</strong>：</p>
<ol>
<li><strong>编码检测优化</strong>：</li>
</ol>
<ul>
<li>使用前1MB数据进行编码推测（通过<code>encoding_threshold</code>控制）</li>
<li>添加LRU缓存避免重复检测</li>
<li>自动回退到UTF-8并替换错误字符</li>
</ul>
<ol start="2">
<li><p><strong>内存管理机制</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动态内存检查</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self._memory_safe(self.size*<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">raise</span> MemoryError(<span class="string">&quot;内存不足&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>自适应读取策略</strong>：</p>
</li>
</ol>
<ul>
<li>&lt;1MB文件：直接读取</li>
<li>1MB~100MB：协程分块读取</li>
<li><blockquote>
<p>100MB：多进程并行处理</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li><p><strong>并发模式选择</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mode = <span class="string">&#x27;async&#x27;</span> <span class="keyword">if</span> self.size &gt; <span class="number">1e6</span> <span class="keyword">else</span> <span class="string">&#x27;multiprocess&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>增强功能</strong>：</p>
</li>
</ol>
<ul>
<li>换行符统一（支持Windows/Unix格式）</li>
<li>批量处理限流（通过信号量控制）</li>
<li>文件完整性校验</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line">parser = FileParser(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">lines = parser.read(progress=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步模式</span></span><br><span class="line">async_lines = asyncio.run(parser.async_read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量处理</span></span><br><span class="line">results = FileParser.batch_process([<span class="string">&quot;file1.txt&quot;</span>, <span class="string">&quot;file2.txt&quot;</span>])</span><br></pre></td></tr></table></figure>

<p><strong>未提及的重要考虑</strong>：</p>
<ul>
<li>文件锁机制（避免并发写入冲突）</li>
<li>内存映射文件支持（通过mmap模块）</li>
<li>二进制模式与文本模式自动切换</li>
<li>异常日志记录（建议集成logging模块）</li>
<li>文件编码BOM头处理</li>
</ul>
<p>建议添加以下监控装饰器来增强稳定性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resource_monitor</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> psutil.cpu_percent() &gt; <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;CPU过载&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> psutil.virtual_memory().percent &gt; <span class="number">95</span>:</span><br><span class="line">            <span class="keyword">raise</span> MemoryError(<span class="string">&quot;内存不足&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(self, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>RAG</tag>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>包装函数的一些用法</title>
    <url>/2025/03/23/python-%E5%8C%85%E8%A3%85%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>在 Python 开发中，经常会遇到需要对函数进行扩展或修改其行为的情况，但又不希望直接修改函数本身的代码。这时，包装函数（也称为装饰器）就派上了大用场。它是一种非常优雅且强大的工具，能够以一种简洁的方式增强函数的功能。</p>
<h2 id="一、包装函数的基本概念"><a href="#一、包装函数的基本概念" class="headerlink" title="一、包装函数的基本概念"></a>一、包装函数的基本概念</h2><p>包装函数本质上是一个返回函数的高阶函数。它接收一个函数作为参数，对其进行包装，然后返回一个新的函数。通过使用 <code>@</code> 符号，可以很方便地将包装函数应用到目标函数上。</p>
<p>在 Python 中，通常使用 <code>functools.wraps</code> 来保留被包装函数的元信息（如函数名、文档字符串等），以确保在使用装饰器后，函数的这些信息不会丢失。</p>
<h2 id="二、应用场景：系统参数与用户参数的结合"><a href="#二、应用场景：系统参数与用户参数的结合" class="headerlink" title="二、应用场景：系统参数与用户参数的结合"></a>二、应用场景：系统参数与用户参数的结合</h2><p>代码示例中，包装函数被用来解决一个非常实用的问题：当系统中需要调用一个函数时，这个函数的参数既包括用户提供的参数，也包括系统配置的参数。如果直接在每次调用时手动添加这些参数，代码会变得冗长且难以维护。而通过使用包装函数，可以将系统参数封装起来，让用户在调用时只需传入自己的参数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">force_think_status_false</span>(<span class="params">func, _<span class="built_in">dict</span></span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> _<span class="built_in">dict</span>.items():</span><br><span class="line">            kwargs[key] = value</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">model_path = <span class="string">&quot;some_module&quot;</span></span><br><span class="line">class_name = <span class="string">&quot;ChatModel&quot;</span></span><br><span class="line">model = importlib.import_module(model_path)</span><br><span class="line">chat = <span class="built_in">getattr</span>(model, class_name)</span><br><span class="line"></span><br><span class="line">func_dict = &#123;</span><br><span class="line">    <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">    <span class="string">&quot;req_url&quot;</span>: <span class="string">&quot;https://api.example.com/chat&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_key&quot;</span>: <span class="string">&quot;your_api_key&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">func_dict[<span class="string">&quot;think_model&quot;</span>] = <span class="literal">False</span> <span class="keyword">if</span> model_config.get(<span class="string">&#x27;think_model&#x27;</span>, <span class="literal">False</span>) == <span class="literal">False</span> <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">chat = force_think_status_false(chat, func_dict)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>force_think_status_false</code> 是一个包装函数，它接收一个函数 <code>func</code> 和一个字典 <code>_dict</code>。在包装后的函数 <code>wrapper</code> 中，它将 <code>_dict</code> 中的键值对添加到 <code>kwargs</code> 中，然后调用原始的 <code>func</code>。这样，当用户调用 <code>chat</code> 时，系统参数会被自动添加进去，而用户只需要传入自己的参数即可。</p>
<h2 id="三、其他包装函数的使用场景"><a href="#三、其他包装函数的使用场景" class="headerlink" title="三、其他包装函数的使用场景"></a>三、其他包装函数的使用场景</h2><h3 id="（一）日志记录"><a href="#（一）日志记录" class="headerlink" title="（一）日志记录"></a>（一）日志记录</h3><p>在开发过程中，经常需要记录函数的调用情况，以便进行调试或监控。通过包装函数，可以轻松地为函数添加日志记录功能，而无需修改函数本身的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        logging.info(<span class="string">f&quot;Calling function <span class="subst">&#123;func.__name__&#125;</span> with args: <span class="subst">&#123;args&#125;</span>, kwargs: <span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        logging.info(<span class="string">f&quot;Function <span class="subst">&#123;func.__name__&#125;</span> returned <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>log_decorator</code> 会记录函数的调用信息和返回值。当调用 <code>add(3, 4)</code> 时，日志会输出函数的名称、传入的参数以及返回的结果。</p>
<h3 id="（二）性能测试"><a href="#（二）性能测试" class="headerlink" title="（二）性能测试"></a>（二）性能测试</h3><p>有时候，可能需要测试某个函数的执行时间，以评估其性能。包装函数可以方便地实现这一功能，而无需在函数内部添加计时代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timing_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Function <span class="subst">&#123;func.__name__&#125;</span> took <span class="subst">&#123;end_time - start_time:<span class="number">.4</span>f&#125;</span> seconds to execute.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timing_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_sum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(compute_sum(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>timing_decorator</code> 会在函数执行前后记录时间，并计算出函数的执行时间。当调用 <code>compute_sum(1000000)</code> 时，它会输出函数的执行时间。</p>
<h3 id="（三）权限验证"><a href="#（三）权限验证" class="headerlink" title="（三）权限验证"></a>（三）权限验证</h3><p>在开发 Web 应用或 API 时，通常需要对某些函数进行权限验证，以确保只有授权的用户才能调用它们。包装函数可以方便地实现这一功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auth_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        user = get_current_user()  <span class="comment"># 假设有一个函数可以获取当前用户</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> user.is_authenticated:</span><br><span class="line">            <span class="keyword">raise</span> PermissionError(<span class="string">&quot;You do not have permission to access this function.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sensitive_data</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Sensitive information&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设的用户类和获取当前用户函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, is_authenticated</span>):</span><br><span class="line">        self.is_authenticated = is_authenticated</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_current_user</span>():</span><br><span class="line">    <span class="keyword">return</span> User(is_authenticated=<span class="literal">True</span>)  <span class="comment"># 示例用户已认证</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sensitive_data())</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>auth_decorator</code> 会检查当前用户是否已认证。如果用户未认证，则抛出 <code>PermissionError</code> 异常。</p>
<h3 id="（四）缓存结果"><a href="#（四）缓存结果" class="headerlink" title="（四）缓存结果"></a>（四）缓存结果</h3><p>对于一些计算成本较高的函数，可以使用包装函数来缓存其结果，以提高性能。当函数被多次调用且参数相同时，可以直接返回缓存的结果，而无需重新计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cache_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[args]</span><br><span class="line">        result = func(*args)</span><br><span class="line">        cache[args] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>cache_decorator</code> 使用一个字典 <code>cache</code> 来存储函数的参数和结果。当调用 <code>fibonacci(30)</code> 时，它会缓存计算结果，避免重复计算。</p>
<h2 id="重点补充"><a href="#重点补充" class="headerlink" title="重点补充"></a>重点补充</h2><p>与之后的案例有点不一样的地方在于，我使用了以一个方法叫做wraps，<code>@wraps(func)</code> 是 Python 中 <code>functools</code> 模块提供的一个非常有用的工具，它主要用于在定义装饰器时保留被装饰函数的元信息（如函数名、文档字符串等）。</p>
<h3 id="一、-wraps-func-的含义"><a href="#一、-wraps-func-的含义" class="headerlink" title="一、@wraps(func) 的含义"></a>一、<code>@wraps(func)</code> 的含义</h3><p>在 Python 中，当使用装饰器对一个函数进行包装时，被装饰的函数的元信息（如函数名、文档字符串、参数列表等）会被覆盖。例如，如果不使用 <code>@wraps(func)</code>，被装饰函数的 <code>__name__</code> 属性会被改为装饰器函数的名称，文档字符串也会丢失。这可能会导致一些问题，比如在调试时无法正确识别函数，或者在某些依赖函数元信息的框架中出现问题。</p>
<p><code>@wraps(func)</code> 的作用就是将被装饰函数的元信息复制到装饰器返回的函数中，从而保留这些信息。它是一个装饰器工厂，接收一个函数作为参数，并返回一个新的装饰器。</p>
<h3 id="二、-wraps-func-的使用方法"><a href="#二、-wraps-func-的使用方法" class="headerlink" title="二、@wraps(func) 的使用方法"></a>二、<code>@wraps(func)</code> 的使用方法</h3><h4 id="1-不使用-wraps-func-的情况"><a href="#1-不使用-wraps-func-的情况" class="headerlink" title="1. 不使用 @wraps(func) 的情况"></a>1. 不使用 <code>@wraps(func)</code> 的情况</h4><p>首先，来看一个不使用 <code>@wraps(func)</code> 的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print a greeting message.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(say_hello.__name__)</span><br><span class="line"><span class="built_in">print</span>(say_hello.__doc__)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Something is happening before the function is called.</span><br><span class="line">Hello, Alice!</span><br><span class="line">Something is happening after the function is called.</span><br><span class="line">wrapper</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>say_hello.__name__</code> 变成了 <code>wrapper</code>，<code>say_hello.__doc__</code> 也变成了 <code>None</code>。这是因为装饰器返回的函数是 <code>wrapper</code>，而 <code>wrapper</code> 的元信息覆盖了 <code>say_hello</code> 的元信息。</p>
<h4 id="2-使用-wraps-func-的情况"><a href="#2-使用-wraps-func-的情况" class="headerlink" title="2. 使用 @wraps(func) 的情况"></a>2. 使用 <code>@wraps(func)</code> 的情况</h4><p>接下来，使用 <code>@wraps(func)</code> 来解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)  </span><span class="comment"># 使用 @wraps(func) 保留元信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print a greeting message.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(say_hello.__name__)</span><br><span class="line"><span class="built_in">print</span>(say_hello.__doc__)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Something is happening before the function is called.</span><br><span class="line">Hello, Alice!</span><br><span class="line">Something is happening after the function is called.</span><br><span class="line">say_hello</span><br><span class="line">Print a greeting message.</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>say_hello.__name__</code> 仍然是 <code>say_hello</code>，<code>say_hello.__doc__</code> 也保留了原始的文档字符串。这是因为 <code>@wraps(func)</code> 将 <code>say_hello</code> 的元信息复制到了 <code>wrapper</code> 函数中。</p>
<h4 id="3-wraps-func-的具体作用"><a href="#3-wraps-func-的具体作用" class="headerlink" title="3. @wraps(func) 的具体作用"></a>3. <code>@wraps(func)</code> 的具体作用</h4><p><code>@wraps(func)</code> 主要做了以下几件事：</p>
<ul>
<li>将被装饰函数的 <code>__name__</code> 属性复制到装饰器返回的函数中。</li>
<li>将被装饰函数的 <code>__doc__</code> 属性（文档字符串）复制到装饰器返回的函数中。</li>
<li>将被装饰函数的其他元信息（如参数列表等）也复制到装饰器返回的函数中。</li>
</ul>
<p>这样，即使函数被装饰器包装，仍然可以通过 <code>__name__</code> 和 <code>__doc__</code> 等属性获取到原始函数的信息。</p>
<h3 id="三、为什么需要-wraps-func"><a href="#三、为什么需要-wraps-func" class="headerlink" title="三、为什么需要 @wraps(func)"></a>三、为什么需要 <code>@wraps(func)</code></h3><ol>
<li><strong>调试方便</strong>：在调试代码时，能够正确识别函数名和文档字符串是非常重要的。如果函数名被覆盖为装饰器的名称，可能会导致混淆。</li>
<li><strong>框架兼容性</strong>：某些框架或工具依赖函数的元信息来实现特定功能。例如，一些测试框架、文档生成工具等可能会根据函数的文档字符串或参数列表来生成文档或执行测试。如果不使用 <code>@wraps(func)</code>，可能会导致这些工具无法正常工作。</li>
<li><strong>代码可读性</strong>：保留函数的原始元信息可以提高代码的可读性，让其他开发者更容易理解代码的意图。</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>RAG-Chonkie实践理解分块</title>
    <url>/2025/03/31/RAG-Chonkie%E5%AE%9E%E8%B7%B5%E7%90%86%E8%A7%A3%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>在构建高效的检索增强生成（RAG）系统时，<strong>文本分块（Chunking）</strong>是决定系统性能的关键预处理步骤。今天我们将深入探讨文本分块的重要性，并详细解析Chonkie库提供的五种分块方法，帮助开发者选择最适合自己场景的分块策略。</p>
<hr>
<h2 id="一-为什么文本分块如此重要？"><a href="#一-为什么文本分块如此重要？" class="headerlink" title="一. 为什么文本分块如此重要？"></a><strong>一. 为什么文本分块如此重要？</strong></h2><p>在RAG流程中，分块是数据预处理的核心环节，直接影响：</p>
<ul>
<li><strong>检索精度</strong>：过大的块会引入噪声，过小的块丢失上下文。</li>
<li><strong>生成质量</strong>：LLM需要连贯的上下文理解用户查询。</li>
<li><strong>计算效率</strong>：合理分块减少无效计算。</li>
</ul>
<h3 id="错误分块的典型问题"><a href="#错误分块的典型问题" class="headerlink" title="错误分块的典型问题"></a><strong>错误分块的典型问题</strong></h3><ul>
<li><strong>案例1</strong>：将“巴黎是法国的首都。柏林是德国的首都”切分为：<ul>
<li>Chunk1: “巴黎是法国的首都。柏林”</li>
<li>Chunk2: “是德国的首都”  </li>
</ul>
<em>→ 检索“德国首都”时可能漏检Chunk1。</em></li>
<li><strong>案例2</strong>：将一篇学术论文的“方法论”和“结论”合并为一个块<br><em>→ 检索具体方法细节时引入无关信息。</em></li>
</ul>
<hr>
<h2 id="二、Chonkie的五种分块方法详解"><a href="#二、Chonkie的五种分块方法详解" class="headerlink" title="二、Chonkie的五种分块方法详解"></a>二、Chonkie的五种分块方法详解</h2><h3 id="1-TokenChunker：基于token的分块"><a href="#1-TokenChunker：基于token的分块" class="headerlink" title="1. TokenChunker：基于token的分块"></a>1. TokenChunker：基于token的分块</h3><p><strong>原理</strong>：按照固定的token数量分割文本</p>
<p><strong>特点</strong>：</p>
<ul>
<li>与LLM的token处理方式直接对应</li>
<li>保持每个块的token长度一致</li>
<li>可能破坏句子完整性</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要严格控制输入token长度的应用</li>
<li>处理token限制严格的LLM API</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> TokenChunker</span><br><span class="line"></span><br><span class="line">chunker = TokenChunker(max_tokens=<span class="number">512</span>)</span><br><span class="line">chunks = chunker.chunk(long_text)</span><br></pre></td></tr></table></figure>

<h3 id="2-WordChunker：基于词的分块"><a href="#2-WordChunker：基于词的分块" class="headerlink" title="2. WordChunker：基于词的分块"></a>2. WordChunker：基于词的分块</h3><p><strong>原理</strong>：按照单词数量分割文本</p>
<p><strong>特点</strong>：</p>
<ul>
<li>比token分块更符合人类阅读习惯</li>
<li>保持单词完整性</li>
<li>可能拆分复合词或专有名词</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要自然语言处理的传统NLP任务</li>
<li>对词边界敏感的应用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> WordChunker</span><br><span class="line"></span><br><span class="line">chunker = WordChunker(max_words=<span class="number">200</span>)</span><br><span class="line">chunks = chunker.chunk(long_text)</span><br></pre></td></tr></table></figure>

<h3 id="3-SentenceChunker：基于句子的分块"><a href="#3-SentenceChunker：基于句子的分块" class="headerlink" title="3. SentenceChunker：基于句子的分块"></a>3. SentenceChunker：基于句子的分块</h3><p><strong>原理</strong>：按照句子边界分割文本</p>
<p><strong>特点</strong>：</p>
<ul>
<li>保持句子完整性</li>
<li>块大小可能不均匀</li>
<li>依赖句子分割的准确性</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理正式文档或新闻文章</li>
<li>需要保持语法结构的应用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> SentenceChunker</span><br><span class="line"></span><br><span class="line">chunker = SentenceChunker(max_sentences=<span class="number">5</span>)</span><br><span class="line">chunks = chunker.chunk(long_text)</span><br></pre></td></tr></table></figure>

<h3 id="4-SemanticChunker：基于语义的分块"><a href="#4-SemanticChunker：基于语义的分块" class="headerlink" title="4. SemanticChunker：基于语义的分块"></a>4. SemanticChunker：基于语义的分块</h3><p><strong>原理</strong>：使用嵌入模型计算语义相似度动态分块</p>
<p><strong>特点</strong>：</p>
<ul>
<li>保持语义连贯性</li>
<li>自动适应不同文本类型</li>
<li>计算开销较大</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理复杂或非结构化文本</li>
<li>需要最高检索精度的RAG系统</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> SemanticChunker</span><br><span class="line"></span><br><span class="line">chunker = SemanticChunker(</span><br><span class="line">    embedding_model=<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>,</span><br><span class="line">    threshold=<span class="number">0.85</span></span><br><span class="line">)</span><br><span class="line">chunks = chunker.chunk(long_text)</span><br></pre></td></tr></table></figure>

<h3 id="5-SPDMChunker：结构化模式感知分块"><a href="#5-SPDMChunker：结构化模式感知分块" class="headerlink" title="5. SPDMChunker：结构化模式感知分块"></a>5. SPDMChunker：结构化模式感知分块</h3><p><strong>原理</strong>：识别特定领域模式（如代码、Markdown）进行分块</p>
<p><strong>特点</strong>：</p>
<ul>
<li>保持领域特定结构</li>
<li>需要预定义模式规则</li>
<li>对特定类型文本效果极佳</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理技术文档、代码或格式化文本</li>
<li>需要保留原始结构的应用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> SPDMChunker</span><br><span class="line"></span><br><span class="line">chunker = SPDMChunker(mode=<span class="string">&quot;markdown&quot;</span>)</span><br><span class="line">chunks = chunker.chunk(markdown_text)</span><br></pre></td></tr></table></figure>

<h2 id="三、如何选择合适的分块方法？"><a href="#三、如何选择合适的分块方法？" class="headerlink" title="三、如何选择合适的分块方法？"></a>三、如何选择合适的分块方法？</h2><table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
<th>最佳适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>TokenChunker</td>
<td>长度精确控制</td>
<td>可能破坏语义</td>
<td>严格token限制环境</td>
</tr>
<tr>
<td>WordChunker</td>
<td>自然词边界</td>
<td>忽略语义关系</td>
<td>传统NLP处理</td>
</tr>
<tr>
<td>SentenceChunker</td>
<td>保持句子完整</td>
<td>块大小不均</td>
<td>正式文档处理</td>
</tr>
<tr>
<td>SemanticChunker</td>
<td>最佳语义保持</td>
<td>计算成本高</td>
<td>高质量RAG系统</td>
</tr>
<tr>
<td>SPDMChunker</td>
<td>保留领域结构</td>
<td>需要配置规则</td>
<td>技术文档/代码</td>
</tr>
</tbody></table>
<h2 id="四、Chonkie的高级功能"><a href="#四、Chonkie的高级功能" class="headerlink" title="四、Chonkie的高级功能"></a>四、Chonkie的高级功能</h2><ol>
<li><p><strong>混合分块</strong>：组合多种分块方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> HybridChunker</span><br><span class="line"></span><br><span class="line">chunker = HybridChunker(</span><br><span class="line">    primary_chunker=<span class="string">&quot;semantic&quot;</span>,</span><br><span class="line">    fallback_chunker=<span class="string">&quot;token&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>动态重叠</strong>：在块间添加重叠区域保持上下文连贯</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunker = SemanticChunker(</span><br><span class="line">    overlap=<span class="number">0.2</span>  <span class="comment"># 20%的重叠</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>自适应分块</strong>：根据内容自动选择最佳分块策略</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> chonkie <span class="keyword">import</span> AutoChunker</span><br><span class="line"></span><br><span class="line">chunker = AutoChunker()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>文本分块是RAG系统中看似简单实则关键的一环。通过Chonkie提供的多样化分块方法，大家可以根据具体需求选择最适合的策略。记住，没有放之四海而皆准的最佳分块方法，只有最适合当前文本类型和使用场景的选择。可以从SemanticChunker开始实验，再根据实际效果进行调整，逐步构建出最适合自己RAG系统的文本处理流水线。</p>
]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>RAG</tag>
        <tag>大模型</tag>
        <tag>文本分块</tag>
        <tag>chonkie</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-在线安装docker脚本</title>
    <url>/2025/03/31/docker-%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85docker%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>这里直接给出脚本内容，脚本内容中已经包含了添加阿里云镜像源的步骤，直接运行即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在线安装 Docker 脚本（使用阿里云镜像源）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">适用于 Ubuntu 系统</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查脚本是否以 root 用户运行</span></span><br><span class="line">if [[ $EUID -ne 0 ]]; then</span><br><span class="line">    echo &quot;该脚本需要以 root 用户运行！&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;正在确认安装curl命令&quot;</span><br><span class="line">apt-get install curl -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否已安装 Docker</span></span><br><span class="line">if command -v docker &amp;&gt;/dev/null; then</span><br><span class="line">    echo &quot;检测到系统中已安装 Docker。&quot;</span><br><span class="line">    read -p &quot;是否需要卸载并重新安装 Docker? [y/N]: &quot; reinstall_docker</span><br><span class="line">    if [[ $reinstall_docker =~ ^[Yy]$ ]]; then</span><br><span class="line">        echo &quot;停止并卸载现有 Docker...&quot;</span><br><span class="line">        systemctl stop docker</span><br><span class="line">        apt-get remove -y docker docker-engine docker.io containerd runc</span><br><span class="line">        rm -rf /var/lib/docker</span><br><span class="line">        echo &quot;现有 Docker 已卸载。&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;用户选择保留现有 Docker，脚本退出。&quot;</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加阿里云 Docker 镜像源</span></span><br><span class="line">echo &quot;添加阿里云 Docker 镜像源...&quot;</span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta prompt_">  $</span><span class="language-bash">(lsb_release -cs) stable<span class="string">&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">更新软件包列表</span></span></span><br><span class="line">echo &quot;更新软件包列表...&quot;</span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">安装 Docker</span></span></span><br><span class="line">echo &quot;安装 Docker...&quot;</span><br><span class="line">apt-get install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">检查 Docker 是否安装成功</span></span></span><br><span class="line">if command -v docker &amp;&gt;/dev/null; then</span><br><span class="line">    echo &quot;Docker 安装成功！&quot;</span><br><span class="line">    echo &quot;启动 Docker 服务...&quot;</span><br><span class="line">    systemctl start docker</span><br><span class="line">    systemctl enable docker</span><br><span class="line">    echo &quot;Docker 服务已启动。&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Docker 安装失败，请检查日志！&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">添加当前用户到 docker 组（可选）</span></span></span><br><span class="line">usermod -aG docker $USER</span><br><span class="line">echo &quot;已将用户 $USER 添加到 docker 组。&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Docker 安装完成！&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-如何在容器内使用显卡资源</title>
    <url>/2025/03/31/docker-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%86%85%E4%BD%BF%E7%94%A8%E6%98%BE%E5%8D%A1%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="1-为什么需要-NVIDIA-Container-Toolkit？"><a href="#1-为什么需要-NVIDIA-Container-Toolkit？" class="headerlink" title="1. 为什么需要 NVIDIA Container Toolkit？"></a><strong>1. 为什么需要 NVIDIA Container Toolkit？</strong></h2><p>在 Docker 中运行深度学习、AI 计算或图形渲染应用时，通常需要调用 GPU 加速。但默认情况下，Docker 容器无法直接访问宿主机的 NVIDIA 显卡，这时就需要 <strong>NVIDIA Container Toolkit</strong>（原名 <code>nvidia-docker</code>）来打通容器与 GPU 之间的桥梁。</p>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ul>
<li>允许 Docker 容器直接访问宿主机上的 NVIDIA GPU。</li>
<li>自动挂载 GPU 驱动和 CUDA 库到容器内。</li>
<li>兼容主流容器运行时（Docker、containerd、Podman）。</li>
</ul>
<hr>
<h2 id="2-NVIDIA-Container-Toolkit-组件解析"><a href="#2-NVIDIA-Container-Toolkit-组件解析" class="headerlink" title="2. NVIDIA Container Toolkit 组件解析"></a><strong>2. NVIDIA Container Toolkit 组件解析</strong></h2><p>该工具包主要由以下组件构成：</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>nvidia-container-toolkit</code></td>
<td>核心组件，负责在容器启动时注入 GPU 相关设备与驱动。</td>
</tr>
<tr>
<td><code>libnvidia-container</code></td>
<td>底层库，处理容器与 GPU 的交互逻辑。</td>
</tr>
<tr>
<td><code>nvidia-container-runtime</code></td>
<td>替换 Docker 默认的 <code>runc</code>，支持 GPU 设备的动态绑定。</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-手动安装步骤（附脚本解析）"><a href="#3-手动安装步骤（附脚本解析）" class="headerlink" title="3. 手动安装步骤（附脚本解析）"></a><strong>3. 手动安装步骤（附脚本解析）</strong></h2><p>以下是你的脚本逐行解析，已优化为完整安装流程：</p>
<h3 id="步骤-1：添加-GPG-密钥"><a href="#步骤-1：添加-GPG-密钥" class="headerlink" title="步骤 1：添加 GPG 密钥"></a><strong>步骤 1：添加 GPG 密钥</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg ./gpgkey</span><br></pre></td></tr></table></figure>
<blockquote>
<p>./gpgkey是我下载到本地的gpgkey文件</p>
</blockquote>
<ul>
<li><strong>作用</strong>：将 NVIDIA 的 GPG 密钥转换为二进制格式，确保软件包来源可信。</li>
</ul>
<h3 id="步骤-2：配置镜像源（国内加速）"><a href="#步骤-2：配置镜像源（国内加速）" class="headerlink" title="步骤 2：配置镜像源（国内加速）"></a><strong>步骤 2：配置镜像源（国内加速）</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -L https://mirrors.ustc.edu.cn/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">sudo sed <span class="string">&#x27;s#deb https://nvidia.github.io#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://mirrors.ustc.edu.cn#g&#x27;</span> | \</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关键点</strong>：  <ul>
<li>使用中科大镜像源（<code>mirrors.ustc.edu.cn</code>）替代官方源，加速下载。  </li>
<li><code>[signed-by]</code> 指定密钥路径，避免安全警告。</li>
</ul>
</li>
</ul>
<h3 id="步骤-3：安装工具包"><a href="#步骤-3：安装工具包" class="headerlink" title="步骤 3：安装工具包"></a><strong>步骤 3：安装工具包</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y nvidia-container-toolkit</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：安装时会自动依赖 <code>libnvidia-container</code> 和 <code>nvidia-container-runtime</code>。</li>
</ul>
<h3 id="步骤-4：配置-Docker-运行时"><a href="#步骤-4：配置-Docker-运行时" class="headerlink" title="步骤 4：配置 Docker 运行时"></a><strong>步骤 4：配置 Docker 运行时</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nvidia-ctk runtime configure --runtime=docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：  <ul>
<li><code>nvidia-ctk</code> 命令生成 <code>/etc/docker/daemon.json</code>，将默认运行时替换为 <code>nvidia-container-runtime</code>。  </li>
<li>重启 Docker 使配置生效。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-验证安装是否成功"><a href="#4-验证安装是否成功" class="headerlink" title="4. 验证安装是否成功"></a><strong>4. 验证安装是否成功</strong></h2><p>运行一个测试容器，检查 GPU 是否可见：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda:12.2-base nvidia-smi</span><br></pre></td></tr></table></figure>
<p><strong>预期输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 535.86.05    Driver Version: 535.86.05    CUDA Version: 12.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce ...  On   | 00000000:01:00.0 Off |                  N/A |</span><br><span class="line">| 30%   45C    P0    25W / 180W |      0MiB / 12288MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--gpus all</code>：允许容器使用所有 GPU。  </li>
<li>若看到 GPU 信息，则配置成功！</li>
</ul>
<hr>
<h2 id="5-常见问题与解决方案"><a href="#5-常见问题与解决方案" class="headerlink" title="5. 常见问题与解决方案"></a><strong>5. 常见问题与解决方案</strong></h2><h3 id="Q1：安装后-Docker-无法启动"><a href="#Q1：安装后-Docker-无法启动" class="headerlink" title="Q1：安装后 Docker 无法启动"></a><strong>Q1：安装后 Docker 无法启动</strong></h3><ul>
<li><strong>原因</strong>：<code>daemon.json</code> 配置错误。  </li>
<li><strong>修复</strong>：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /etc/docker/daemon.json</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Q2：容器内无法找到-GPU"><a href="#Q2：容器内无法找到-GPU" class="headerlink" title="Q2：容器内无法找到 GPU"></a><strong>Q2：容器内无法找到 GPU</strong></h3><ul>
<li><strong>检查项</strong>：  <ol>
<li>宿主机驱动是否正常（<code>nvidia-smi</code> 能否运行）。  </li>
<li>Docker 运行时是否为 <code>nvidia</code>（<code>docker info | grep Runtime</code>）。  </li>
</ol>
</li>
</ul>
<h3 id="Q3：如何指定使用特定-GPU？"><a href="#Q3：如何指定使用特定-GPU？" class="headerlink" title="Q3：如何指定使用特定 GPU？"></a><strong>Q3：如何指定使用特定 GPU？</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --gpus <span class="string">&#x27;&quot;device=0,1&quot;&#x27;</span> nvidia/cuda:11.0-base nvidia-smi  <span class="comment"># 仅使用 GPU 0 和 1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-提一嘴：Kubernetes-中的-GPU-支持"><a href="#6-提一嘴：Kubernetes-中的-GPU-支持" class="headerlink" title="6. 提一嘴：Kubernetes 中的 GPU 支持"></a><strong>6. 提一嘴：Kubernetes 中的 GPU 支持</strong></h2><p>若需在 K8S 中使用 GPU，需额外配置：  </p>
<ol>
<li>安装 NVIDIA Device Plugin：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v0.14.1/nvidia-device-plugin.yml</span><br></pre></td></tr></table></figure></li>
<li>在 Pod 中声明资源：  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">nvidia.com/gpu:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h2><ul>
<li><strong>NVIDIA Container Toolkit</strong> 是 Docker 调用 GPU 的必备工具。  </li>
<li>通过 <code>--gpus</code> 参数控制容器对 GPU 的访问权限。  </li>
<li>生产环境中建议结合 Kubernetes Device Plugin 管理集群 GPU 资源。  </li>
</ul>
<p>你的安装脚本已完美覆盖关键步骤，建议保存为 <code>install-nvidia-docker.sh</code> 方便复用！  </p>
<p><strong>附完整脚本</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 一键安装 NVIDIA Container Toolkit</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[1/4] 添加 GPG 密钥...&quot;</span></span><br><span class="line">sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg ./gpgkey</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[2/4] 配置镜像源...&quot;</span></span><br><span class="line">curl -s -L https://mirrors.ustc.edu.cn/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">  sudo sed <span class="string">&#x27;s#deb https://nvidia.github.io#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://mirrors.ustc.edu.cn#g&#x27;</span> | \</span><br><span class="line">  sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list &gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[3/4] 安装工具包...&quot;</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[4/4] 配置 Docker...&quot;</span></span><br><span class="line">sudo nvidia-ctk runtime configure --runtime=docker</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;验证安装：&quot;</span></span><br><span class="line">docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda:12.2-base nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>GPU</tag>
        <tag>NVIDIA</tag>
      </tags>
  </entry>
  <entry>
    <title>docker与k8s的异同</title>
    <url>/2025/03/31/docker%E4%B8%8Ek8s%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>容器化技术已经成为现代云计算和DevOps的核心组成部分，而 <strong>Docker</strong> 和 <strong>Kubernetes（K8S）</strong> 是其中最重要的两个工具。很多人对它们的定位和关系感到困惑：  </p>
<ul>
<li><strong>Docker 负责什么？</strong>  </li>
<li><strong>Kubernetes 又负责什么？</strong>  </li>
<li><strong>它们的网络模型有何不同？</strong>  </li>
</ul>
<p>本文将从 <strong>架构定位、核心功能、网络模型</strong> 三个方面深入对比，帮助你彻底理解二者的关系与差异。</p>
<hr>
<h2 id="1-Docker-与-Kubernetes-的定位与关系"><a href="#1-Docker-与-Kubernetes-的定位与关系" class="headerlink" title="1. Docker 与 Kubernetes 的定位与关系"></a><strong>1. Docker 与 Kubernetes 的定位与关系</strong></h2><h3 id="1-Docker：单机容器运行时"><a href="#1-Docker：单机容器运行时" class="headerlink" title="(1) Docker：单机容器运行时"></a><strong>(1) Docker：单机容器运行时</strong></h3><ul>
<li><strong>核心功能</strong>：  <ul>
<li>创建、运行和管理<strong>单个容器</strong>（应用打包与隔离）。  </li>
<li>提供镜像构建（<code>Dockerfile</code>）和分发（Docker Hub）。  </li>
</ul>
</li>
<li><strong>适用场景</strong>：  <ul>
<li>本地开发、测试环境。  </li>
<li>单机部署简单应用。  </li>
</ul>
</li>
</ul>
<h3 id="2-Kubernetes：容器编排系统"><a href="#2-Kubernetes：容器编排系统" class="headerlink" title="(2) Kubernetes：容器编排系统"></a><strong>(2) Kubernetes：容器编排系统</strong></h3><ul>
<li><strong>核心功能</strong>：  <ul>
<li>管理<strong>多个容器化应用</strong>的部署、伸缩、负载均衡。  </li>
<li>自动化运维（自愈、滚动更新、服务发现）。  </li>
</ul>
</li>
<li><strong>适用场景</strong>：  <ul>
<li>生产环境的大规模集群管理。  </li>
<li>微服务架构（数百个容器的协同）。  </li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>类比理解</strong>：  </p>
<ul>
<li><strong>Docker</strong> 像是一台“集装箱卡车”，负责单个容器的运输。  </li>
<li><strong>Kubernetes</strong> 像是“全球物流系统”，调度成千上万的卡车和集装箱。  </li>
</ul>
</blockquote>
<hr>
<h2 id="2-核心区别对比"><a href="#2-核心区别对比" class="headerlink" title="2. 核心区别对比"></a><strong>2. 核心区别对比</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Docker</th>
<th>Kubernetes (K8S)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心目标</strong></td>
<td>创建和运行容器</td>
<td>编排和管理多个容器</td>
</tr>
<tr>
<td><strong>集群支持</strong></td>
<td>单机（需 Swarm 扩展集群能力）</td>
<td>原生支持多节点集群</td>
</tr>
<tr>
<td><strong>伸缩性</strong></td>
<td>手动</td>
<td>自动扩缩容（HPA）</td>
</tr>
<tr>
<td><strong>服务发现</strong></td>
<td>需手动配置或依赖第三方工具</td>
<td>内置 DNS 和服务发现（Service）</td>
</tr>
<tr>
<td><strong>存储管理</strong></td>
<td>本地卷或插件</td>
<td>支持 PV/PVC（动态存储）</td>
</tr>
<tr>
<td><strong>网络模型</strong></td>
<td>单机网络（bridge/host/none）</td>
<td>集群级网络（CNI 插件）</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-网络模型详解"><a href="#3-网络模型详解" class="headerlink" title="3. 网络模型详解"></a><strong>3. 网络模型详解</strong></h2><h3 id="1-Docker-网络"><a href="#1-Docker-网络" class="headerlink" title="(1) Docker 网络"></a><strong>(1) Docker 网络</strong></h3><p>Docker 的网络是<strong>单机级别</strong>的，主要模式包括：</p>
<ul>
<li><strong><code>bridge</code>（默认）</strong>：  <ul>
<li>容器通过虚拟网桥（<code>docker0</code>）通信，分配私有 IP。  </li>
<li>外部访问需端口映射（<code>-p 8080:80</code>）。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:80 nginx  <span class="comment"># 映射主机端口</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>**<code>host</code>**：  <ul>
<li>容器直接使用主机网络栈（无隔离，性能高）。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --network=host nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>**<code>none</code>**：  <ul>
<li>无网络（仅用于特殊场景）。  </li>
</ul>
</li>
</ul>
<p><strong>局限性</strong>：  </p>
<ul>
<li>跨主机通信需手动配置（如 Overlay 网络或第三方工具）。  </li>
</ul>
<hr>
<h3 id="2-Kubernetes-网络"><a href="#2-Kubernetes-网络" class="headerlink" title="(2) Kubernetes 网络"></a><strong>(2) Kubernetes 网络</strong></h3><p>K8S 的网络是<strong>集群级别</strong>的，核心要求：  </p>
<blockquote>
<p><strong>所有 Pod 之间可以直接通信</strong>（无论是否在同一节点）。</p>
</blockquote>
<h4 id="关键组件："><a href="#关键组件：" class="headerlink" title="关键组件："></a><strong>关键组件</strong>：</h4><ol>
<li><p><strong>Pod 网络</strong>：  </p>
<ul>
<li>每个 Pod 拥有唯一 IP（容器共享网络命名空间）。  </li>
<li>通过 <strong>CNI（Container Network Interface）插件</strong>实现：  <ul>
<li><strong>Calico</strong>（BGP 路由）  </li>
<li><strong>Flannel</strong>（Overlay 网络）  </li>
<li><strong>Cilium</strong>（eBPF 高性能）  </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Service 网络</strong>：  </p>
<ul>
<li>为 Pod 提供稳定的虚拟 IP（VIP）和负载均衡。  </li>
<li>类型包括：  <ul>
<li><code>ClusterIP</code>（集群内访问）  </li>
<li><code>NodePort</code>（主机端口暴露）  </li>
<li><code>LoadBalancer</code>（云厂商 LB 集成）  </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Ingress</strong>：  </p>
<ul>
<li>管理外部 HTTP/S 流量路由（如 Nginx Ingress Controller）。  </li>
</ul>
</li>
</ol>
<h4 id="示例流量路径："><a href="#示例流量路径：" class="headerlink" title="示例流量路径："></a><strong>示例流量路径</strong>：</h4><pre class="mermaid">graph LR
    A[外部用户] --> B[Ingress]
    B --> C[Service]
    C --> D[Pod 1]
    C --> E[Pod 2]</pre>

<hr>
<h2 id="4-如何选择？"><a href="#4-如何选择？" class="headerlink" title="4. 如何选择？"></a><strong>4. 如何选择？</strong></h2><ul>
<li><p><strong>只用 Docker</strong>：  </p>
<ul>
<li>适合本地开发、单机应用。  </li>
<li>例子：快速运行一个 PostgreSQL 容器。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name postgres -e POSTGRES_PASSWORD=123456 postgres</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 Kubernetes</strong>：  </p>
<ul>
<li>适合生产环境、微服务架构。  </li>
<li>例子：部署一个高可用的 Web 应用：  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-常见问题解答"><a href="#5-常见问题解答" class="headerlink" title="5. 常见问题解答"></a><strong>5. 常见问题解答</strong></h2><p><strong>Q1：Docker 和 Kubernetes 必须一起用吗？</strong>  </p>
<ul>
<li>不是。Docker 可以单独使用，但 K8S 需要容器运行时（如 Docker、containerd）。  </li>
</ul>
<p><strong>Q2：K8S 替代 Docker 了吗？</strong>  </p>
<ul>
<li>不是替代关系，而是互补。Docker 负责“容器化”，K8S 负责“编排”。  </li>
</ul>
<p><strong>Q3：K8S 网络为什么比 Docker 复杂？</strong>  </p>
<ul>
<li>Docker 只需处理单机，K8S 需解决跨主机通信、服务发现、安全策略等分布式问题。  </li>
</ul>
<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>Docker</strong></th>
<th><strong>Kubernetes</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定位</strong></td>
<td>容器运行时</td>
<td>容器编排平台</td>
</tr>
<tr>
<td><strong>网络范围</strong></td>
<td>单机</td>
<td>跨主机集群</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>开发/测试</td>
<td>生产/大规模部署</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>推荐学习路径</strong>：  </p>
<ol>
<li>先掌握 Docker（容器化基础）。  </li>
<li>再学习 Kubernetes（编排与生产实践）。  </li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose与k8s对比</title>
    <url>/2025/03/31/docker-compose%E4%B8%8Ek8s%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>在现代容器化生态中，<strong>Docker Compose</strong> 和 <strong>Kubernetes（K8S）</strong> 是两个最常用的编排工具，但它们的设计目标和适用场景截然不同。本文将深入分析它们的异同、优劣势及互补关系，帮助你做出合理的技术选型。</p>
<hr>
<h2 id="1-核心定位对比"><a href="#1-核心定位对比" class="headerlink" title="1. 核心定位对比"></a><strong>1. 核心定位对比</strong></h2><h3 id="Docker-Compose：轻量级单机编排"><a href="#Docker-Compose：轻量级单机编排" class="headerlink" title="Docker Compose：轻量级单机编排"></a><strong>Docker Compose：轻量级单机编排</strong></h3><ul>
<li><strong>定位</strong>：定义和运行<strong>多个关联容器</strong>（如 Web + DB + Cache）。  </li>
<li><strong>适用场景</strong>：  <ul>
<li>本地开发环境  </li>
<li>单机测试部署  </li>
<li>快速原型验证  </li>
</ul>
</li>
</ul>
<h3 id="Kubernetes：企业级分布式编排"><a href="#Kubernetes：企业级分布式编排" class="headerlink" title="Kubernetes：企业级分布式编排"></a><strong>Kubernetes：企业级分布式编排</strong></h3><ul>
<li><strong>定位</strong>：管理<strong>跨多节点的大规模容器集群</strong>。  </li>
<li><strong>适用场景</strong>：  <ul>
<li>生产环境微服务架构  </li>
<li>高可用、自动伸缩需求  </li>
<li>混合云/多云部署  </li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>类比</strong>：  </p>
<ul>
<li>Docker Compose 像“乐高说明书”，指导如何组装一组容器。  </li>
<li>Kubernetes 像“智能机器人流水线”，自动管理全球工厂的乐高生产。  </li>
</ul>
</blockquote>
<hr>
<h2 id="2-功能对比"><a href="#2-功能对比" class="headerlink" title="2. 功能对比"></a><strong>2. 功能对比</strong></h2><table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th>Docker Compose</th>
<th>Kubernetes</th>
</tr>
</thead>
<tbody><tr>
<td><strong>部署单元</strong></td>
<td>容器组（Services）</td>
<td>Pod（1个或多个容器）</td>
</tr>
<tr>
<td><strong>伸缩能力</strong></td>
<td>手动（<code>docker-compose up --scale</code>）</td>
<td>自动（HPA/VPA）</td>
</tr>
<tr>
<td><strong>服务发现</strong></td>
<td>容器名称作为DNS</td>
<td>内置 Service + DNS</td>
</tr>
<tr>
<td><strong>负载均衡</strong></td>
<td>需手动配置</td>
<td>原生支持（Ingress + Service）</td>
</tr>
<tr>
<td><strong>存储管理</strong></td>
<td>本地卷或简单驱动</td>
<td>PV/PVC（动态供给）</td>
</tr>
<tr>
<td><strong>滚动更新</strong></td>
<td>需手动操作</td>
<td>声明式滚动更新（Deployment）</td>
</tr>
<tr>
<td><strong>健康检查</strong></td>
<td>有限支持</td>
<td>完备的 Liveness/Readiness 探针</td>
</tr>
<tr>
<td><strong>跨主机网络</strong></td>
<td>依赖第三方插件</td>
<td>原生 CNI 网络插件</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-配置文件对比"><a href="#3-配置文件对比" class="headerlink" title="3. 配置文件对比"></a><strong>3. 配置文件对比</strong></h2><h3 id="Docker-Compose（YAML）"><a href="#Docker-Compose（YAML）" class="headerlink" title="Docker Compose（YAML）"></a><strong>Docker Compose（YAML）</strong></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/postgresql/data</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：简单直观，适合定义少量服务的依赖关系。</li>
</ul>
<h3 id="Kubernetes（多YAML组合）"><a href="#Kubernetes（多YAML组合）" class="headerlink" title="Kubernetes（多YAML组合）"></a><strong>Kubernetes（多YAML组合）</strong></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：模块化设计，需拆分多个资源对象（Deployment/Service/Ingress 等）。</li>
</ul>
<hr>
<h2 id="4-优势与劣势"><a href="#4-优势与劣势" class="headerlink" title="4. 优势与劣势"></a><strong>4. 优势与劣势</strong></h2><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a><strong>Docker Compose</strong></h3><p><strong>✅ 优势</strong>：  </p>
<ul>
<li>学习成本极低，5分钟上手。  </li>
<li>开发环境一键启停（<code>docker-compose up/down</code>）。  </li>
<li>无需集群，单机即可运行。  </li>
</ul>
<p><strong>❌ 劣势</strong>：  </p>
<ul>
<li>无自动扩缩容能力。  </li>
<li>缺乏生产级高可用保障。  </li>
<li>跨主机部署复杂。  </li>
</ul>
<h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a><strong>Kubernetes</strong></h3><p><strong>✅ 优势</strong>：  </p>
<ul>
<li>企业级功能（自愈、滚动更新、资源配额）。  </li>
<li>天然支持多云/混合云。  </li>
<li>丰富的生态系统（Helm、Operators、CRD）。  </li>
</ul>
<p><strong>❌ 劣势</strong>：  </p>
<ul>
<li>学习曲线陡峭，需掌握大量概念（Pod/Service/Ingress/PVC 等）。  </li>
<li>本地开发需要 Minikube/Kind 等工具。  </li>
<li>运维复杂度高。  </li>
</ul>
<hr>
<h2 id="5-互补与冲突"><a href="#5-互补与冲突" class="headerlink" title="5. 互补与冲突"></a><strong>5. 互补与冲突</strong></h2><h3 id="互补场景"><a href="#互补场景" class="headerlink" title="互补场景"></a><strong>互补场景</strong></h3><ol>
<li><p><strong>开发与生产的协作</strong>：  </p>
<ul>
<li>开发阶段用 <code>docker-compose.yml</code> 快速启动环境。  </li>
<li>生产阶段转换为 K8S 的 Helm Chart 或 Kustomize 配置。  </li>
<li>工具如 <code>kompose</code> 可自动转换 Compose 文件为 K8S 资源。  </li>
</ul>
</li>
<li><p><strong>本地调试与集群部署</strong>：  </p>
<ul>
<li>本地使用 Docker Compose 模拟依赖服务（如数据库）。  </li>
<li>远程 K8S 集群运行核心业务。  </li>
</ul>
</li>
</ol>
<h3 id="冲突点"><a href="#冲突点" class="headerlink" title="冲突点"></a><strong>冲突点</strong></h3><ol>
<li><strong>网络模型不兼容</strong>：  <ul>
<li>Compose 的 <code>networks</code> 与 K8S 的 CNI 插件无法直接互通。  </li>
</ul>
</li>
<li><strong>配置管理差异</strong>：  <ul>
<li>Compose 的环境变量优先级策略与 K8S ConfigMap/Secret 不同。  </li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-如何选择？"><a href="#6-如何选择？" class="headerlink" title="6. 如何选择？"></a><strong>6. 如何选择？</strong></h2><h3 id="选择-Docker-Compose-如果："><a href="#选择-Docker-Compose-如果：" class="headerlink" title="选择 Docker Compose 如果："></a><strong>选择 Docker Compose 如果：</strong></h3><ul>
<li>你是开发者，需要快速搭建本地环境。  </li>
<li>项目仅需运行在单台机器上（如小型应用）。  </li>
<li>不想投入时间学习 K8S。  </li>
</ul>
<h3 id="选择-Kubernetes-如果："><a href="#选择-Kubernetes-如果：" class="headerlink" title="选择 Kubernetes 如果："></a><strong>选择 Kubernetes 如果：</strong></h3><ul>
<li>应用需要高可用（如用户量 &gt; 1k）。  </li>
<li>团队有 DevOps 能力或云平台支持。  </li>
<li>未来需要横向扩展（微服务架构）。  </li>
</ul>
<hr>
<h2 id="7-进阶建议"><a href="#7-进阶建议" class="headerlink" title="7. 进阶建议"></a><strong>7. 进阶建议</strong></h2><ul>
<li><strong>从 Compose 迁移到 K8S</strong>：<br>使用 <code>kompose convert</code> 工具生成基础 K8S YAML，再手动优化。  </li>
<li><strong>混合使用</strong>：<br>开发环境保留 Compose，生产环境使用 K8S + Helm。  </li>
<li><strong>性能敏感场景</strong>：<br>K8S 的 Resource Quotas 和 Affinity 规则能更好地控制资源分配。  </li>
</ul>
<hr>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>Docker Compose</strong></th>
<th><strong>Kubernetes</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>复杂度</strong></td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>单机</td>
<td>跨集群</td>
</tr>
<tr>
<td><strong>适用阶段</strong></td>
<td>开发/测试</td>
<td>生产</td>
</tr>
<tr>
<td><strong>自动化能力</strong></td>
<td>弱</td>
<td>强</td>
</tr>
</tbody></table>
<p><strong>最终建议</strong>：  </p>
<ul>
<li><strong>个人开发者/小项目</strong>：Compose 足矣。  </li>
<li><strong>企业级服务/长期项目</strong>：尽早拥抱 K8S。  </li>
</ul>
<blockquote>
<p>注意：两者并非竞争关系，而是针对不同场景的解决方案。合理搭配使用，能最大化开发与运维效率！ 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>doc与docx的历史</title>
    <url>/2025/03/31/%E5%B7%A5%E5%85%B7-doc%E4%B8%8Edocx%E7%9A%84%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<p>在 Linux 系统上处理 Microsoft Word 文档时，我们经常会遇到两种格式：<code>.doc</code> 和 <code>.docx</code>。由于兼容性问题，有时需要将旧版 <code>.doc</code> 转换为 <code>.docx</code> 才能正常编辑。本文将详细介绍这两种格式的历史、区别，并讲解如何使用 <strong>LibreOffice</strong> 进行转换。</p>
<hr>
<h2 id="1-DOC-与-DOCX-的历史与区别"><a href="#1-DOC-与-DOCX-的历史与区别" class="headerlink" title="1. DOC 与 DOCX 的历史与区别"></a><strong>1. DOC 与 DOCX 的历史与区别</strong></h2><h3 id="1-DOC-格式（1990s–2007）"><a href="#1-DOC-格式（1990s–2007）" class="headerlink" title="(1) DOC 格式（1990s–2007）"></a><strong>(1) DOC 格式（1990s–2007）</strong></h3><ul>
<li><strong>诞生</strong>：DOC 是 Microsoft Word 的专有二进制格式，最早随 Word 1.0（1983）推出，并在 Word 97–2003 成为主流。</li>
<li><strong>特点</strong>：<ul>
<li>二进制存储（不可直接阅读）。</li>
<li>文件体积较大（未优化压缩）。</li>
<li>兼容性问题较多（不同 Word 版本可能显示不同）。</li>
</ul>
</li>
<li><strong>现状</strong>：<ul>
<li>已淘汰，但仍有一些旧文档使用。</li>
</ul>
</li>
</ul>
<h3 id="2-DOCX-格式（2007–至今）"><a href="#2-DOCX-格式（2007–至今）" class="headerlink" title="(2) DOCX 格式（2007–至今）"></a><strong>(2) DOCX 格式（2007–至今）</strong></h3><ul>
<li><strong>诞生</strong>：DOCX 是 Microsoft Office 2007 引入的 <strong>Office Open XML (OOXML)</strong> 格式，现为 Word 默认格式。</li>
<li><strong>特点</strong>：<ul>
<li>基于 XML（结构化文本，可解压查看内容）。</li>
<li>采用 ZIP 压缩，文件更小。</li>
<li>兼容性更好（支持现代 Office 及开源软件）。</li>
</ul>
</li>
<li><strong>优势</strong>：<ul>
<li>更安全（不易损坏）。</li>
<li>支持高级功能（如 SmartArt、新样式）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>DOC vs DOCX 核心区别</strong>：<br>| 特性       | DOC (Word 97-2003) | DOCX (Word 2007+) |<br>|————|——————–|——————-|<br>| <strong>格式</strong>   | 二进制             | XML + ZIP 压缩    |<br>| <strong>体积</strong>   | 较大               | 较小              |<br>| <strong>兼容性</strong> | 旧版软件           | 现代软件          |<br>| <strong>扩展性</strong> | 功能有限           | 支持新特性        |</p>
</blockquote>
<hr>
<h2 id="2-为什么在-Linux-上需要转换？"><a href="#2-为什么在-Linux-上需要转换？" class="headerlink" title="2. 为什么在 Linux 上需要转换？"></a><strong>2. 为什么在 Linux 上需要转换？</strong></h2><ul>
<li><strong>兼容性问题</strong>：<ul>
<li>LibreOffice 对 <code>.doc</code> 的支持不如 <code>.docx</code> 完善（可能丢失格式）。</li>
<li>新版 Microsoft Word 已逐步放弃 <code>.doc</code> 的官方支持。</li>
</ul>
</li>
<li><strong>功能需求</strong>：<ul>
<li><code>.docx</code> 支持更丰富的排版、图表和样式。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-LibreOffice：开源办公套件"><a href="#3-LibreOffice：开源办公套件" class="headerlink" title="3. LibreOffice：开源办公套件"></a><strong>3. LibreOffice：开源办公套件</strong></h2><p>LibreOffice 是 <strong>最流行的开源 Office 套件</strong>，支持 DOC/DOCX 的读写与转换，包含：</p>
<ul>
<li><strong>Writer</strong>（Word 替代）</li>
<li><strong>Calc</strong>（Excel 替代）</li>
<li><strong>Impress</strong>（PowerPoint 替代）</li>
</ul>
<h3 id="安装-LibreOffice"><a href="#安装-LibreOffice" class="headerlink" title="安装 LibreOffice"></a><strong>安装 LibreOffice</strong></h3><p>在 Linux 上安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo apt install libreoffice</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo yum install libreoffice</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arch Linux</span></span><br><span class="line">sudo pacman -S libreoffice-fresh</span><br></pre></td></tr></table></figure>

<h3 id="使用-LibreOffice-转换-DOC-→-DOCX"><a href="#使用-LibreOffice-转换-DOC-→-DOCX" class="headerlink" title="使用 LibreOffice 转换 DOC → DOCX"></a><strong>使用 LibreOffice 转换 DOC → DOCX</strong></h3><h4 id="方法-1：GUI-图形界面"><a href="#方法-1：GUI-图形界面" class="headerlink" title="方法 1：GUI 图形界面"></a><strong>方法 1：GUI 图形界面</strong></h4><ol>
<li>打开 LibreOffice Writer。</li>
<li>点击 <strong>文件 → 打开</strong>，选择 <code>.doc</code> 文件。</li>
<li>点击 <strong>文件 → 另存为</strong>，格式选择 **”Word 2007-365 (.docx)”**。</li>
<li>保存即可。</li>
</ol>
<h4 id="方法-2：命令行批量转换"><a href="#方法-2：命令行批量转换" class="headerlink" title="方法 2：命令行批量转换"></a><strong>方法 2：命令行批量转换</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">libreoffice --headless --convert-to docx *.doc</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--headless</code>：无图形界面模式（适合服务器）。</li>
<li><code>*.doc</code>：匹配所有 <code>.doc</code> 文件。</li>
</ul>
<h4 id="方法-3：Python-脚本自动化"><a href="#方法-3：Python-脚本自动化" class="headerlink" title="方法 3：Python 脚本自动化"></a><strong>方法 3：Python 脚本自动化</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&quot;libreoffice --convert-to docx /path/to/file.doc&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-其他转换工具（备选）"><a href="#4-其他转换工具（备选）" class="headerlink" title="4. 其他转换工具（备选）"></a><strong>4. 其他转换工具（备选）</strong></h2><table>
<thead>
<tr>
<th>工具</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Pandoc</strong></td>
<td>支持 DOC/DOCX/ODT 互转（需安装）</td>
</tr>
<tr>
<td><strong>unoconv</strong></td>
<td>调用 LibreOffice 进行转换</td>
</tr>
<tr>
<td><strong>Google Docs</strong></td>
<td>在线导入后下载为 DOCX</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-转换注意事项"><a href="#5-转换注意事项" class="headerlink" title="5. 转换注意事项"></a><strong>5. 转换注意事项</strong></h2><ul>
<li><strong>格式可能丢失</strong>：复杂排版、宏或特殊字体可能无法完美转换。</li>
<li><strong>批量处理</strong>：建议用命令行或脚本自动化。</li>
<li><strong>版本问题</strong>：确保使用最新版 LibreOffice（≥7.0）。</li>
</ul>
<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h2><ul>
<li><strong>DOC</strong>：旧版二进制格式，已淘汰，兼容性差。  </li>
<li><strong>DOCX</strong>：现代 XML 格式，推荐使用。  </li>
<li><strong>LibreOffice</strong>：Linux 最佳转换工具，支持 GUI/CLI。  </li>
</ul>
<p><strong>推荐操作</strong>：</p>
<ol>
<li>将旧 <code>.doc</code> 转换为 <code>.docx</code> 以确保兼容性。</li>
<li>使用 <code>libreoffice --convert-to</code> 批量处理。</li>
<li>检查转换后的文件是否有格式错误。</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title>打包与压缩</title>
    <url>/2025/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>在软件开发、数据备份和文件传输中，我们经常会遇到各种归档和压缩格式，如 <strong>ZIP、TAR、TAR.GZ、RAR、7Z</strong> 等。这些格式有些是<strong>纯打包</strong>，有些是<strong>纯压缩</strong>，有些则是<strong>打包+压缩</strong>的组合。本文将详细解析它们的区别、适用场景及优缺点。</p>
<hr>
<h2 id="1-基础概念：打包-vs-压缩"><a href="#1-基础概念：打包-vs-压缩" class="headerlink" title="1. 基础概念：打包 vs 压缩"></a><strong>1. 基础概念：打包 vs 压缩</strong></h2><p>在讨论具体格式之前，先明确两个核心概念：</p>
<ul>
<li><p><strong>打包（Archiving）</strong>：将多个文件或目录合并成一个文件，但不进行压缩。<br><strong>特点</strong>：保留文件结构、权限、元数据，但文件大小不变。<br><strong>典型格式</strong>：<code>TAR</code>、<code>CPIO</code>。</p>
</li>
<li><p><strong>压缩（Compression）</strong>：通过算法减少文件体积，但不涉及多文件管理。<br><strong>特点</strong>：文件变小，但通常只能压缩单个文件（除非先打包）。<br><strong>典型格式</strong>：<code>GZ</code>、<code>BZ2</code>、<code>XZ</code>、<code>ZSTD</code>。</p>
</li>
</ul>
<blockquote>
<p><strong>关键区别</strong>：  </p>
<ul>
<li><strong>打包</strong> = 合并文件（如 <code>tar</code>）  </li>
<li><strong>压缩</strong> = 减小体积（如 <code>gzip</code>）  </li>
<li><strong>打包+压缩</strong> = 先打包再压缩（如 <code>tar.gz</code>）</li>
</ul>
</blockquote>
<hr>
<h2 id="2-常见归档-压缩格式详解"><a href="#2-常见归档-压缩格式详解" class="headerlink" title="2. 常见归档/压缩格式详解"></a><strong>2. 常见归档/压缩格式详解</strong></h2><h3 id="1-纯打包格式"><a href="#1-纯打包格式" class="headerlink" title="(1) 纯打包格式"></a><strong>(1) 纯打包格式</strong></h3><h4 id="TAR-Tape-Archive"><a href="#TAR-Tape-Archive" class="headerlink" title="TAR (Tape Archive)"></a><strong>TAR (Tape Archive)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>Unix/Linux 标准打包工具，仅合并文件，不压缩。</li>
<li>保留文件权限、符号链接、时间戳等元数据。</li>
<li>通常结合压缩工具使用（如 <code>tar.gz</code>）。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>兼容性好，几乎所有系统支持。</li>
<li>适合备份目录结构。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>单独使用时不减少文件大小。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf archive.tar /path/to/files  <span class="comment"># 打包</span></span><br><span class="line">tar -xvf archive.tar                <span class="comment"># 解包</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-纯压缩格式"><a href="#2-纯压缩格式" class="headerlink" title="(2) 纯压缩格式"></a><strong>(2) 纯压缩格式</strong></h3><h4 id="GZIP-gz"><a href="#GZIP-gz" class="headerlink" title="GZIP (.gz)"></a><strong>GZIP (.gz)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>仅压缩单个文件（通常与 <code>tar</code> 配合使用，如 <code>.tar.gz</code>）。</li>
<li>使用 DEFLATE 算法，压缩比中等，速度较快。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>广泛支持，适合文本文件。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>不能压缩目录（需先打包）。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip file.txt       <span class="comment"># 压缩 -&gt; file.txt.gz</span></span><br><span class="line">gunzip file.txt.gz  <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="BZIP2-bz2"><a href="#BZIP2-bz2" class="headerlink" title="BZIP2 (.bz2)"></a><strong>BZIP2 (.bz2)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>比 <code>gzip</code> 压缩率更高（但更慢）。</li>
<li>适合不追求速度的场景（如长期存储）。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>压缩比比 <code>gzip</code> 高约 10%~20%。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>压缩/解压速度慢。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bzip2 file.txt      <span class="comment"># 压缩 -&gt; file.txt.bz2</span></span><br><span class="line">bunzip2 file.txt.bz2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="XZ-xz"><a href="#XZ-xz" class="headerlink" title="XZ (.xz)"></a><strong>XZ (.xz)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>使用 LZMA 算法，压缩率极高（但速度最慢）。</li>
<li>适合分发大型文件（如 Linux 发行版）。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>目前主流压缩率最高的算法之一。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>压缩/解压耗时长。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz file.txt         <span class="comment"># 压缩 -&gt; file.txt.xz</span></span><br><span class="line">unxz file.txt.xz</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-打包-压缩组合格式"><a href="#3-打包-压缩组合格式" class="headerlink" title="(3) 打包+压缩组合格式"></a><strong>(3) 打包+压缩组合格式</strong></h3><h4 id="TAR-GZ-tar-gz"><a href="#TAR-GZ-tar-gz" class="headerlink" title="TAR.GZ (.tar.gz)"></a><strong>TAR.GZ (.tar.gz)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>先用 <code>tar</code> 打包，再用 <code>gzip</code> 压缩。</li>
<li>Linux 最常见格式，平衡压缩率和速度。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>兼容性好，适合通用场景。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>压缩率不如 <code>tar.xz</code>。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf archive.tar.gz /path/to/files  <span class="comment"># 打包+压缩</span></span><br><span class="line">tar -xzvf archive.tar.gz                <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="TAR-XZ-tar-xz"><a href="#TAR-XZ-tar-xz" class="headerlink" title="TAR.XZ (.tar.xz)"></a><strong>TAR.XZ (.tar.xz)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>先用 <code>tar</code> 打包，再用 <code>xz</code> 压缩。</li>
<li>压缩率极高，适合大型文件存储。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>比 <code>tar.gz</code> 体积更小。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>压缩/解压速度慢。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cJvf archive.tar.xz /path/to/files</span><br><span class="line">tar -xJvf archive.tar.xz</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ZIP-zip"><a href="#ZIP-zip" class="headerlink" title="ZIP (.zip)"></a><strong>ZIP (.zip)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>同时打包+压缩（Windows 默认格式）。</li>
<li>支持密码加密（<code>zip -e</code>）。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>跨平台（Windows/macOS/Linux 原生支持）。</li>
<li>可随机访问文件（无需解压全部内容）。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>压缩率通常不如 <code>tar.gz</code>/<code>tar.xz</code>。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -r archive.zip /path/to/files  <span class="comment"># 压缩</span></span><br><span class="line">unzip archive.zip                 <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7Z-7z"><a href="#7Z-7z" class="headerlink" title="7Z (.7z)"></a><strong>7Z (.7z)</strong></h4><ul>
<li><strong>特点</strong>：<ul>
<li>使用 LZMA 算法，压缩率接近 <code>xz</code>。</li>
<li>支持分卷压缩、密码加密。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>高压缩率，功能丰富。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需额外工具（如 <code>p7zip</code>）。</li>
</ul>
</li>
<li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7z a archive.7z /path/to/files  <span class="comment"># 压缩</span></span><br><span class="line">7z x archive.7z                <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-如何选择合适的格式？"><a href="#3-如何选择合适的格式？" class="headerlink" title="3. 如何选择合适的格式？"></a><strong>3. 如何选择合适的格式？</strong></h2><table>
<thead>
<tr>
<th>格式</th>
<th>压缩率</th>
<th>速度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>TAR</code></td>
<td>❌ 无</td>
<td>⚡ 最快</td>
<td>仅需打包，不压缩（如备份）</td>
</tr>
<tr>
<td><code>TAR.GZ</code></td>
<td>⭐⭐</td>
<td>⏱️ 中等</td>
<td>通用（日志、代码分发）</td>
</tr>
<tr>
<td><code>TAR.XZ</code></td>
<td>⭐⭐⭐</td>
<td>🐢 最慢</td>
<td>高压缩需求（如发行版）</td>
</tr>
<tr>
<td><code>ZIP</code></td>
<td>⭐</td>
<td>⏱️ 中等</td>
<td>Windows 兼容/加密需求</td>
</tr>
<tr>
<td><code>7Z</code></td>
<td>⭐⭐⭐</td>
<td>🐢 慢</td>
<td>极限压缩/分卷压缩</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><ul>
<li><strong>仅打包</strong> → <code>TAR</code>  </li>
<li><strong>仅压缩</strong> → <code>GZ</code>/<code>BZ2</code>/<code>XZ</code>（需先打包）  </li>
<li><strong>打包+压缩</strong> → <code>TAR.GZ</code>（通用）、<code>TAR.XZ</code>（高压缩）、<code>ZIP</code>（跨平台）、<code>7Z</code>（极限压缩）  </li>
</ul>
<p><strong>推荐选择</strong>：</p>
<ul>
<li><strong>Linux 环境</strong>：<code>tar.gz</code>（平衡）、<code>tar.xz</code>（高压缩）  </li>
<li><strong>Windows 环境</strong>：<code>ZIP</code>（兼容性）、<code>7Z</code>（高压缩）  </li>
<li><strong>长期存储</strong>：<code>tar.xz</code> 或 <code>7z</code>  </li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>压缩</tag>
        <tag>归档</tag>
      </tags>
  </entry>
  <entry>
    <title>32位与64位的区别</title>
    <url>/2024/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="32位与64位的区别"><a href="#32位与64位的区别" class="headerlink" title="32位与64位的区别"></a>32位与64位的区别</h2><p>首先，我们需要了解计算机中的位数的概念。计算机中的位数指的是计算机中用于表示数据的最大二进制数。例如，32位计算机可以处理最大为2^32-1的整数，而64位计算机可以处理最大为2^64-1的整数。</p>
<p>接下来，我们来详细解释32位程序与64位程序的区别。</p>
<ol>
<li>程序的地址空间不同</li>
</ol>
<p>32位程序的地址空间为4GB，而64位程序的地址空间为16GB。这意味着32位程序可以访问的内存地址范围比64位程序要小得多。</p>
<ol start="2">
<li>程序的寻址能力不同</li>
</ol>
<p>32位程序的寻址能力为4GB，而64位程序的寻址能力为16GB。这意味着32位程序可以访问的内存地址范围比64位程序要小得多。</p>
<ol start="3">
<li>程序的寄存器不同</li>
</ol>
<p>32位程序使用32位寄存器，而64位程序使用64位寄存器。这意味着32位程序可以处理的数据范围比64位程序要小得多。</p>
<ol start="4">
<li>程序的指令集不同</li>
</ol>
<p>32位程序使用32位指令集，而64位程序使用64位指令集。这意味着32位程序可以执行的指令比64位程序要少得多。</p>
<ol start="5">
<li>程序的兼容性问题</li>
</ol>
<p>由于32位程序和64位程序的地址空间和寄存器不同，因此它们之间可能存在兼容性问题。例如，某些32位程序可能无法在64位计算机上运行，或者在运行时出现错误。</p>
<h2 id="两者之间的兼容"><a href="#两者之间的兼容" class="headerlink" title="两者之间的兼容"></a>两者之间的兼容</h2><ol>
<li>操作系统兼容性</li>
</ol>
<p>由于32位程序在64位计算机上运行时可能存在兼容性问题，因此需要操作系统提供兼容性支持。例如，Windows操作系统提供了兼容性模式，允许32位程序在64位计算机上运行。</p>
<ol start="2">
<li>程序兼容性</li>
</ol>
<p>某些32位程序可能已经针对64位计算机进行了优化，因此可以在64位计算机上运行。但是，这种兼容性可能并不完全，可能会导致程序在运行时出现错误。</p>
<ol start="3">
<li>硬件兼容性</li>
</ol>
<p>某些硬件设备可能仅支持32位程序，因此无法在64位计算机上运行。<br>32位程序可以在64位计算机上运行的原因是操作系统提供了兼容性支持，以及某些程序针对64位计算机进行了优化。但是，这种兼容性可能并不完全，可能会导致程序在运行时出现错误。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>VLLM-多机多卡推理部署</title>
    <url>/2025/03/23/LLM-%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E6%8E%A8%E7%90%86%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>本教程将指导如何在多机多卡环境中部署 vLLM 推理服务，以实现高效的分布式推理。假设你已经安装了 Docker 和下载好了模型文件，并且两台服务器的模型存放路径一致。</p>
<hr>
<h2 id="1-安装-NVIDIA-Container-Toolkit"><a href="#1-安装-NVIDIA-Container-Toolkit" class="headerlink" title="1. 安装 NVIDIA Container Toolkit"></a>1. 安装 NVIDIA Container Toolkit</h2><p>在开始之前，确保你的服务器已经安装了 <strong>NVIDIA Container Toolkit</strong>，以便 Docker 能够使用 GPU 资源。</p>
<h3 id="1-1-添加-NVIDIA-容器工具包仓库"><a href="#1-1-添加-NVIDIA-容器工具包仓库" class="headerlink" title="1.1 添加 NVIDIA 容器工具包仓库"></a>1.1 添加 NVIDIA 容器工具包仓库</h3><p>运行以下命令，添加 NVIDIA 容器工具包的官方仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://mirrors.ustc.edu.cn/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">sudo sed <span class="string">&#x27;s#deb https://nvidia.github.io#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://mirrors.ustc.edu.cn#g&#x27;</span> | \</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br></pre></td></tr></table></figure>

<p>如果还是无法下载建议手动下载后安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg /gpgkey路径</span><br><span class="line">curl -s -L https://mirrors.ustc.edu.cn/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">sudo sed <span class="string">&#x27;s#deb https://nvidia.github.io#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://mirrors.ustc.edu.cn#g&#x27;</span> | \</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>作用</strong>：添加 NVIDIA 容器工具包的 GPG 密钥和软件源，确保可以从官方仓库安装最新版本。</li>
</ul>
<h3 id="1-2-安装-NVIDIA-Container-Toolkit"><a href="#1-2-安装-NVIDIA-Container-Toolkit" class="headerlink" title="1.2 安装 NVIDIA Container Toolkit"></a>1.2 安装 NVIDIA Container Toolkit</h3><p>更新软件包列表并安装 NVIDIA Container Toolkit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y nvidia-docker2</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：安装 <code>nvidia-docker2</code> 包，重启 Docker 服务以加载 NVIDIA 驱动，使 Docker 容器能够使用 GPU 资源。</li>
</ul>
<hr>
<h2 id="2-下载-vLLM-集群启动脚本"><a href="#2-下载-vLLM-集群启动脚本" class="headerlink" title="2. 下载 vLLM 集群启动脚本"></a>2. 下载 vLLM 集群启动脚本</h2><p>运行以下命令，下载并准备 vLLM 集群启动脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/vllm-project/vllm/main/examples/online_serving/run_cluster.sh</span><br><span class="line"><span class="built_in">chmod</span> +x run_cluster.sh</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：下载 <code>run_cluster.sh</code> 脚本，用于启动 vLLM 集群。<code>chmod +x</code> 使脚本具有可执行权限。</li>
</ul>
<blockquote>
<p>注意，脚本当中的端口为 6379，这个端口跟redis数据库的端口是冲突的，如果你已经启用这个端口运行其他服务，你需要更改这个脚本当中的端口，主从节点都需要同步更改。</p>
</blockquote>
<hr>
<h2 id="3-启动-vLLM-集群"><a href="#3-启动-vLLM-集群" class="headerlink" title="3. 启动 vLLM 集群"></a>3. 启动 vLLM 集群</h2><h3 id="3-1-启动主节点（Head-Node）"><a href="#3-1-启动主节点（Head-Node）" class="headerlink" title="3.1 启动主节点（Head Node）"></a>3.1 启动主节点（Head Node）</h3><p>在主节点上运行以下命令启动集群的主节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash run_cluster.sh \</span><br><span class="line">docker.1ms.run/vllm/vllm-openai:latest \  <span class="comment"># 使用 vLLM 的 Docker 镜像</span></span><br><span class="line">192.168.xxx.xxx \                         <span class="comment"># 主节点的 IP 地址</span></span><br><span class="line">--<span class="built_in">head</span> \                                 <span class="comment"># 指定为主节点</span></span><br><span class="line">/data/model/qeternity/DeepSeek-R1-Distill-Qwen-32B-FP8 \  <span class="comment"># 模型路径</span></span><br><span class="line">-e VLLM_HOST_IP=192.168.xxx.xxx \         <span class="comment"># 设置主节点的 IP 地址</span></span><br><span class="line">-e GLOO_SOCKET_IFNAME=eno1 \             <span class="comment"># 指定集群通信的网卡接口</span></span><br><span class="line">-e NCCL_SOCKET_IFNAME=eno1               <span class="comment"># 指定 NCCL 通信的网卡接口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>--head</code>**：标记该节点为集群的主节点。</li>
<li>**<code>VLLM_HOST_IP</code>**：设置主节点的 IP 地址，用于集群通信。</li>
<li>**<code>GLOO_SOCKET_IFNAME</code> 和 <code>NCCL_SOCKET_IFNAME</code>**：指定集群通信使用的网卡接口名称（如 <code>eno1</code>），确保集群内部通信的正确性。</li>
</ul>
<p><strong>命令推荐后台运行或采用自动化脚本执行</strong></p>
<h3 id="3-2-启动从节点（Worker-Node）"><a href="#3-2-启动从节点（Worker-Node）" class="headerlink" title="3.2 启动从节点（Worker Node）"></a>3.2 启动从节点（Worker Node）</h3><p>在从节点上运行以下命令启动集群的从节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash run_cluster.sh \</span><br><span class="line">docker.1ms.run/vllm/vllm-openai:latest \  <span class="comment"># 使用 vLLM 的 Docker 镜像</span></span><br><span class="line">192.168.xxx.xxx \                         <span class="comment"># 主节点的 IP 地址</span></span><br><span class="line">--worker \                               <span class="comment"># 指定为从节点</span></span><br><span class="line">/data/model/qeternity/DeepSeek-R1-Distill-Qwen-32B-FP8 \  <span class="comment"># 模型路径</span></span><br><span class="line">-e VLLM_HOST_IP=192.168.xxx.xxx \          <span class="comment"># 设置从节点的 IP 地址</span></span><br><span class="line">-e GLOO_SOCKET_IFNAME=eno1 \             <span class="comment"># 指定集群通信的网卡接口</span></span><br><span class="line">-e NCCL_SOCKET_IFNAME=eno1               <span class="comment"># 指定 NCCL 通信的网卡接口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>--worker</code>**：标记该节点为集群的从节点。</li>
<li>**<code>VLLM_HOST_IP</code>**：设置从节点的 IP 地址，用于集群通信。</li>
<li>**<code>GLOO_SOCKET_IFNAME</code> 和 <code>NCCL_SOCKET_IFNAME</code>**：与主节点相同，指定集群通信使用的网卡接口名称。</li>
</ul>
<p><strong>命令推荐后台运行或采用自动化脚本执行</strong></p>
<hr>
<h2 id="4-启动推理服务"><a href="#4-启动推理服务" class="headerlink" title="4. 启动推理服务"></a>4. 启动推理服务</h2><p>在主节点的容器内启动 vLLM 推理服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vllm serve /root/.cache/huggingface \  <span class="comment"># 模型缓存路径</span></span><br><span class="line">--tokenizer /root/.cache/huggingface \  <span class="comment"># Tokenizer 路径</span></span><br><span class="line">--served-model-name llm \               <span class="comment"># 模型服务名称</span></span><br><span class="line">--port 9990 \                           <span class="comment"># 推理服务端口</span></span><br><span class="line">--gpu-memory-utilization 0.85 \         <span class="comment"># GPU 内存利用率（85%）</span></span><br><span class="line">--max-model-len=16384 \                 <span class="comment"># 最大模型长度</span></span><br><span class="line">--max-num-seqs 20 \                     <span class="comment"># 最大序列数</span></span><br><span class="line">--tensor-parallel-size 8 \              <span class="comment"># 张量并行大小</span></span><br><span class="line">--pipeline-parallel-size 2              <span class="comment"># 管道并行大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>--served-model-name</code>**：指定推理服务的名称，客户端通过此名称访问模型。</li>
<li>**<code>--port</code>**：指定推理服务的监听端口（如 <code>9990</code>）。</li>
<li>**<code>--gpu-memory-utilization</code>**：设置 GPU 内存利用率，避免 GPU 内存溢出。</li>
<li>**<code>--max-model-len</code>**：设置模型的最大输入长度。</li>
<li>**<code>--max-num-seqs</code>**：设置推理的最大序列数。</li>
<li>**<code>--tensor-parallel-size</code> 和 <code>--pipeline-parallel-size</code>**：指定分布式推理的并行策略，提升推理效率。</li>
</ul>
<hr>
<h2 id="5-验证集群状态"><a href="#5-验证集群状态" class="headerlink" title="5. 验证集群状态"></a>5. 验证集群状态</h2><p>在任意节点上进入容器并检查 Ray 集群状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it &lt;容器ID&gt; bash</span><br><span class="line">ray status</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：检查 Ray 集群的状态，确保主节点和从节点已正确连接。</li>
</ul>
<hr>
<h2 id="6-测试推理服务"><a href="#6-测试推理服务" class="headerlink" title="6. 测试推理服务"></a>6. 测试推理服务</h2><p>使用 <code>curl</code> 或其他工具测试推理服务是否正常运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;prompt&quot;: &quot;Hello, world!&quot;&#125;&#x27;</span> http://192.168.191.11:9990/v1/chat/completions</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：向推理服务发送测试请求，验证服务是否正常响应。</li>
</ul>
<p>如果返回合理的推理结果，说明部署成功。</p>
<hr>
<p>通过以上步骤，可以在多机多卡环境中成功部署 vLLM 推理服务。如果有任何问题，百度吧，剩下的我也没遇到过。</p>
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>VLLM</tag>
      </tags>
  </entry>
  <entry>
    <title>显存计算</title>
    <url>/2025/05/21/LLM-%E6%98%BE%E5%AD%98%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="了解大模型的显存占用"><a href="#了解大模型的显存占用" class="headerlink" title="了解大模型的显存占用"></a>了解大模型的显存占用</h2><p>在大型语言模型(LLM)领域，经常看到”7B”、”13B”、”70B”这样的参数规模描述，这些数字直接关系到模型运行所需的显存资源。对于开发者、研究人员和AI应用部署者来说，准确计算模型显存需求是：</p>
<ul>
<li>硬件采购的基础</li>
<li>部署方案设计的依据</li>
<li>模型选择的关键因素</li>
<li>性能优化的起点</li>
</ul>
<p>本文将系统性地解析大模型显存占用的计算方法，包括全精度加载和量化加载的不同场景。</p>
<h2 id="一、基础概念：模型参数与显存的关系"><a href="#一、基础概念：模型参数与显存的关系" class="headerlink" title="一、基础概念：模型参数与显存的关系"></a>一、基础概念：模型参数与显存的关系</h2><h3 id="1-1-参数量的表示方法"><a href="#1-1-参数量的表示方法" class="headerlink" title="1.1 参数量的表示方法"></a>1.1 参数量的表示方法</h3><ul>
<li><strong>1B参数</strong> = 10亿(1,000,000,000)个参数</li>
<li><strong>常见模型规模</strong>：<ul>
<li>7B (70亿，如Llama 2-7B)</li>
<li>13B (130亿，如Llama 2-13B)</li>
<li>70B (700亿，如Llama 2-70B)</li>
</ul>
</li>
</ul>
<h3 id="1-2-参数数据类型与显存占用"><a href="#1-2-参数数据类型与显存占用" class="headerlink" title="1.2 参数数据类型与显存占用"></a>1.2 参数数据类型与显存占用</h3><p>现代大模型通常使用以下数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>位数</th>
<th>字节数</th>
<th>常见用途</th>
</tr>
</thead>
<tbody><tr>
<td>FP32</td>
<td>32</td>
<td>4</td>
<td>全精度训练</td>
</tr>
<tr>
<td>FP16</td>
<td>16</td>
<td>2</td>
<td>混合精度训练/推理</td>
</tr>
<tr>
<td>BF16</td>
<td>16</td>
<td>2</td>
<td>训练(动态范围更大)</td>
</tr>
<tr>
<td>INT8</td>
<td>8</td>
<td>1</td>
<td>量化推理</td>
</tr>
<tr>
<td>INT4</td>
<td>4</td>
<td>0.5</td>
<td>极端量化</td>
</tr>
</tbody></table>
<h2 id="二、全量加载显存计算"><a href="#二、全量加载显存计算" class="headerlink" title="二、全量加载显存计算"></a>二、全量加载显存计算</h2><h3 id="2-1-基础计算公式"><a href="#2-1-基础计算公式" class="headerlink" title="2.1 基础计算公式"></a>2.1 基础计算公式</h3><p><strong>全量加载显存(字节) = 参数量 × 每个参数所占字节数</strong></p>
<p>举例：</p>
<ul>
<li>7B模型的FP32加载：7×10⁹ × 4 = 28GB</li>
<li>70B模型的FP16加载：70×10⁹ × 2 = 140GB</li>
</ul>
<h3 id="2-2-实际计算中的额外开销"><a href="#2-2-实际计算中的额外开销" class="headerlink" title="2.2 实际计算中的额外开销"></a>2.2 实际计算中的额外开销</h3><p>实际显存占用还需考虑：</p>
<ol>
<li><p><strong>优化器状态</strong>（训练时）：</p>
<ul>
<li>Adam优化器：每个参数需要额外8字节(2个FP32状态)</li>
<li>公式：参数量 × 12 (4参数+8优化器)</li>
</ul>
</li>
<li><p><strong>激活值</strong>（前向传播）：</p>
<ul>
<li>约占总显存的20-30%</li>
<li>与批次大小(batch size)和序列长度正相关</li>
</ul>
</li>
<li><p><strong>临时缓冲区</strong>：</p>
<ul>
<li>用于中间计算结果存储</li>
</ul>
</li>
</ol>
<h3 id="2-3-完整训练显存估算"><a href="#2-3-完整训练显存估算" class="headerlink" title="2.3 完整训练显存估算"></a>2.3 完整训练显存估算</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总显存 ≈ 参数量 × (参数字节 + 优化器字节) × 安全系数(1.2~1.3)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：训练7B模型的FP16混合精度训练：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7×10⁹ × (2 + 8) × 1.2 ≈ 84GB</span><br></pre></td></tr></table></figure>

<h2 id="三、量化加载显存计算"><a href="#三、量化加载显存计算" class="headerlink" title="三、量化加载显存计算"></a>三、量化加载显存计算</h2><h3 id="3-1-量化的基本原理"><a href="#3-1-量化的基本原理" class="headerlink" title="3.1 量化的基本原理"></a>3.1 量化的基本原理</h3><p>量化通过减少参数精度来降低显存需求：</p>
<ul>
<li><strong>权重量化</strong>：将FP32/FP16转换为低精度(INT8/INT4)</li>
<li><strong>激活量化</strong>：动态量化中间结果</li>
</ul>
<h3 id="3-2-常见量化方案"><a href="#3-2-常见量化方案" class="headerlink" title="3.2 常见量化方案"></a>3.2 常见量化方案</h3><table>
<thead>
<tr>
<th>量化类型</th>
<th>权重</th>
<th>激活值</th>
<th>显存减少</th>
<th>精度损失</th>
</tr>
</thead>
<tbody><tr>
<td>FP16</td>
<td>16位</td>
<td>16位</td>
<td>~50%</td>
<td>极小</td>
</tr>
<tr>
<td>INT8</td>
<td>8位</td>
<td>8位</td>
<td>~75%</td>
<td>较小</td>
</tr>
<tr>
<td>INT4</td>
<td>4位</td>
<td>8位</td>
<td>~87.5%</td>
<td>明显</td>
</tr>
<tr>
<td>GPTQ</td>
<td>混合</td>
<td>FP16</td>
<td>可配置</td>
<td>较小</td>
</tr>
</tbody></table>
<h3 id="3-3-量化显存计算公式"><a href="#3-3-量化显存计算公式" class="headerlink" title="3.3 量化显存计算公式"></a>3.3 量化显存计算公式</h3><p><strong>量化显存 = 参数量 × 量化后字节数 + 额外开销</strong></p>
<p><strong>示例</strong>：7B模型INT8量化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7×10⁹ × 1 = 7GB</span><br></pre></td></tr></table></figure>
<p>INT4量化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7×10⁹ × 0.5 = 3.5GB</span><br></pre></td></tr></table></figure>

<h3 id="3-4-实际工具中的量化实现"><a href="#3-4-实际工具中的量化实现" class="headerlink" title="3.4 实际工具中的量化实现"></a>3.4 实际工具中的量化实现</h3><p>现代推理框架提供了便捷的量化方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用bitsandbytes进行8位量化</span></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(</span><br><span class="line">    <span class="string">&quot;meta-llama/Llama-2-7b-hf&quot;</span>,</span><br><span class="line">    load_in_8bit=<span class="literal">True</span>,  <span class="comment"># 8位量化</span></span><br><span class="line">    device_map=<span class="string">&quot;auto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用4位量化</span></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(</span><br><span class="line">    <span class="string">&quot;meta-llama/Llama-2-7b-hf&quot;</span>,</span><br><span class="line">    load_in_4bit=<span class="literal">True</span>,  <span class="comment"># 4位量化</span></span><br><span class="line">    device_map=<span class="string">&quot;auto&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="四、实践指南：如何选择加载方式？"><a href="#四、实践指南：如何选择加载方式？" class="headerlink" title="四、实践指南：如何选择加载方式？"></a>四、实践指南：如何选择加载方式？</h2><h3 id="4-1-全量加载-vs-量化加载"><a href="#4-1-全量加载-vs-量化加载" class="headerlink" title="4.1 全量加载 vs 量化加载"></a>4.1 全量加载 vs 量化加载</h3><table>
<thead>
<tr>
<th>考量因素</th>
<th>全量加载</th>
<th>量化加载</th>
</tr>
</thead>
<tbody><tr>
<td>显存需求</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>计算速度</td>
<td>快(适合A100等)</td>
<td>可能稍慢</td>
</tr>
<tr>
<td>模型精度</td>
<td>最佳</td>
<td>略有下降</td>
</tr>
<tr>
<td>硬件要求</td>
<td>需要高端GPU</td>
<td>可在消费级GPU运行</td>
</tr>
<tr>
<td>适用场景</td>
<td>训练/高精度推理</td>
<td>资源受限的推理</td>
</tr>
</tbody></table>
<h3 id="4-2-硬件与模型规模的匹配参考"><a href="#4-2-硬件与模型规模的匹配参考" class="headerlink" title="4.2 硬件与模型规模的匹配参考"></a>4.2 硬件与模型规模的匹配参考</h3><table>
<thead>
<tr>
<th>模型规模</th>
<th>全FP16(GB)</th>
<th>INT8(GB)</th>
<th>INT4(GB)</th>
<th>推荐GPU</th>
</tr>
</thead>
<tbody><tr>
<td>7B</td>
<td>14</td>
<td>7</td>
<td>3.5</td>
<td>RTX 3090/4090</td>
</tr>
<tr>
<td>13B</td>
<td>26</td>
<td>13</td>
<td>6.5</td>
<td>A10G/A100 40GB</td>
</tr>
<tr>
<td>70B</td>
<td>140</td>
<td>70</td>
<td>35</td>
<td>A100 80GB×2</td>
</tr>
</tbody></table>
<h2 id="五、显存优化的其他技术"><a href="#五、显存优化的其他技术" class="headerlink" title="五、显存优化的其他技术"></a>五、显存优化的其他技术</h2><h3 id="5-1-模型并行"><a href="#5-1-模型并行" class="headerlink" title="5.1 模型并行"></a>5.1 模型并行</h3><ul>
<li><strong>Tensor并行</strong>：将模型层拆分到多个GPU</li>
<li><strong>Pipeline并行</strong>：按层划分到不同设备</li>
<li><strong>示例</strong>：Deepspeed的Zero优化</li>
</ul>
<h3 id="5-2-Flash-Attention"><a href="#5-2-Flash-Attention" class="headerlink" title="5.2 Flash Attention"></a>5.2 Flash Attention</h3><p>优化注意力机制的内存访问模式，可减少约20%显存占用</p>
<h3 id="5-3-梯度检查点"><a href="#5-3-梯度检查点" class="headerlink" title="5.3 梯度检查点"></a>5.3 梯度检查点</h3><p>用计算换显存，可减少约60%的激活值显存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用梯度检查点</span></span><br><span class="line">model.gradient_checkpointing_enable()</span><br></pre></td></tr></table></figure>

<h2 id="六、实用工具推荐"><a href="#六、实用工具推荐" class="headerlink" title="六、实用工具推荐"></a>六、实用工具推荐</h2><ol>
<li><p><strong>显存估算工具</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoConfig</span><br><span class="line"></span><br><span class="line">config = AutoConfig.from_pretrained(<span class="string">&quot;meta-llama/Llama-2-7b-hf&quot;</span>)</span><br><span class="line">params = <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;FP32显存需求: <span class="subst">&#123;params * <span class="number">4</span> / <span class="number">1024</span>**<span class="number">3</span>:<span class="number">.2</span>f&#125;</span>GB&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设备映射检查</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.hf_device_map)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>显存监控</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi -l 1  <span class="comment"># 实时监控显存使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h2><p>大模型部署始终是资源、精度和速度的平衡艺术。理解显存计算原理后，你可以：</p>
<ol>
<li>根据硬件条件选择合适模型</li>
<li>为特定任务选择最佳量化方案</li>
<li>设计高效的分布式推理方案</li>
<li>预判扩展需求，合理规划硬件</li>
</ol>
<p>记住，没有”最好”的加载方式，只有最适合你应用场景的选择。希望本文能成为你在大型语言模型部署路上的实用参考！</p>
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>LLN-训练与微调</title>
    <url>/2025/05/21/LLM-%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/</url>
    <content><![CDATA[<h2 id="为什么需要多种微调方法？"><a href="#为什么需要多种微调方法？" class="headerlink" title="为什么需要多种微调方法？"></a>为什么需要多种微调方法？</h2><p>在大模型应用落地的过程中，预训练后的微调(Fine-tuning)是使模型适应特定任务的关键环节。随着技术的发展，研究者们提出了从传统的监督微调(SFT)到基于人类反馈的强化学习(RHLF)，再到最新的直接偏好优化(DPO)等一系列方法。本文将系统解析6种主流微调技术的工作原理、适用场景及实践要点，根据具体需求选择最佳方案。</p>
<h2 id="一、基础方法：监督微调-SFT"><a href="#一、基础方法：监督微调-SFT" class="headerlink" title="一、基础方法：监督微调(SFT)"></a>一、基础方法：监督微调(SFT)</h2><h3 id="1-1-技术原理"><a href="#1-1-技术原理" class="headerlink" title="1.1 技术原理"></a>1.1 技术原理</h3><p>**监督微调(Supervised Fine-Tuning)**是最基础的微调方法，使用标注数据集通过标准交叉熵损失进行训练：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L_SFT = -Σ log P(y|x;θ)</span><br></pre></td></tr></table></figure>
<p>其中(x,y)是输入-输出对，θ是模型参数。</p>
<h3 id="1-2-典型流程"><a href="#1-2-典型流程" class="headerlink" title="1.2 典型流程"></a>1.2 典型流程</h3><ol>
<li>准备高质量标注数据</li>
<li>在预训练模型上继续训练</li>
<li>使用学习率衰减策略（如cosine衰减）</li>
</ol>
<h3 id="1-3-优缺点分析"><a href="#1-3-优缺点分析" class="headerlink" title="1.3 优缺点分析"></a>1.3 优缺点分析</h3><p><strong>优势</strong>：</p>
<ul>
<li>实现简单，计算成本低</li>
<li>对小规模数据适应良好</li>
<li>可复用传统NLP训练流程</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li>依赖大量标注数据</li>
<li>容易过拟合</li>
<li>无法学习复杂偏好</li>
</ul>
<p><strong>适用场景</strong>：任务明确、有充足标注数据的领域适应</p>
<h2 id="二、高效微调技术：参数高效微调-ReFT"><a href="#二、高效微调技术：参数高效微调-ReFT" class="headerlink" title="二、高效微调技术：参数高效微调(ReFT)"></a>二、高效微调技术：参数高效微调(ReFT)</h2><h3 id="2-1-核心思想"><a href="#2-1-核心思想" class="headerlink" title="2.1 核心思想"></a>2.1 核心思想</h3><p>**参数高效微调(Resource-efficient Fine-Tuning)**通过冻结大部分参数，仅更新少量新增参数来降低计算成本。主要变体：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表方法</th>
<th>参数更新量</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>适配器</td>
<td>Adapter</td>
<td>0.5-5%</td>
<td>插入小型全连接层</td>
</tr>
<tr>
<td>前缀调优</td>
<td>Prefix</td>
<td>0.1-3%</td>
<td>添加可训练前缀token</td>
</tr>
<tr>
<td>LoRA</td>
<td>LoRA</td>
<td>1-10%</td>
<td>低秩矩阵分解</td>
</tr>
<tr>
<td>部分解冻</td>
<td>BitFit</td>
<td>&lt;1%</td>
<td>仅调整偏置项</td>
</tr>
</tbody></table>
<h3 id="2-2-LoRA实现示例"><a href="#2-2-LoRA实现示例" class="headerlink" title="2.2 LoRA实现示例"></a>2.2 LoRA实现示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> LoraConfig, get_peft_model</span><br><span class="line"></span><br><span class="line">config = LoraConfig(</span><br><span class="line">    r=<span class="number">8</span>,  <span class="comment"># 低秩维度</span></span><br><span class="line">    lora_alpha=<span class="number">32</span>,</span><br><span class="line">    target_modules=[<span class="string">&quot;q_proj&quot;</span>, <span class="string">&quot;v_proj&quot;</span>],</span><br><span class="line">    lora_dropout=<span class="number">0.1</span>,</span><br><span class="line">    bias=<span class="string">&quot;none&quot;</span></span><br><span class="line">)</span><br><span class="line">model = get_peft_model(model, config)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-技术对比"><a href="#2-3-技术对比" class="headerlink" title="2.3 技术对比"></a>2.3 技术对比</h3><p><strong>计算效率</strong>：BitFit &gt; Adapter ≈ Prefix &gt; LoRA &gt; 全参数<br><strong>效果表现</strong>：LoRA ≈ 全参数 &gt; Adapter &gt; Prefix &gt; BitFit<br><strong>内存占用</strong>：全参数 &gt; LoRA &gt; Adapter &gt; Prefix &gt; BitFit</p>
<h2 id="三、基于人类反馈的强化学习-RHLF"><a href="#三、基于人类反馈的强化学习-RHLF" class="headerlink" title="三、基于人类反馈的强化学习(RHLF)"></a>三、基于人类反馈的强化学习(RHLF)</h2><h3 id="3-1-三阶段训练流程"><a href="#3-1-三阶段训练流程" class="headerlink" title="3.1 三阶段训练流程"></a>3.1 三阶段训练流程</h3><ol>
<li><strong>SFT阶段</strong>：基础监督微调</li>
<li><strong>奖励建模</strong>：训练奖励模型(RM)预测人类偏好</li>
<li><strong>RL微调</strong>：使用PPO算法优化策略</li>
</ol>
<h3 id="3-2-关键组件"><a href="#3-2-关键组件" class="headerlink" title="3.2 关键组件"></a>3.2 关键组件</h3><ul>
<li><strong>奖励模型</strong>：通常使用6B左右模型，输入为response，输出标量分数</li>
<li><strong>PPO算法</strong>：通过策略梯度优化，公式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L^CLIP(θ) = E[min(r(θ)A, clip(r(θ),1-ε,1+ε)A)]</span><br></pre></td></tr></table></figure>
其中r(θ)是新旧策略概率比，A是优势函数</li>
</ul>
<h3 id="3-3-挑战与解决方案"><a href="#3-3-挑战与解决方案" class="headerlink" title="3.3 挑战与解决方案"></a>3.3 挑战与解决方案</h3><table>
<thead>
<tr>
<th>挑战</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>奖励黑客(Reward Hacking)</td>
<td>KL惩罚项、多奖励模型集成</td>
</tr>
<tr>
<td>训练不稳定</td>
<td>梯度裁剪、自适应学习率</td>
</tr>
<tr>
<td>人类标注成本高</td>
<td>半自动标注、主动学习</td>
</tr>
</tbody></table>
<h2 id="四、新兴技术：直接偏好优化-DPO"><a href="#四、新兴技术：直接偏好优化-DPO" class="headerlink" title="四、新兴技术：直接偏好优化(DPO)"></a>四、新兴技术：直接偏好优化(DPO)</h2><h3 id="4-1-算法突破"><a href="#4-1-算法突破" class="headerlink" title="4.1 算法突破"></a>4.1 算法突破</h3><p>DPO(Direct Preference Optimization)去除了复杂的RL流程，将偏好学习转化为分类问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L_DPO = -log σ(β log πθ(y_w|x)/πref(y_w|x) - β log πθ(y_l|x)/πref(y_l|x))</span><br></pre></td></tr></table></figure>
<p>其中(y_w, y_l)是偏好对，πref是参考策略。</p>
<h3 id="4-2-相比RHLF的优势"><a href="#4-2-相比RHLF的优势" class="headerlink" title="4.2 相比RHLF的优势"></a>4.2 相比RHLF的优势</h3><ol>
<li><strong>训练稳定</strong>：不需要奖励模型</li>
<li><strong>计算高效</strong>：单阶段训练</li>
<li><strong>超参更少</strong>：主要调节温度系数β</li>
</ol>
<h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> trl <span class="keyword">import</span> DPOTrainer</span><br><span class="line"></span><br><span class="line">dpo_trainer = DPOTrainer(</span><br><span class="line">    model,</span><br><span class="line">    args=training_args,</span><br><span class="line">    beta=<span class="number">0.1</span>,</span><br><span class="line">    train_dataset=train_dataset,</span><br><span class="line">    tokenizer=tokenizer,</span><br><span class="line">)</span><br><span class="line">dpo_trainer.train()</span><br></pre></td></tr></table></figure>

<h2 id="五、自动化偏好学习：RLAIF"><a href="#五、自动化偏好学习：RLAIF" class="headerlink" title="五、自动化偏好学习：RLAIF"></a>五、自动化偏好学习：RLAIF</h2><h3 id="5-1-核心概念"><a href="#5-1-核心概念" class="headerlink" title="5.1 核心概念"></a>5.1 核心概念</h3><p>**RLAIF(Reinforcement Learning from AI Feedback)**使用大模型替代人类进行偏好标注：</p>
<ol>
<li>用LLM生成候选回答</li>
<li>相同LLM作为评判员进行评分</li>
<li>基于AI生成的偏好进行强化学习</li>
</ol>
<h3 id="5-2-实施步骤"><a href="#5-2-实施步骤" class="headerlink" title="5.2 实施步骤"></a>5.2 实施步骤</h3><ol>
<li>构建提示词模板：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;请比较以下两个回答，根据[标准]选择更好的一个：</span><br><span class="line">回答A: &#123;response_a&#125;</span><br><span class="line">回答B: &#123;response_b&#125;</span><br><span class="line">选择结果:&quot;</span><br></pre></td></tr></table></figure></li>
<li>使用温度采样(T=0.7)获得多样性评判</li>
<li>过滤低置信度样本</li>
</ol>
<h3 id="5-3-效果验证"><a href="#5-3-效果验证" class="headerlink" title="5.3 效果验证"></a>5.3 效果验证</h3><p>Anthropic研究显示：</p>
<ul>
<li>在无害性任务上，RLAIF达到RHLF 90%的效果</li>
<li>在有用性任务上，达到RHLF 70-80%的效果</li>
</ul>
<h2 id="六、技术全景对比与选型指南"><a href="#六、技术全景对比与选型指南" class="headerlink" title="六、技术全景对比与选型指南"></a>六、技术全景对比与选型指南</h2><h3 id="6-1-方法对比矩阵"><a href="#6-1-方法对比矩阵" class="headerlink" title="6.1 方法对比矩阵"></a>6.1 方法对比矩阵</h3><table>
<thead>
<tr>
<th>方法</th>
<th>数据需求</th>
<th>计算成本</th>
<th>效果潜力</th>
<th>实现难度</th>
<th>适用阶段</th>
</tr>
</thead>
<tbody><tr>
<td>SFT</td>
<td>标注输入-输出</td>
<td>低</td>
<td>中</td>
<td>易</td>
<td>初期领域适应</td>
</tr>
<tr>
<td>ReFT</td>
<td>标注输入-输出</td>
<td>很低</td>
<td>中</td>
<td>中</td>
<td>资源受限场景</td>
</tr>
<tr>
<td>RHLF</td>
<td>偏好对</td>
<td>极高</td>
<td>高</td>
<td>难</td>
<td>最终效果优化</td>
</tr>
<tr>
<td>DPO</td>
<td>偏好对</td>
<td>中</td>
<td>高</td>
<td>中</td>
<td>替代RHLF</td>
</tr>
<tr>
<td>RLAIF</td>
<td>无标注</td>
<td>高</td>
<td>中高</td>
<td>难</td>
<td>无人类数据时</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>训练</tag>
        <tag>微调</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM-长文本问题</title>
    <url>/2025/05/21/LLM-%E9%95%BF%E6%96%87%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着大语言模型(LLM)的广泛应用，处理超长文本输入已成为开发者面临的常见问题。当文本长度超过模型的上下文窗口限制（如GPT-4的32k token或Claude的100k token），或者即使长度未超限但内容过于复杂时，都需要特殊的处理策略。本文将分析现有解决方案，评估其适用场景，并介绍前沿的处理技术。(部分内容由大模型总结，请谨慎辨别)</p>
<h2 id="一、长文本处理的核心挑战"><a href="#一、长文本处理的核心挑战" class="headerlink" title="一、长文本处理的核心挑战"></a>一、长文本处理的核心挑战</h2><h3 id="1-技术限制"><a href="#1-技术限制" class="headerlink" title="1. 技术限制"></a>1. 技术限制</h3><ul>
<li><strong>上下文窗口限制</strong>：主流模型的token上限<pre class="mermaid">  graph LR
  A[模型类型] --> B[GPT-4-32k]
  A --> C[Claude-100k]
  A --> D[LLaMA2-4k]</pre></li>
<li><strong>注意力机制开销</strong>：Transformer的O(n²)复杂度</li>
<li><strong>信息衰减现象</strong>：模型对中间位置内容理解较弱</li>
</ul>
<h3 id="2-业务影响"><a href="#2-业务影响" class="headerlink" title="2. 业务影响"></a>2. 业务影响</h3><ul>
<li><strong>关键信息丢失</strong>：超出窗口部分被截断</li>
<li><strong>语义连贯性破坏</strong>：拆分导致上下文断裂</li>
<li><strong>推理质量下降</strong>：复杂论证难以维持</li>
</ul>
<h2 id="二、现有解决方案深度评估"><a href="#二、现有解决方案深度评估" class="headerlink" title="二、现有解决方案深度评估"></a>二、现有解决方案深度评估</h2><h3 id="1-检索增强生成-RAG"><a href="#1-检索增强生成-RAG" class="headerlink" title="1. 检索增强生成(RAG)"></a>1. 检索增强生成(RAG)</h3><p><strong>技术实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rag_pipeline</span>(<span class="params">long_text, query</span>):</span><br><span class="line">    <span class="comment"># 文本分块</span></span><br><span class="line">    text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">1000</span>)</span><br><span class="line">    chunks = text_splitter.split_text(long_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建向量库</span></span><br><span class="line">    embeddings = OpenAIEmbeddings()</span><br><span class="line">    vectorstore = Chroma.from_texts(chunks, embeddings)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 相关性检索</span></span><br><span class="line">    relevant_docs = vectorstore.similarity_search(query, k=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> generate_answer(query, relevant_docs)</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>文档问答系统</li>
<li>知识库查询</li>
<li>需要精确引用源材料的场景</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>突破上下文长度限制</li>
<li>可追溯信息来源</li>
<li>支持动态知识更新</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li>依赖检索质量</li>
<li>不适用于需要全局理解的复杂推理</li>
</ul>
<h3 id="2-历史对话分块处理"><a href="#2-历史对话分块处理" class="headerlink" title="2. 历史对话分块处理"></a>2. 历史对话分块处理</h3><p><strong>技术实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConversationManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, window_size=<span class="number">4000</span></span>):</span><br><span class="line">        self.memory = []</span><br><span class="line">        self.window = window_size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_message</span>(<span class="params">self, text</span>):</span><br><span class="line">        self.memory.append(text)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.tokenize(<span class="string">&#x27;\n&#x27;</span>.join(self.memory))) &gt; self.window:</span><br><span class="line">            self.memory.pop(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_context</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(self.memory[-<span class="number">5</span>:])  <span class="comment"># 保留最近5轮对话</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>多轮对话系统</li>
<li>渐进式信息收集</li>
<li>需要维持对话连贯性的场景</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>保持对话状态</li>
<li>自然的信息分段</li>
<li>低实现复杂度</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li>早期信息可能丢失</li>
<li>不适用于单次长文本处理</li>
</ul>
<h3 id="3-多模型协同处理"><a href="#3-多模型协同处理" class="headerlink" title="3. 多模型协同处理"></a>3. 多模型协同处理</h3><p><strong>架构设计</strong>：</p>
<pre class="mermaid">  graph TB
    Input[长文本输入] --> Splitter[文本分割]
    Splitter --> Model1[模型1处理段1]
    Splitter --> Model2[模型2处理段2]
    Splitter --> Model3[模型3处理段3]
    Model1 --> Aggregator[结果聚合]
    Model2 --> Aggregator
    Model3 --> Aggregator
    Aggregator --> Output[最终输出]</pre>

<p><strong>适用场景</strong>：</p>
<ul>
<li>可并行处理的独立子任务</li>
<li>时效性要求高的批量处理</li>
<li>需要冗余验证的关键决策</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>处理速度更快</li>
<li>可利用不同模型优势</li>
<li>结果可交叉验证</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li>协调成本高</li>
<li>聚合算法复杂</li>
<li>资源消耗大</li>
</ul>
<h3 id="4-迭代式文本压缩"><a href="#4-迭代式文本压缩" class="headerlink" title="4. 迭代式文本压缩"></a>4. 迭代式文本压缩</h3><p><strong>压缩算法示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iterative_compress</span>(<span class="params">text, target_length, model</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(tokenizer.encode(text)) &gt; target_length:</span><br><span class="line">        chunks = split_text(text)</span><br><span class="line">        compressed = []</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">            prompt = <span class="string">f&quot;用30%的篇幅总结下文，保留关键数据和结论：\n<span class="subst">&#123;chunk&#125;</span>&quot;</span></span><br><span class="line">            compressed.append(model.generate(prompt))</span><br><span class="line">        text = <span class="string">&#x27;\n&#x27;</span>.join(compressed)</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>学术论文分析</li>
<li>长篇报告处理</li>
<li>需要保持原文结构的场景</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>保留核心内容</li>
<li>可控制信息密度</li>
<li>适用于单文档分析</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li>多次调用成本高</li>
<li>存在信息损失风险</li>
<li>压缩比难以精确控制</li>
</ul>
<h2 id="三、其他看到的解决方案与技术前沿"><a href="#三、其他看到的解决方案与技术前沿" class="headerlink" title="三、其他看到的解决方案与技术前沿"></a>三、其他看到的解决方案与技术前沿</h2><h3 id="1-层次化注意力机制"><a href="#1-层次化注意力机制" class="headerlink" title="1. 层次化注意力机制"></a>1. 层次化注意力机制</h3><p><strong>架构原理</strong>：</p>
<ol>
<li>第一层：将文档分为若干段，生成段级表示</li>
<li>第二层：基于段表示构建文档级注意力</li>
<li>第三层：在关键段落内部进行token级注意力</li>
</ol>
<p><strong>实现框架</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HierarchicalAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, encoder</span>):</span><br><span class="line">        self.segment_encoder = encoder</span><br><span class="line">        self.document_attn = nn.MultiheadAttention()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, document</span>):</span><br><span class="line">        segments = split_document(document)</span><br><span class="line">        seg_embeddings = [self.segment_encoder(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments]</span><br><span class="line">        doc_embedding = self.document_attn(seg_embeddings)</span><br><span class="line">        <span class="keyword">return</span> doc_embedding</span><br></pre></td></tr></table></figure>

<h3 id="2-记忆增强架构"><a href="#2-记忆增强架构" class="headerlink" title="2. 记忆增强架构"></a>2. 记忆增强架构</h3><p><strong>关键技术</strong>：</p>
<ul>
<li><strong>外部记忆库</strong>：存储历史信息的关键向量</li>
<li><strong>动态记忆更新</strong>：基于相关性分数更新记忆</li>
<li><strong>记忆检索</strong>：使用当前查询检索相关记忆</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li>将长文本处理为记忆片段</li>
<li>建立可持久化的记忆存储</li>
<li>查询时检索相关记忆片段</li>
<li>将记忆与当前输入组合</li>
</ol>
<h3 id="3-递归式处理"><a href="#3-递归式处理" class="headerlink" title="3. 递归式处理"></a>3. 递归式处理</h3><p><strong>算法伪代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function process_long_text(text, model, max_length):</span><br><span class="line">    if length(text) &lt;= max_length:</span><br><span class="line">        return model.process(text)</span><br><span class="line">    else:</span><br><span class="line">        first_half, second_half = split_text(text)</span><br><span class="line">        summary1 = process_long_text(first_half, model, max_length)</span><br><span class="line">        summary2 = process_long_text(second_half, model, max_length)</span><br><span class="line">        return model.process(summary1 + summary2)</span><br></pre></td></tr></table></figure>

<h3 id="4-稀疏注意力优化"><a href="#4-稀疏注意力优化" class="headerlink" title="4. 稀疏注意力优化"></a>4. 稀疏注意力优化</h3><p><strong>创新方法</strong>：</p>
<ul>
<li><strong>块稀疏注意力</strong>：将注意力计算限制在局部窗口</li>
<li><strong>随机注意力</strong>：随机选择部分位置计算注意力</li>
<li><strong>LSH注意力</strong>：使用局部敏感哈希分组相似token</li>
</ul>
<h2 id="四、解决方案选择矩阵"><a href="#四、解决方案选择矩阵" class="headerlink" title="四、解决方案选择矩阵"></a>四、解决方案选择矩阵</h2><table>
<thead>
<tr>
<th>方案</th>
<th>适用文本长度</th>
<th>处理速度</th>
<th>信息保留</th>
<th>实现难度</th>
<th>成本</th>
</tr>
</thead>
<tbody><tr>
<td>RAG</td>
<td>任意</td>
<td>中</td>
<td>高★</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>历史分块</td>
<td>&lt;10倍窗口</td>
<td>快</td>
<td>低</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>多模型协同</td>
<td>任意</td>
<td>慢</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>迭代压缩</td>
<td>2-5倍窗口</td>
<td>慢</td>
<td>中</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>层次化注意力</td>
<td>5-20倍窗口</td>
<td>中</td>
<td>高★</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>记忆增强</td>
<td>任意</td>
<td>中</td>
<td>高</td>
<td>高</td>
<td>中</td>
</tr>
</tbody></table>
<p>（★表示可通过精确检索保留原文信息）</p>
<h2 id="五、场景化建议"><a href="#五、场景化建议" class="headerlink" title="五、场景化建议"></a>五、场景化建议</h2><h3 id="1-法律合同分析"><a href="#1-法律合同分析" class="headerlink" title="1. 法律合同分析"></a>1. 法律合同分析</h3><ul>
<li><strong>推荐方案</strong>：RAG + 层次化注意力</li>
<li><strong>原因</strong>：需要精确引用条款，同时保持整体理解</li>
<li><strong>实现提示</strong>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 法律条款的特殊分块策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LegalTextSplitter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="comment"># 按条款编号分割</span></span><br><span class="line">        <span class="keyword">return</span> re.split(<span class="string">r&#x27;\nArticle [IVXLCDM]+&#x27;</span>, text)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-学术论文阅读"><a href="#2-学术论文阅读" class="headerlink" title="2. 学术论文阅读"></a>2. 学术论文阅读</h3><ul>
<li><strong>推荐方案</strong>：迭代式压缩 + 结构化提示</li>
<li><strong>模板示例</strong>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请按照以下结构总结：</span><br><span class="line">[研究问题]:...</span><br><span class="line">[方法创新]:...</span><br><span class="line">[关键发现]:...</span><br><span class="line">[局限]:...</span><br><span class="line">原文内容：&#123;chunk&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-客户服务对话"><a href="#3-客户服务对话" class="headerlink" title="3. 客户服务对话"></a>3. 客户服务对话</h3><ul>
<li><strong>推荐方案</strong>：历史对话管理 + 关键信息提取</li>
<li><strong>优化技巧</strong>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_entities</span>(<span class="params">dialog</span>):</span><br><span class="line">    <span class="comment"># 提取时间、产品型号等关键信息单独存储</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;products&#x27;</span>: detect_products(dialog),</span><br><span class="line">        <span class="string">&#x27;issues&#x27;</span>: classify_issues(dialog)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>处理长文本输入没有放之四海而皆准的解决方案，需要根据具体场景选择合适策略。建议的决策流程：</p>
<ol>
<li><strong>评估文本特性</strong>：是单一文档还是对话？需要全局理解还是局部检索？</li>
<li><strong>明确需求优先级</strong>：准确性、响应速度、成本哪个最关键？</li>
<li><strong>原型测试</strong>：对候选方案进行小规模验证</li>
<li><strong>监控优化</strong>：在生产环境中持续跟踪效果</li>
</ol>
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>大模型</tag>
        <tag>LLM</tag>
        <tag>长文本</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的df命令概述</title>
    <url>/2024/03/25/Linux-df%E5%91%BD%E4%BB%A4%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="命令概述"><a href="#命令概述" class="headerlink" title="命令概述"></a>命令概述</h2><p><code>df</code>命令的英文全称即“Disk Free”，用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“<code>df -h</code>”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读，日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。</p>
<h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><p><code>df</code>【选项】 【参数】 </p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li><code>-a</code>或<code>--all</code>:显示所有的文件系统，包括虚拟文件系统</li>
<li><code>-B</code>:<code>--block-size=&lt;区块大小&gt;</code> 以指定的区块大小来显示区块数目；</li>
<li><code>-h</code>或<code>--human-readable</code>:以可读性较高的方式来显示信息；</li>
<li><code>-H</code>或<code>--si</code>:与<code>-h</code>参数相同，但在计算时是以<code>1000 Bytes</code>为换算单位而非1024 Bytes；</li>
<li><code>-i</code>或<code>--inodes</code>:显示inode的信息；</li>
<li><code>-l</code>或<code>--local</code>:仅显示本地端的文件系统；</li>
<li><code>-k</code>或<code>--kilobytes</code>:指定区块大小为1024字节，相当于<code>--block-size=1k</code></li>
<li><code>-m</code>或<code>--megabytes</code>:指定区块大小为1048576字节，相当于<code>--block-size=1M</code></li>
<li><code>--sync</code>:在取得磁盘使用信息前，先执行sync指令；</li>
<li><code>--no-sync</code>:在取得磁盘使用信息前，不要执行sync指令，此为预设值；</li>
<li><code>-P</code>或<code>--portability</code>:使用POSIX的输出格式；</li>
<li><code>-t &lt;文件系统类型&gt;</code>或<code>--type=&lt;文件系统类型&gt;</code>:仅显示指定文件系统类型的磁盘信息；</li>
<li><code>-T</code>或<code>--print-type</code>:显示文件系统的类型；</li>
<li><code>-x &lt;文件系统类型&gt;</code>或<code>--exclude-type=&lt;文件系统类型&gt;</code>:不要显示指定文件系统类型的磁盘信息；</li>
</ul>
<h2 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h2><h3 id="查看包含指定文件磁盘空间使用情况"><a href="#查看包含指定文件磁盘空间使用情况" class="headerlink" title="查看包含指定文件磁盘空间使用情况:"></a>查看包含指定文件磁盘空间使用情况:</h3><figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@lzg ~]<span class="comment"># df /home/    #指定一个文件夹，查看该文件夹所在磁盘的使用情况</span></span><br><span class="line">Filesystem     1K-blocks  Used Available Use% Mounted on</span><br><span class="line">/dev/sda2      414110148 33064 414077084   1% /home</span><br><span class="line">[root@lzg ~]<span class="comment"># df /root/test.txt    #指定一个文件</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda5      104806400 1692812 103113588   2% /</span><br><span class="line">[root@lzg ~]<span class="comment"># df /root/text.txt /home/    #指定多个文件或文件夹</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda5      104806400 1692812 103113588   2% /</span><br><span class="line">/dev/sda2      414110148   33064 414077084   1% /home</span><br><span class="line">[root@lzg ~]<span class="comment"># df /root/ /home/ /etc/      #指定多个文件或文件夹</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda5      104806400 1692812 103113588   2% /</span><br><span class="line">/dev/sda2      414110148   33064 414077084   1% /home</span><br><span class="line">/dev/sda5      104806400 1692812 103113588   2% /</span><br><span class="line">[root@lzg ~]<span class="comment"># df                  #默认情况</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs         2013532       0   2013532   0% /dev</span><br><span class="line">tmpfs            2023336       0   2023336   0% /dev/shm</span><br><span class="line">tmpfs            2023336   25180   1998156   2% /run</span><br></pre></td></tr></table></figure>


<p>输出结果列说明:</p>
<ul>
<li><code>Filesystem</code>:代表该文件系统是哪个分区，所以列出的是设备名称。</li>
<li><code>1K-blocks</code>:说明下面的数字单位是1KB，可利用-h或-m来改变单位大小，也可以用-B来设置。</li>
<li><code>Used</code>:已经使用的空间大小。</li>
<li><code>Available</code>:剩余的空间大小。</li>
<li><code>Use%</code>:磁盘使用率。如果使用率在90%以上时，就需要注意了，避免磁盘容量不足出现系统问题，尤其是对于文件内容增加较快的情况(如/home、/var/spool/mail等)。</li>
<li><code>Mounted on</code>:磁盘挂载的目录，即该磁盘挂载到了哪个目录下面。</li>
</ul>
<h3 id="a查看所有文件系统"><a href="#a查看所有文件系统" class="headerlink" title="-a查看所有文件系统:"></a>-a查看所有文件系统:</h3><figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@lzg ~]<span class="comment"># df -a</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">sysfs                  0       0         0    - /sys</span><br><span class="line">proc                   0       0         0    - /proc</span><br><span class="line">devtmpfs         2013532       0   2013532   0% /dev</span><br><span class="line">securityfs             0       0         0    - /sys/kernel/security</span><br><span class="line">tmpfs            2023336       0   2023336   0% /dev/shm</span><br><span class="line">devpts                 0       0         0    - /dev/pts</span><br><span class="line">tmpfs            2023336   25180   1998156   2% /run</span><br><span class="line">tmpfs            2023336       0   2023336   0% /sys/fs/cgroup</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/systemd</span><br><span class="line">pstore                 0       0         0    - /sys/fs/pstore</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/blkio</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/hugetlb</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/devices</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/cpuset</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/perf_event</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/freezer</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/net_cls,net_prio</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/pids</span><br><span class="line">cgroup                 0       0         0    - /sys/fs/cgroup/memory</span><br><span class="line">configfs               0       0         0    - /sys/kernel/config</span><br><span class="line">/dev/sda5      104806400 1692308 103114092   2% /</span><br><span class="line">selinuxfs              0       0         0    - /sys/fs/selinux</span><br><span class="line">debugfs                0       0         0    - /sys/kernel/debug</span><br><span class="line">mqueue                 0       0         0    - /dev/mqueue</span><br><span class="line">hugetlbfs              0       0         0    - /dev/hugepages</span><br><span class="line">/dev/sda2      414110148   33064 414077084   1% /home</span><br><span class="line">/dev/sda1        1038336  150724    887612  15% /boot</span><br><span class="line">systemd-1              -       -         -    - /proc/sys/fs/binfmt_misc</span><br><span class="line">binfmt_misc            0       0         0    - /proc/sys/fs/binfmt_misc</span><br><span class="line">tmpfs            2023336       4   2023332   1% /tmp</span><br><span class="line">tmpfs             404668       0    404668   0% /run/user/0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明:系统里面存在很多特殊的文件系统，这些比较特殊的文件系统几乎都是在内存当中，（如/proc挂载点），所以，这些特殊文件系统都不会占据硬盘空间。</p>
</blockquote>
<h3 id="指定单位大小显示"><a href="#指定单位大小显示" class="headerlink" title="指定单位大小显示:"></a>指定单位大小显示:</h3><figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@lzg ~]<span class="comment"># df -B 1k            #1k为单位</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs         2013532       0   2013532   0% /dev</span><br><span class="line">tmpfs            2023336       0   2023336   0% /dev/shm</span><br><span class="line">tmpfs            2023336   25180   1998156   2% /run</span><br><span class="line">tmpfs            2023336       0   2023336   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda5      104806400 1692308 103114092   2% /</span><br><span class="line">/dev/sda2      414110148   33064 414077084   1% /home</span><br><span class="line">/dev/sda1        1038336  150724    887612  15% /boot</span><br><span class="line">tmpfs            2023336       4   2023332   1% /tmp</span><br><span class="line">tmpfs             404668       0    404668   0% /run/user/0</span><br><span class="line">[root@lzg ~]<span class="comment"># df --block-size 1m   #1M为单位</span></span><br><span class="line">Filesystem     1M-blocks  Used Available Use% Mounted on</span><br><span class="line">devtmpfs            1967     0      1967   0% /dev</span><br><span class="line">tmpfs               1976     0      1976   0% /dev/shm</span><br><span class="line">tmpfs               1976    25      1952   2% /run</span><br><span class="line">tmpfs               1976     0      1976   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda5         102350  1653    100698   2% /</span><br><span class="line">/dev/sda2         404405    33    404373   1% /home</span><br><span class="line">/dev/sda1           1014   148       867  15% /boot</span><br><span class="line">tmpfs               1976     1      1976   1% /tmp</span><br><span class="line">tmpfs                396     0       396   0% /run/user/0</span><br></pre></td></tr></table></figure>

<h3 id="h-以易读的方式显示"><a href="#h-以易读的方式显示" class="headerlink" title="-h 以易读的方式显示:"></a><code>-h</code> 以易读的方式显示:</h3><figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@lzg ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        2.0G     0  2.0G   0% /dev</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs           2.0G   25M  2.0G   2% /run</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda5       100G  1.7G   99G   2% /</span><br><span class="line">/dev/sda2       395G   33M  395G   1% /home</span><br><span class="line">/dev/sda1      1014M  148M  867M  15% /boot</span><br><span class="line">tmpfs           2.0G  4.0K  2.0G   1% /tmp</span><br><span class="line">tmpfs           396M     0  396M   0% /run/user/0</span><br></pre></td></tr></table></figure>

<h3 id="以inode的数量显示"><a href="#以inode的数量显示" class="headerlink" title="以inode的数量显示:"></a>以<code>inode</code>的数量显示:</h3><figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@lzg ~]<span class="comment"># df -i</span></span><br><span class="line">Filesystem        Inodes IUsed     IFree IUse% Mounted on</span><br><span class="line">devtmpfs          503383   376    503007    1% /dev</span><br><span class="line">tmpfs             505834     1    505833    1% /dev/shm</span><br><span class="line">tmpfs             505834   475    505359    1% /run</span><br><span class="line">tmpfs             505834    16    505818    1% /sys/fs/cgroup</span><br><span class="line">/dev/sda5       52428800 36206  52392594    1% /</span><br><span class="line">/dev/sda2      207156224    23 207156201    1% /home</span><br><span class="line">/dev/sda1         524288   334    523954    1% /boot</span><br><span class="line">tmpfs             505834     2    505832    1% /tmp</span><br><span class="line">tmpfs             505834     1    505833    1% /run/user/0</span><br></pre></td></tr></table></figure>

<h3 id="T-显示出每个文件系统的类型"><a href="#T-显示出每个文件系统的类型" class="headerlink" title="-T 显示出每个文件系统的类型:"></a><code>-T</code> 显示出每个文件系统的类型:</h3><figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@lzg ~]<span class="comment"># df -T</span></span><br><span class="line">Filesystem     Type     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs       devtmpfs   2013532       0   2013532   0% /dev</span><br><span class="line">tmpfs          tmpfs      2023336       0   2023336   0% /dev/shm</span><br><span class="line">tmpfs          tmpfs      2023336   25180   1998156   2% /run</span><br><span class="line">tmpfs          tmpfs      2023336       0   2023336   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda5      xfs      104806400 1692308 103114092   2% /</span><br><span class="line">/dev/sda2      xfs      414110148   33064 414077084   1% /home</span><br><span class="line">/dev/sda1      xfs        1038336  150724    887612  15% /boot</span><br><span class="line">tmpfs          tmpfs      2023336       4   2023332   1% /tmp</span><br><span class="line">tmpfs          tmpfs       404668       0    404668   0% /run/user/0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Too many open files 解决办法</title>
    <url>/2023/02/21/Linux-%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E8%BF%87%E5%A4%9A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>近期使用Linux操作系统的时候用到了多进程，导致同一时间内文件打开数量超过限制，从而导致进程卡死问题，在网上找到了以下解决方法</p>
<h2 id="单个进程打开文件句柄数过多"><a href="#单个进程打开文件句柄数过多" class="headerlink" title="单个进程打开文件句柄数过多"></a>单个进程打开文件句柄数过多</h2><p><code>ulimit</code>中的<code>nofile</code>表示单进程可以打开的最大文件句柄数，可以通过<code>ulimit -a</code>查看，子进程默认继承父进程的限制（注意，是继承，不是共享，子进程和父进程打开的文件句柄数是单独算的）。<br>网上还有一种解读是<code>nofile</code>表示单用户可以打开的文件句柄数，因为他们在<code>limit.conf</code>中看到类似于<code>openstack soft nofile 65536</code>，便认为是<code>openstack</code>用户最多可以打开的文件句柄数。该解读是错误的，<code>openstack soft nofile 65536</code>表示的含义是当你执行<code>su - openstack</code>切换到<code>openstack</code>用户后，你创建的所有进程最大可以打开的文件句柄数是<code>65536</code>。<br>要查看一个进程可以打开的文件句柄数，可以通过<code>cat /proc/&lt;pid&gt;/limits</code>查看。</p>
<p>要修改<code>ulimit</code>中的<code>nofile</code>，可以通过修改<code>/etc/security/limits.conf</code>文件，在其中加入类似<code>openstack soft nofile 65536</code>的语句来进行修改。修改完成后，可以通过<code>su - openstack</code>切换用户，或者重新登录，来使该配置生效。</p>
<p>要动态修改一个进程的限制，可以使用<code>prlimit</code>命令，具体用法为：<code>prlimit --pid $&#123;pid&#125; --nofile=102400:102400</code>。</p>
<h2 id="操作系统打开的文件句柄数过多"><a href="#操作系统打开的文件句柄数过多" class="headerlink" title="操作系统打开的文件句柄数过多"></a>操作系统打开的文件句柄数过多</h2><p>整个操作系统可以打开的文件句柄数是有限的，受内核参数<code>fs.file-max</code>影响。<br>可以通过执行<code>echo 100000000 &gt; /proc/sys/fs/file-max</code>命令来动态修改该值，也可以通过修改<code>/etc/sysctl.conf</code>文件来永久修改该值。</p>
<h2 id="systemd对该进程进行了限制、"><a href="#systemd对该进程进行了限制、" class="headerlink" title="systemd对该进程进行了限制、"></a><code>systemd</code>对该进程进行了限制、</h2><p>该场景仅针对被<code>systemd</code>管理的进程（也就是可以通过<code>systemctl</code>来控制的进程）生效，可以通过修改该进程的<code>service</code>文件（通常在<code>/etc/systemd/system/</code>目录下），在<code>[Service]</code>下面添加<code>LimitNOFILE=20480000</code>来实现，修改完成之后需要执行<code>systemctl daemon-reload</code>来使该配置生效。</p>
<h2 id="inotify达到上限"><a href="#inotify达到上限" class="headerlink" title="inotify达到上限"></a><code>inotify</code>达到上限</h2><p><code>inotify</code>是<code>linux</code>提供的一种监控机制，可以监控文件系统的变化。该机制受到2个内核参数的影响：<code>fs.inotify.max_user_instances</code>和<code>fs.inotify.max_user_watches</code>，其中<code>fs.inotify.max_user_instances</code>表示每个用户最多可以创建的<code>inotify instances</code>数量上限，<code>fs.inotify.max_user_watches</code>表示么个用户同时可以添加的<code>watch</code>数目，当出现<code>too many open files</code>问题而上面三种方法都无法解决时，可以尝试通过修改这2个内核参数来生效。修改方法是修改<code>/etc/sysctl.conf</code>文件，并执行<code>sysctl -p</code>。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>top命令基础</title>
    <url>/2022/08/18/Linux-top%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>top命令是Linux下常用的性能分析工具,能够实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。top命令展示的信息众多，初学者可能不能够快速掌握所有信息概况，以下对top命令基础进行简单讲解。</p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>在使用了top命令后会出现以下数据样式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 01:05:24 up 9 min,  0 <span class="built_in">users</span>,  load average: 0.00, 0.04, 0.05</span><br><span class="line">Tasks: 138 total,   1 running, 137 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.1 us,  0.3 sy,  0.0 ni, 99.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  7990064 total,  7001532 free,   698000 used,   290532 buff/cache</span><br><span class="line">KiB Swap:  8257532 total,  8257532 free,        0 used.  7043352 avail Mem </span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                                                   </span><br><span class="line">  1620 root      20   0  699732  38824  15664 S   0.7  0.5   0:02.71 node                                                                                                                                                      </span><br><span class="line">  1655 root      20   0 1023288 124372  21240 S   0.7  1.6   0:05.07 node                                                                                                                                                      </span><br><span class="line">  1398 root      20   0  157084   6040   4352 S   0.3  0.1   0:00.33 sshd                                                                                                                                                      </span><br><span class="line">  1474 root      20   0  954828  60136  18520 S   0.3  0.8   0:02.79 node                                                                                                                                                      </span><br><span class="line">     1 root      20   0  193704   6772   4140 S   0.0  0.1   0:00.95 systemd                                                                                                                                                   </span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd                                                                                                                                                  </span><br><span class="line">     3 root      20   0       0      0      0 S   0.0  0.0   0:00.06 kworker/0:0                                                                                                                                               </span><br><span class="line">     4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H                                                                                                                                              </span><br><span class="line">     6 root      20   0       0      0      0 S   0.0  0.0   0:00.01 ksoftirqd/0                                                                                                                                               </span><br><span class="line">     7 root      rt   0       0      0      0 S   0.0  0.0   0:00.02 migration/0  </span><br></pre></td></tr></table></figure>

<h3 id="系统概况"><a href="#系统概况" class="headerlink" title="系统概况"></a>系统概况</h3><p>首先是第一行，内容是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 01:05:24 up 9 min,  0 <span class="built_in">users</span>,  load average: 0.00, 0.04, 0.05</span><br></pre></td></tr></table></figure>

<p>内容分别是：</p>
<ul>
<li><code>top</code> : 名称</li>
<li><code>01:05:24</code> ： 系统当前时间</li>
<li><code>up 9 min</code> ： 用户登录时间</li>
<li><code>0 users</code> ： 当前登录用户数量</li>
<li><code>load average: 0.00, 0.04, 0.05</code> ： 系统负载 一分钟/五分钟/十五分钟 三个时间段的统计</li>
</ul>
<blockquote>
<p>注意 ： 对于单CPU的机器而言，1.00已经是满负载了</p>
</blockquote>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>然后是第二行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Tasks: 138 total,   1 running, 137 sleeping,   0 stopped,   0 zombie</span><br></pre></td></tr></table></figure>

<p>内容分别是：</p>
<ul>
<li><code>Tasks: 138 total</code> : 进程任务总数138个</li>
<li><code>1 running</code> : 运行进程1个</li>
<li><code>137 sleeping</code> : 137个进程正在睡眠状态</li>
<li><code>0 stopped</code> : 停止进程0个</li>
<li><code>0 zombie</code> : 僵尸进程0个</li>
</ul>
<h3 id="CPU-状态"><a href="#CPU-状态" class="headerlink" title="CPU 状态"></a>CPU 状态</h3><p>接着第三行： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%Cpu(s):  0.1 us,  0.3 sy,  0.0 ni, 99.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0.1 us</code> : 用户空间</li>
<li><code>0.3 sy</code> : 内核空间</li>
<li><code>0.0 ni</code> : 用户定义优先级</li>
<li><code>99.6 id</code> : 空闲</li>
<li><code>0.0 wa</code> : 等待io</li>
<li><code>0.0 hi</code> : 硬中断</li>
<li><code>0.0 si</code> : 软中断</li>
<li><code>0.0 st</code> : 虚拟机</li>
</ul>
<p>以上数字含义为百分比</p>
<h3 id="内存和Swap交换区状态"><a href="#内存和Swap交换区状态" class="headerlink" title="内存和Swap交换区状态"></a>内存和Swap交换区状态</h3><p>紧接第四行与第五行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KiB Mem :  7990064 total,  7001532 free,   698000 used,   290532 buff/cache</span><br><span class="line">KiB Swap :  8257532 total,  8257532 free,        0 used.  7043352 avail Mem </span><br></pre></td></tr></table></figure>

<p><code>KiB Mem</code>为物理内存区，<code>KiB Swap</code>是交换区，从左至右分别是总量、空闲、已经使用、（内核缓存用量与可用内存）</p>
<h3 id="最后内容"><a href="#最后内容" class="headerlink" title="最后内容"></a>最后内容</h3><p>紧接着是关于系统中正在运行的进程信息，信息<strong>title</strong>如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PID</code> : 进程id</li>
<li><code>USER</code> : 进程归属者</li>
<li><code>PR</code> : 优先级</li>
<li><code>NI</code> : nice值</li>
<li><code>VIRT</code> : 虚拟内存</li>
<li><code>RES</code> : 无力内存</li>
<li><code>SHR S  %CPU %MEM</code> : 共享内存/CPU/内存</li>
<li><code>TIME+ COMMAND</code> : CPU总时间/命令</li>
</ul>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li><code>shift+e</code> : 切换内存显示模式（可重复按键切换）</li>
<li><code>z</code> : 切换是否彩色显示（可重复按键切换）</li>
<li><code>m</code> : 切换内存显示模式（可重复按键切换）</li>
<li><code>e</code> : 切换底部进程中单位的显示模式（可重复按键切换）</li>
<li><code>b</code> : 切换高亮选中（可重复按键切换）</li>
<li><code>W</code> : 把当前配置保存到文件中，下次启动top会使用当前的配置</li>
<li><code>h</code> : 进入帮助菜单 (进入菜单后，可按ESC或q退出帮助菜单)</li>
<li><code>q</code> : 退出top命令</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>行尾序列是个啥？</title>
    <url>/2022/10/19/Linux-%E8%A1%8C%E5%B0%BE%E5%BA%8F%E5%88%97%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p>在使用vscode开发的时候，我一直很疑惑右下角的一个<code>选择行尾序列</code>的按钮，这东西到底什么用？为啥点击之后感觉也没啥变化？但是碍于我很懒，只想摆烂，所以一直没有去关心这个。但是好奇心终究还是挡不住，我还是打算将其搞个明白。</p>
<hr>
<h2 id="究竟是啥？"><a href="#究竟是啥？" class="headerlink" title="究竟是啥？"></a>究竟是啥？</h2><p>简单来说就是当我们需要写一段文本的时候如果需要换行，在<code>Linux</code>与<code>windows</code>下面是不同的，虽然我们同样看到的是换行的样式，但是实际被记录的是两种。</p>
<p><code>Linux</code>下创建的<code>LinuxFIle</code>文件，用<code>Linux</code>的编辑器在里面写上文本。然后用<code>Python</code>显示出转义符，可以看到换行符是<code>\n</code>，这里的<code>\n</code>就是指的是换行符（<code>LF</code>）。</p>
<p><code>Windows</code>下创建的文件，同样的处理方式，换行符是<code>\r\n</code>，<code>\r</code>指的就是回车（<code>CR</code>），<code>\r\n</code>连起来就是回车换行（<code>CRLF</code>）。</p>
<blockquote>
<p>总结来说就是：在Linux里编辑文件，一行结束后跟的是<code>\n</code>；在Windows里用自带的记事本编辑文件，一行结束后跟的是<code>\r\n</code></p>
</blockquote>
<h2 id="CR和LF"><a href="#CR和LF" class="headerlink" title="CR和LF"></a>CR和LF</h2><p><code>CR</code>和<code>LF</code>是缩写，其实他们的全称分别是：<code>Carriage-Return</code>和<code>Line-Feed</code>。追本溯源的说，<code>CR(Carriage-Return)</code>和<code>LF(Line-Feed)</code>这两个词来源于打字机的发明和使用。打字机的纸张向下卷动一行，就是换行(<code>LF</code>, <code>Line-Feed</code>),将打印头从最右边归位到最左边，就是回车(<code>CR</code>, <code>Carriage-Return</code>)</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux当中解压命令基础</title>
    <url>/2022/08/30/Linux-%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>在常见的Linux压缩当中，有两种格式是十分常见的，分别是<code>zip</code>与<code>tar</code>，这边文章对两种格式需要用到的命令做了基础性的总结。</p>
<h2 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h2><p>zip和unzip命令可以分别对文件进行压缩和解压缩</p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip可以对文件快速创建压缩包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip archive inpath inpath  ...</span><br><span class="line"><span class="comment"># archive指定生成压缩归档文件的路径</span></span><br><span class="line"><span class="comment"># inpath inpath ...要添加到压缩包中的文件路径</span></span><br></pre></td></tr></table></figure>

<p>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip backup.zip <span class="built_in">test</span>/*.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在windows当中压缩文件可以右键进行压缩，并且有多种选项，相对的在Linux也可以做这些选项，不过这些都涵盖在命令当中。</p>
</blockquote>
<h3 id="zip分卷压缩"><a href="#zip分卷压缩" class="headerlink" title="zip分卷压缩"></a>zip分卷压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -s 64k new.zip *.txt</span><br><span class="line"><span class="comment"># -s 64k 指定分卷大小为64K，zip允许的最小分卷大小为64k。</span></span><br><span class="line">zip test.zip  /bin/zsh  -s 100k</span><br></pre></td></tr></table></figure>

<p>对压缩包重新分卷 如果你有一个较大的压缩包，要进行分卷也可以采用类似的方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip big.ziph --out new.zip -s 1m</span><br></pre></td></tr></table></figure>

<h3 id="zip的更多参数"><a href="#zip的更多参数" class="headerlink" title="zip的更多参数"></a>zip的更多参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip options archive inpath inpath ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>options在这里是指一系列的选项参数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归遍历目录</td>
</tr>
<tr>
<td>-q</td>
<td>不显示压缩命令的执行过程（q为quite缩写，安静模式）</td>
</tr>
<tr>
<td>-d</td>
<td>删除压缩包中指定文件</td>
</tr>
<tr>
<td>-p</td>
<td>添加密码，密码在命令行是明文</td>
</tr>
<tr>
<td>-e</td>
<td>添加密码，密码是隐藏的</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>不使用-r参数，压缩遇到目录，只会添加目录路径本身，不会遍历目录内其他文件</li>
<li>-d 的含义是删除已经压缩好的压缩包当中的文件，不是在压缩过程中排除某个文件</li>
<li>使用-p的时候需要添加密码参数，使用-e的时候不需要添加密码，等待输入回车后提示输入密码</li>
</ul>
</blockquote>
<h3 id="unzip解压缩文件"><a href="#unzip解压缩文件" class="headerlink" title="unzip解压缩文件"></a>unzip解压缩文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip filepath</span><br><span class="line"><span class="comment"># filepath 要解压缩的文件的路径。</span></span><br><span class="line">unzip test.zip</span><br></pre></td></tr></table></figure>

<h3 id="unzip其他参数"><a href="#unzip其他参数" class="headerlink" title="unzip其他参数"></a>unzip其他参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>查看压缩包内容</td>
</tr>
<tr>
<td>-d</td>
<td>指定解压缩路径</td>
</tr>
</tbody></table>
<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>gzip命令是一个既能进行压缩，又能进行解压缩的全能选手</p>
<p><strong>使用方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip [OPTION] ... [FILE] ...</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[OPTION]</code> 选项参数，可以指定多个选项参数</li>
<li><code>[FILE]</code> 要压缩的文件路径，可以指定多个要压缩文件</li>
</ul>
<p>下面是常用参数的一个列表:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数长名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>—stdout</td>
<td>在标准输出上输出，保持原始文件</td>
</tr>
<tr>
<td>-d</td>
<td>—decompress</td>
<td>解压缩</td>
</tr>
<tr>
<td>-f</td>
<td>—force</td>
<td>强制覆盖输出文件并压缩链接</td>
</tr>
<tr>
<td>-h</td>
<td>—help</td>
<td>显示帮助</td>
</tr>
<tr>
<td>-k</td>
<td>—keep</td>
<td>保留（不删除）输入文件</td>
</tr>
<tr>
<td>-l</td>
<td>—list</td>
<td>列出压缩文件的内容</td>
</tr>
<tr>
<td>-L</td>
<td>—license</td>
<td>显示软件许可证</td>
</tr>
<tr>
<td>-n</td>
<td>—no</td>
<td>name</td>
</tr>
<tr>
<td>-N</td>
<td>—name</td>
<td>保存或恢复原始文件名称和时间戳</td>
</tr>
<tr>
<td>-q</td>
<td>—quiet</td>
<td>禁用所有警告，安静模式</td>
</tr>
<tr>
<td>-r</td>
<td>—recursive</td>
<td>对目录启动递归操作</td>
</tr>
<tr>
<td></td>
<td>—syncable</td>
<td>制作对rsync友好的存档</td>
</tr>
<tr>
<td>-S</td>
<td>—suffix=SUF</td>
<td>在压缩文件上使用后缀 SUF</td>
</tr>
<tr>
<td></td>
<td>—synchronous</td>
<td>同步输出（如果系统崩溃，则更安全，但是更慢）</td>
</tr>
<tr>
<td>-t</td>
<td>—test</td>
<td>测试压缩文件的完整性</td>
</tr>
<tr>
<td>-v</td>
<td>—verbose</td>
<td>详细输出执行过程</td>
</tr>
<tr>
<td>-V</td>
<td>—version</td>
<td>显示版本号</td>
</tr>
<tr>
<td>-1</td>
<td>—fast</td>
<td>更快的压缩速度</td>
</tr>
<tr>
<td>-9</td>
<td>—best</td>
<td>最好的压缩率</td>
</tr>
</tbody></table>
<h2 id="tar命令归档"><a href="#tar命令归档" class="headerlink" title="tar命令归档"></a>tar命令归档</h2><p>tar命令可以将多个文件归档到一个文件，或者从归档中还原出所有文件。</p>
<p>这里tar命令的作用是把多个文件打包成一个文件，如果此时再对打包后的这个文件进行gzip压缩，这就会生成一个带压缩的归档文件，通常会看到.tar.gz这样的文件后缀。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar [options...] [file] ...</span><br></pre></td></tr></table></figure>

<ul>
<li>options为可选参数，可以有多个options参数</li>
<li>file为要归档的文件路径，可以有多个这样的file</li>
</ul>
<p>下面是tar命令的一些常用的options参数。</p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>长选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>—create</td>
<td>创建一个新的归档文件</td>
</tr>
<tr>
<td>-r</td>
<td>—append</td>
<td>往归档文件末尾追加文件</td>
</tr>
<tr>
<td>-u</td>
<td>—update</td>
<td>将更新的文件更新到归档中</td>
</tr>
<tr>
<td>-x</td>
<td>—get —extract</td>
<td>将归档中解压文件</td>
</tr>
<tr>
<td>-d</td>
<td>—diff —compare</td>
<td>对归档和文件系统中的文件进行差异比较</td>
</tr>
<tr>
<td></td>
<td>—delete</td>
<td>从归档文件中删除指定文件</td>
</tr>
<tr>
<td>-t</td>
<td>—list</td>
<td>查看归档文件中的内容列表</td>
</tr>
<tr>
<td>-v</td>
<td>—verbose</td>
<td>显示执行过程</td>
</tr>
<tr>
<td>-z</td>
<td>—gzip</td>
<td>使用gzip进行压缩</td>
</tr>
<tr>
<td>-f</td>
<td>—file</td>
<td>指定备份文件名称</td>
</tr>
</tbody></table>
<p>并且以上面的这些选项参数可以叠加使用,如下：</p>
<h3 id="创建归档"><a href="#创建归档" class="headerlink" title="创建归档"></a>创建归档</h3><p>下面的这条命令，是对当前路径下所有的.txt后缀的文件进行归档，并使用gzip对归档文件进行压缩。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf test.tar.gz <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>

<p>-czvf 这是一个多个选项合并的写法，</p>
<ul>
<li>c 创建归档</li>
<li>z 使用gzip进行压缩处理</li>
<li>v 显示执行过程</li>
<li>f 指定归档文件的名称，</li>
<li><code>test.tar.gz</code> 为归档文件的名称</li>
<li><code>test/</code> 为要归档的文件路径</li>
</ul>
<h3 id="解压归档"><a href="#解压归档" class="headerlink" title="解压归档"></a>解压归档</h3><p>使用下面这条命令，我们可以把一个gzip压缩的归档文件进行解压缩。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure>

<p>注意实验前，先把test目录删除干净，然后再进行解压操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf <span class="built_in">test</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell环境变量</title>
    <url>/2022/08/18/Linux-shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><code>bash shell</code>用一个叫作环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息(这也是它们被称作环境变量的原因)。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。</p>
<p>简单来说环境变量就是在交互环境中预先被设定的变量，能够让程序启动的时候更快的找到他们或者为某些程序预先设置运行条件的变量设置。如电脑中两个Java，指定环境变量能够让Java默认启动第一个或者第二个。</p>
<blockquote>
<p>在shell编程中尽量使用大写字符作为变量名称。并且环境变量不能够以数字作为变量名的开头。</p>
</blockquote>
<h2 id="环境变量发赋值与输出"><a href="#环境变量发赋值与输出" class="headerlink" title="环境变量发赋值与输出"></a>环境变量发赋值与输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名称=变量值</span><br><span class="line">echo $变量名称</span><br></pre></td></tr></table></figure>

<h2 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h2><p>全局变量生效与所有的shell环境中。 <code>export a=1</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@my server~]# echo $b</span><br><span class="line">2</span><br><span class="line">[root@myserver~]# b=2</span><br><span class="line">[root@myserver~]# export b</span><br><span class="line">[root@myserver~]# bash</span><br><span class="line">[root@myserver~]# echo $b</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>局部:仅生效与当前的环境中  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@myserver~]# b=2</span><br></pre></td></tr></table></figure>

<p>如何查看系统中的环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@myserver~]#env | grep HOME</span><br><span class="line">HOME=/root</span><br></pre></td></tr></table></figure>

<h2 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@myserver~]# env | grep a=1</span><br><span class="line">a=1</span><br><span class="line">[root@myserver~]# unset a </span><br><span class="line">[root@myserver~]# env | grep a=1 </span><br></pre></td></tr></table></figure>

<h2 id="etc-profile"><a href="#etc-profile" class="headerlink" title="/etc/profile"></a>/etc/profile</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 新增环境变量</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/root</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vim /etc/profie</span><br><span class="line"><span class="comment"># 重新加载环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="环境变量涉及的文件"><a href="#环境变量涉及的文件" class="headerlink" title="环境变量涉及的文件"></a>环境变量涉及的文件</h2><ul>
<li><code>/etc/profile</code> : The systemwide initialization file, executed for login shells。系统初始化文件，在login shells时执行</li>
<li><code>/etc/bash.bash_logout</code> : The systemwide login shell cleanup file, executed when a login shell exits。系统的登录shell清理文件，当一个登录shell退出时执行。</li>
<li><code>~/.bash_profile</code> : The personal initialization file, executed for login shells。个人初始化文件，为登录shell执行。</li>
<li><code>~/.bashrc</code> : The individual per-interactive-shell startup file。每个交互式shell启动文件。</li>
<li><code>~/.bash_logout</code> : The individual login shell cleanup file, executed when a login shell exits。单个登录shell清理文件，当一个登录shell退出时执行。</li>
</ul>
<p>这些文件涉及到bash与shell相关的知识，但是在个人配置环境变量的时候经常接触到，了解文件的作用机制可以更好的在不同文件当中设置环境变量</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>java 环境变量的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_241</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HIOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>RAG-什么是RAG</title>
    <url>/2025/05/21/RAG-%E4%BB%80%E4%B9%88%E6%98%AFRAG/</url>
    <content><![CDATA[<p>在传统数据库查询与RAG（检索增强生成）技术之间，存在着如同图书馆卡片目录与专业学术顾问之间的本质差异。这种差异不仅体现在技术实现层面，更深刻地改变了获取和处理知识的方式。</p>
<p>传统数据库查询如同在结构严谨的档案馆中工作，通过精确的SQL语句或关键词匹配，从行列分明的表格中提取预设答案。这种查询遵循严格的模式（Schema），要求提问者必须明确知道如何构建查询条件，系统则根据索引快速返回完全匹配的结果。例如查询”2023年公司销售额”，数据库会直接返回存储在”financial_data”表中”year=2023”的对应数值。</p>
<p>而RAG的知识库查询更像与一位博览群书的专家对话。当用户提出”请分析去年销售表现及其主要原因”这样的开放性问题时，RAG系统首先会理解问题的语义背景，从海量文档（可能是PDF报告、网页、邮件等非结构化数据）中检索相关片段，然后综合这些信息生成结构化的分析报告。这个过程涉及三个认知层面的跃升：</p>
<p>在技术架构上，RAG系统通过嵌入模型（如BERT、GPT）将知识库文档和查询都转换为高维向量，在向量空间中进行相似性检索。这种基于语义而非字面匹配的方式，使得系统能够理解”营收”、”收入”、”销售额”等不同表述的实际关联。典型的处理流程包括：查询理解→向量检索→相关性排序→上下文构造→生成回答，整个过程在毫秒级完成。</p>
<p>传统数据库与RAG知识库的关键差异体现在五个维度：查询方式上，前者需要精确的结构化查询，后者支持自然语言提问；数据组织上，数据库依赖预先定义的模式，RAG处理原始文档；输出结果上，数据库返回精确匹配，RAG生成综合回答；知识更新方面，数据库需要人工ETL，RAG可自动摄入新文档；在容错能力上，数据库查询有绝对对错，RAG回答存在灰度空间。</p>
<p>这种差异在实际应用中产生深远影响。医疗领域，传统数据库可以准确查询”患者A的血型”，而RAG系统能够回答”患者A的症状与哪些疾病相关”；法律场景中，数据库能检索特定法条编号，RAG则可以综合判例解释法条适用性。RAG特别适合处理那些需要背景知识、多文档关联和推理判断的复杂查询。</p>
<p>实现高效的RAG系统需要精心设计多个环节：文档分块策略影响检索精度，通常采用语义段落而非固定字数分割；向量模型选择决定语义理解深度，当前sentence-transformers模型较通用；检索阶段可加入元数据过滤提升准确性；生成环节要通过提示工程确保回答基于检索内容。值得注意的是，RAG并非万能，对于需要精确数值的查询（如”库存量”），传统数据库仍是更可靠选择。</p>
<p>RAG技术正在重塑知识管理系统的发展方向。它打破了传统数据库”垃圾进-垃圾出”的限制，使组织能够充分利用积累的非结构化数据财富。随着嵌入模型和生成模型的持续进步，未来的知识查询系统将更加智能，在保持事实准确性的同时，提供更深度的知识分析和洞察。这种转变不仅改变了人机交互方式，更重新定义了组织获取和利用知识的基本范式。</p>
]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>RAG</tag>
      </tags>
  </entry>
  <entry>
    <title>RAG-向量模型选择</title>
    <url>/2025/05/21/RAG-%E5%90%91%E9%87%8F%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在检索增强生成(Retrieval-Augmented Generation, RAG)系统中，向量模型的质量直接决定了系统的检索效果，进而影响最终生成内容的相关性和准确性。本文将深入探讨如何评估和选择适合RAG系统的向量模型,如有不足请指正。</p>
<h2 id="一、向量模型的核心作用"><a href="#一、向量模型的核心作用" class="headerlink" title="一、向量模型的核心作用"></a>一、向量模型的核心作用</h2><p>向量模型(嵌入模型)在RAG系统中承担着将文本转化为数值向量(嵌入)的关键任务，其质量影响以下核心环节：</p>
<ol>
<li><strong>语义表示能力</strong>：决定模型是否能准确捕捉文本的深层含义</li>
<li><strong>检索相关性</strong>：影响系统找到与查询最相关文档的能力</li>
<li><strong>计算效率</strong>：直接影响系统的响应速度和资源消耗</li>
<li><strong>领域适应性</strong>：决定模型在特定领域的表现效果</li>
</ol>
<h2 id="二、主流向量模型类型"><a href="#二、主流向量模型类型" class="headerlink" title="二、主流向量模型类型"></a>二、主流向量模型类型</h2><h3 id="1-通用预训练模型"><a href="#1-通用预训练模型" class="headerlink" title="1. 通用预训练模型"></a>1. 通用预训练模型</h3><ul>
<li><strong>示例</strong>：OpenAI的text-embedding-ada-002、Cohere的embed-english-v3.0</li>
<li><strong>特点</strong>：在大规模通用语料上预训练，适合大多数通用场景</li>
<li><strong>优势</strong>：开箱即用，无需额外训练</li>
</ul>
<h3 id="2-领域专用模型"><a href="#2-领域专用模型" class="headerlink" title="2. 领域专用模型"></a>2. 领域专用模型</h3><ul>
<li><strong>示例</strong>：BioBERT(生物医学)、Legal-BERT(法律)</li>
<li><strong>特点</strong>：在特定领域数据上训练或微调</li>
<li><strong>优势</strong>：在专业领域表现更优</li>
</ul>
<h3 id="3-多语言模型"><a href="#3-多语言模型" class="headerlink" title="3. 多语言模型"></a>3. 多语言模型</h3><ul>
<li><strong>示例</strong>：paraphrase-multilingual-MiniLM-L12-v2</li>
<li><strong>特点</strong>：支持多种语言的嵌入表示</li>
<li><strong>优势</strong>：适合多语言应用场景</li>
</ul>
<h3 id="4-轻量级模型"><a href="#4-轻量级模型" class="headerlink" title="4. 轻量级模型"></a>4. 轻量级模型</h3><ul>
<li><strong>示例</strong>：all-MiniLM-L6-v2</li>
<li><strong>特点</strong>：模型尺寸小，推理速度快</li>
<li><strong>优势</strong>：适合资源受限环境</li>
</ul>
<h2 id="三、关键评估指标"><a href="#三、关键评估指标" class="headerlink" title="三、关键评估指标"></a>三、关键评估指标</h2><h3 id="1-语义相似度任务表现"><a href="#1-语义相似度任务表现" class="headerlink" title="1. 语义相似度任务表现"></a>1. 语义相似度任务表现</h3><ul>
<li><p><strong>常用基准</strong>：</p>
<ul>
<li><strong>MTEB</strong>(Massive Text Embedding Benchmark)：涵盖56个数据集、8种任务类型的综合评估</li>
<li><strong>STS</strong>(Semantic Textual Similarity)任务：衡量模型对语义相似度的判断能力</li>
</ul>
</li>
<li><p><strong>典型指标</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> ndcg_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算余弦相似度</span></span><br><span class="line">similarity = cosine_similarity([query_embedding], [doc_embedding])[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算NDCG(衡量排序质量)</span></span><br><span class="line">ndcg = ndcg_score([ideal_ranking], [model_ranking])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-检索任务表现"><a href="#2-检索任务表现" class="headerlink" title="2. 检索任务表现"></a>2. 检索任务表现</h3><ul>
<li><strong>重要指标</strong>：<ul>
<li><strong>召回率@K</strong>(Recall@K)：前K个结果中包含相关文档的比例</li>
<li><strong>精确率@K</strong>(Precision@K)：前K个结果中相关文档的比例</li>
<li><strong>MRR</strong>(Mean Reciprocal Rank)：衡量第一个相关结果出现的位置</li>
</ul>
</li>
</ul>
<h3 id="3-计算效率"><a href="#3-计算效率" class="headerlink" title="3. 计算效率"></a>3. 计算效率</h3><ul>
<li><strong>评估维度</strong>：<ul>
<li><strong>延迟</strong>：单次推理耗时(CPU/GPU)</li>
<li><strong>吞吐量</strong>：单位时间内能处理的请求数</li>
<li><strong>内存占用</strong>：模型运行时内存需求</li>
</ul>
</li>
</ul>
<h3 id="4-领域适应性"><a href="#4-领域适应性" class="headerlink" title="4. 领域适应性"></a>4. 领域适应性</h3><ul>
<li><strong>评估方法</strong>：<ul>
<li>在领域特定测试集上的表现</li>
<li>与领域内专业术语的兼容性</li>
</ul>
</li>
</ul>
<h2 id="四、实用评估流程"><a href="#四、实用评估流程" class="headerlink" title="四、实用评估流程"></a>四、实用评估流程</h2><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例测试数据准备</span></span><br><span class="line">test_cases = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;深度学习在医疗影像中的应用&quot;</span>,</span><br><span class="line">        <span class="string">&quot;relevant_docs&quot;</span>: [<span class="string">&quot;doc1_id&quot;</span>, <span class="string">&quot;doc2_id&quot;</span>],</span><br><span class="line">        <span class="string">&quot;irrelevant_docs&quot;</span>: [<span class="string">&quot;doc3_id&quot;</span>, <span class="string">&quot;doc4_id&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 更多测试用例...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="2-基准测试实现"><a href="#2-基准测试实现" class="headerlink" title="2. 基准测试实现"></a>2. 基准测试实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_model</span>(<span class="params">model, test_cases, doc_embeddings</span>):</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> case <span class="keyword">in</span> test_cases:</span><br><span class="line">        query_embedding = model.encode(case[<span class="string">&quot;query&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算所有文档的相似度</span></span><br><span class="line">        similarities = cosine_similarity(</span><br><span class="line">            [query_embedding],</span><br><span class="line">            [doc_embeddings[doc_id] <span class="keyword">for</span> doc_id <span class="keyword">in</span> case[<span class="string">&quot;relevant_docs&quot;</span>] + case[<span class="string">&quot;irrelevant_docs&quot;</span>]]</span><br><span class="line">        )[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算排名指标</span></span><br><span class="line">        <span class="comment"># ...实现具体评估逻辑</span></span><br><span class="line">        </span><br><span class="line">        results.append(metrics)</span><br><span class="line">    <span class="keyword">return</span> aggregate_results(results)</span><br></pre></td></tr></table></figure>

<h3 id="3-结果可视化"><a href="#3-结果可视化" class="headerlink" title="3. 结果可视化"></a>3. 结果可视化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_metrics</span>(<span class="params">metrics_df</span>):</span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">    sns.barplot(data=metrics_df, x=<span class="string">&quot;model&quot;</span>, y=<span class="string">&quot;recall@10&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Recall@10 Comparison Across Models&quot;</span>)</span><br><span class="line">    plt.xticks(rotation=<span class="number">45</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="五、如何合理的评估"><a href="#五、如何合理的评估" class="headerlink" title="五、如何合理的评估"></a>五、如何合理的评估</h2><h3 id="1-需求分析矩阵"><a href="#1-需求分析矩阵" class="headerlink" title="1. 需求分析矩阵"></a>1. 需求分析矩阵</h3><table>
<thead>
<tr>
<th>考虑因素</th>
<th>权重</th>
<th>模型A得分</th>
<th>模型B得分</th>
</tr>
</thead>
<tbody><tr>
<td>语义准确性</td>
<td>40%</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td>推理速度</td>
<td>30%</td>
<td>6</td>
<td>8</td>
</tr>
<tr>
<td>内存占用</td>
<td>20%</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td>领域适配</td>
<td>10%</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>总分</strong></td>
<td>100%</td>
<td>7.4</td>
<td>7.3</td>
</tr>
</tbody></table>
<h3 id="2-典型场景推荐"><a href="#2-典型场景推荐" class="headerlink" title="2. 典型场景推荐"></a>2. 典型场景推荐</h3><ul>
<li><strong>高精度优先</strong>：选择MTEB排名靠前的大模型(text-embedding-ada-002等)</li>
<li><strong>低延迟要求</strong>：考虑轻量级模型(如all-MiniLM-L6-v2)</li>
<li><strong>领域特异性强</strong>：在领域数据上微调现有模型</li>
<li><strong>多语言支持</strong>：选择多语言专用模型</li>
</ul>
<h2 id="六、优化策略"><a href="#六、优化策略" class="headerlink" title="六、优化策略"></a>六、优化策略</h2><ol>
<li><p><strong>模型微调</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer, InputExample, losses</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">model = SentenceTransformer(<span class="string">&#x27;all-MiniLM-L6-v2&#x27;</span>)</span><br><span class="line">train_examples = [InputExample(texts=[text1, text2], label=similarity_score)]</span><br><span class="line">train_dataloader = DataLoader(train_examples, shuffle=<span class="literal">True</span>, batch_size=<span class="number">16</span>)</span><br><span class="line">train_loss = losses.CosineSimilarityLoss(model)</span><br><span class="line"></span><br><span class="line">model.fit(train_objectives=[(train_dataloader, train_loss)], epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>混合检索策略</strong>：</p>
<ul>
<li>结合稠密检索(向量)和稀疏检索(如BM25)</li>
<li>使用重排序(Rerank)模型优化最终结果</li>
</ul>
</li>
<li><p><strong>维度缩减</strong>：</p>
<ul>
<li>使用PCA或UMAP降低嵌入维度</li>
<li>平衡精度和效率</li>
</ul>
</li>
</ol>
<h2 id="七、常见误区"><a href="#七、常见误区" class="headerlink" title="七、常见误区"></a>七、常见误区</h2><ol>
<li><strong>盲目追求大模型</strong>：并非所有场景都需要最大模型</li>
<li><strong>忽视领域适配</strong>：通用模型在专业领域可能表现不佳</li>
<li><strong>忽略计算成本</strong>：模型运行成本长期累积可能很高</li>
<li><strong>单一评估指标</strong>：需要综合多个指标全面评估</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>选择合适的向量模型需要综合考虑性能指标、计算资源和业务需求的平衡。建议从以下步骤入手：</p>
<ol>
<li>明确应用场景和需求优先级</li>
<li>选择3-5个候选模型进行基准测试</li>
<li>在真实数据上进行小规模验证</li>
<li>持续监控生产环境中的表现并迭代优化</li>
</ol>
<p>记住，没有”最好”的向量模型，只有”最适合”的向量模型。随着技术的发展，定期重新评估模型选择是保持RAG系统竞争力的关键。</p>
<h2 id="延伸阅读资源"><a href="#延伸阅读资源" class="headerlink" title="延伸阅读资源"></a>延伸阅读资源</h2><ol>
<li><a href="https://huggingface.co/spaces/mteb/leaderboard">MTEB官方排行榜</a></li>
<li><a href="https://www.sbert.net/">Sentence-Transformers文档</a></li>
<li><a href="https://arxiv.org/abs/2112.01488">向量检索优化技术白皮书</a></li>
</ol>
]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>RAG</tag>
        <tag>大模型</tag>
        <tag>向量模型</tag>
        <tag>检索增强生成</tag>
      </tags>
  </entry>
  <entry>
    <title>git分支怎样改名字</title>
    <url>/2022/07/25/git-%E5%88%86%E6%94%AF%E6%80%8E%E6%A0%B7%E6%94%B9%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<p>假设分支名称为oldName,想要修改为 newName</p>
<p>1.本地分支重命名(还没有推送到远程)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure>

<p>2.远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)</p>
<p>a. 重命名远程分支对应的本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure>

<p>b. 删除远程分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --delete origin oldName</span><br></pre></td></tr></table></figure>

<p>c. 上传新命名的本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin newName</span><br></pre></td></tr></table></figure>

<p>d.把修改后的本地分支与远程分支关联</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础使用</title>
    <url>/2022/05/01/git-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h2><p>git是一个<strong>分布式的版本控制软件</strong>。  </p>
<ul>
<li>分布式：<blockquote>
<p>场景：解决开发进度丢失问题，某人进度丢失可以从其他开发者那里找回来</p>
</blockquote>
</li>
<li>版本控制：能够控制开发<strong>进度</strong>并记录开发<strong>版本</strong>。<blockquote>
<p>场景：软件升级版本，毕业论文修改版本，写书不停的修订版本。</p>
</blockquote>
</li>
<li>软件：字面意思。<blockquote>
<p>场景：window上的安装包，软件，无脑下一步的安装的软件。</p>
</blockquote>
</li>
</ul>
<h3 id="分布式能够做什么？"><a href="#分布式能够做什么？" class="headerlink" title="分布式能够做什么？"></a>分布式能够做什么？</h3><ul>
<li>分布式存储开发进度，防止仓库信息挂掉的问题</li>
<li>提高代码开发完整性</li>
</ul>
<h3 id="关于版本控制能够做什么？"><a href="#关于版本控制能够做什么？" class="headerlink" title="关于版本控制能够做什么？"></a>关于版本控制能够做什么？</h3><ul>
<li>良好的版本管理可以控制开发进度，掌握开发问题，统一处理问题</li>
<li>可以多人同时开发，共同完成一个项目或者问题，减少重复工作量</li>
<li>减少文件重复保存，浪费存储资源</li>
<li>对版本回滚，问题排查，开发者追究起到良好的控制作用</li>
</ul>
<h3 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a>git是什么</h3><p>git是一个可以管理版本的软件，并且支持多人协同管理，能够有效的解决开发冲突、版本控制、文件存放等问题。并且由于其支持分布式，所以不用担心某一处版本丢失问题。并且开发能够独立与其他开发者的进度，可以实现独立版本控制与多人版本控制。<br>git每一次进行版本控制都只会保留修改部分的内容，不会将内容全部保存，因此不会占用太大的空间资源，因此十分适合长期、大体量、多用户、工作复杂的版本管理。</p>
<h2 id="个人如何使用"><a href="#个人如何使用" class="headerlink" title="个人如何使用"></a>个人如何使用</h2><h3 id="git的文件关系"><a href="#git的文件关系" class="headerlink" title="git的文件关系"></a>git的文件关系</h3><ul>
<li>开发区：自己本地没有进入版本的的新文件或者文件被变动过</li>
<li>暂存区：将想要提交新版本的文件存放的区域</li>
<li>版本管理区：已经提交过版本管理的文件<blockquote>
<p>为什么会有暂存区，暂存区的存在使得文件能够更加灵活的开发，假设开发超进度了，但是只需要部分功能，这样也可以很好的做版本控制。或者临时发现有些文件不需要进入版本，需要移出这个版本也需要暂存区这个功能。暂存去就代表文件走向了版本管理的流程。</p>
</blockquote>
</li>
</ul>
<h3 id="第一次版本管理流程"><a href="#第一次版本管理流程" class="headerlink" title="第一次版本管理流程"></a>第一次版本管理流程</h3><p>如是实现：  </p>
<ul>
<li>进入项目文件夹根目录</li>
<li>初始化文件夹: <code>git init</code></li>
<li>查看文件夹下所有文件状态：<code>git status</code><blockquote>
<p>在git命令行当中，新文件或者被修改的文件会被标识为红色</p>
</blockquote>
</li>
<li>将文件存储到暂存区: <code>git add .</code><blockquote>
<p><code>add .</code>的含义是把所有文件都添加进去。如果想要一个个的添加文件你可以使用<code>git add 指定文件的全名(包含后缀名)</code>。添加到暂存区之后的文件会呈现绿色。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果你想要把一个文件从暂存区踢出去，你可以使用命令：<code>git restore &lt;filename&gt;</code></p>
</blockquote>
<ul>
<li>记录一个版本: <code>git commit -m &quot;版本的名字&quot;</code></li>
</ul>
<h3 id="而后的管理"><a href="#而后的管理" class="headerlink" title="而后的管理"></a>而后的管理</h3><p>再第一次初始化之后，而后的版本管理步骤相比于第一次就不用执行<code>git init</code>命令。之后只需要继续添加你想要加入新版本的文件，将文件加入暂存区，再提交版本。</p>
<h3 id="个人信息配置"><a href="#个人信息配置" class="headerlink" title="个人信息配置"></a>个人信息配置</h3><p>git配置个人信息有利于在多人开发的时候识别版本修改来源于哪一位修改者，一般来说在第一次执行版本提交命令的时候，如果没有配置个人信息，那么一定会报错，提示让你运行命令：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;you name&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h3><ul>
<li>如果已经提交多次，想要查看历史的版本记录，可以使用命令：<code>git log</code></li>
<li>如果该版本出错了，想要找回历史版本，这个过程被称为<strong>回滚</strong>。意思就是重新滚回到历史的某一个版本，可以执行命令：<code>git reset --hard 版本号</code><blockquote>
<p>什么是版本号？版本号就是查看历史记录的时候展示的commit后面的一串编码。<br><strong>注意：</strong> 当执行了回滚之后再使用<code>git log</code>就不能够查看之后的记录了，需要使用另一个命令查看：<code>git reflog</code></p>
</blockquote>
</li>
<li>如果感觉查看版本不直观或者多人协同可以试试图形化查看：<code>git log graph</code></li>
</ul>
<h3 id="分支的使用"><a href="#分支的使用" class="headerlink" title="分支的使用"></a>分支的使用</h3><p>什么是分支？分支是我们基于当前进度在另一方向上进行拓展开发。使用场景：</p>
<blockquote>
<p>开发网站，前期准备工作已经完毕，但是现在需要转型，需要同时转向博客类型跟网盘类型，互不干扰,分成两个分支。<br>软件开发，开发在测试分支上，测试通过进入稳定版本。<br>多人协同工作，每人一个分支，到时候一起来合稿。<br>一人完成多项工作，每个分支一个章节，主分支用于合稿。</p>
</blockquote>
<ul>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch &lt;myselfbranch&gt;</code></li>
<li>切换分支：<code>git checkout master</code></li>
<li>创建并切换：<code>git checkout -b &lt;myselfbranch&gt;</code></li>
<li>删除分支：<code>git branch -d &lt;myselfbranch&gt;</code></li>
<li>合并分支：<code>git merge master</code><blockquote>
<p>合并分支能够让你的分支同步你合并的对象</p>
</blockquote>
</li>
</ul>
<h2 id="结合远程仓库的个人使用"><a href="#结合远程仓库的个人使用" class="headerlink" title="结合远程仓库的个人使用"></a>结合远程仓库的个人使用</h2><p>以上的操作对于个人使用已经完全足够，用于个人记录文档或者日志记录已经完全足够，但是既然git是一个分布式的框架，总会需要结合远程仓库使用的时候。对于远程仓库有GitHub、gitlab、码云等多种选择方式，这里不再过多赘述。现在结合远程仓库一起使用。</p>
<h3 id="为什么要远程仓库"><a href="#为什么要远程仓库" class="headerlink" title="为什么要远程仓库"></a>为什么要远程仓库</h3><p>假设在家办公，在学校也在办公，或者在到处奔赴办公，如果想要继续保持上一次的开发进度，就必须要随身携带自己的文件。如果是以前可以选择放在U盘随身携带或者放在百度云等等。但是如果文件太大，那就比较麻烦了，每一次也是全部拷贝十分麻烦。还有可能文件丢失的可能性。<br>远程仓库的出现能够在云端创建一个保存文件的区域。能够一样保留开发记录，每次下载也可以只更新被更新的文件，不需要全部下载。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>注册一个远程仓库账号， <del>百度创建仓库教程</del></p>
<blockquote>
<p>场景：第一次创建仓库如果你还没开始进行版本管理可以这样操作：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# info&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git remote add origin 你仓库地址</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>只需要在本地按顺序执行以上命令就可以了。</p>
<blockquote>
<p>场景：如果已经在本地写了一些版本了，突然某天想起要不要搞个远程仓库，可以执行以下操作：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin 你仓库地址</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>推送的时候需要填写自己的账号密码，填写你注册平台的账号名与密码。</p>
<h3 id="推送与拉取"><a href="#推送与拉取" class="headerlink" title="推送与拉取"></a>推送与拉取</h3><ul>
<li>push : 推送; pull:拉取;</li>
</ul>
<p>首先必须分清那个是推送，那个是拉取。推送指的是将代码推送到远程仓库里，推送内容包括本地文件与git记录；拉取同理。<br>在添加远程仓库的时候，<code>origin</code>指的是远程仓库的名字，而master指的是分支的名字，一般默认是在主分支也就是master上。</p>
<p>推送跟拉取的时候由于开发进度的不同或者开发产生冲突，会出现代码合并的请求出现，所以在推送之前一定要先拉取一遍保证本地文件为最新版本以防止冲突。</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><blockquote>
<p>场景1：远程仓库的进度大于本地进度，本地没有第一时间合并<br>场景2：两个个不同的人对一个地方进行了修改并且同时推送导致线上冲突</p>
</blockquote>
<p>这两种冲突是需要注意的，一般情况不会发生，但是发生后就需要对代码进行合并。合并一般不使用命令行，就目前的情况已经有比较成熟的合并工具了，具体使用不再赘述。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git推送443报错解决</title>
    <url>/2024/12/01/git-%E6%8E%A8%E9%80%81443%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>git报错：<code>Failed to connect to github.com port 443: Connection refused</code></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-检查网络"><a href="#1-检查网络" class="headerlink" title="1. 检查网络"></a>1. 检查网络</h3><p>确保网络连接正常，可以访问github.com。</p>
<h3 id="2-检查git配置"><a href="#2-检查git配置" class="headerlink" title="2. 检查git配置"></a>2. 检查git配置</h3><p>使用以下命令检查git配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>

<p>如果配置中包含<code>http.proxy</code>或<code>https.proxy</code>，则删除它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h3 id="3-检查防火墙"><a href="#3-检查防火墙" class="headerlink" title="3. 检查防火墙"></a>3. 检查防火墙</h3><p>确保防火墙没有阻止git的443端口。</p>
<h3 id="4-检查代理"><a href="#4-检查代理" class="headerlink" title="4. 检查代理"></a>4. 检查代理</h3><p>确保没有设置代理，可以使用以下命令检查代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I https://github.com</span><br></pre></td></tr></table></figure>

<p>如果返回的<code>HTTP/1.1 200 OK</code>，则表示没有设置代理。如果设置了代理，在windows上可以在设置中关闭代理，在linux上可以使用以下命令关闭代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure>

<h3 id="5-检查git版本"><a href="#5-检查git版本" class="headerlink" title="5. 检查git版本"></a>5. 检查git版本</h3><p>确保git版本在2.0以上，可以使用以下命令检查git版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>如果版本低于2.0，则需要升级git。</p>
<h3 id="6-检查DNS"><a href="#6-检查DNS" class="headerlink" title="6. 检查DNS"></a>6. 检查DNS</h3><p>如果以上方法都没有解决问题，可以尝试更换DNS，例如使用Google DNS（8.8.8.8和8.8.4.4）。</p>
<h3 id="7-检查证书"><a href="#7-检查证书" class="headerlink" title="7. 检查证书"></a>7. 检查证书</h3><p>如果以上方法都没有解决问题，可以尝试更换证书，例如使用Let’s Encrypt证书。</p>
<h3 id="8-检查SSH"><a href="#8-检查SSH" class="headerlink" title="8. 检查SSH"></a>8. 检查SSH</h3><p>如果以上方法都没有解决问题，可以尝试使用SSH方式推送代码，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:username/repo.git</span><br></pre></td></tr></table></figure>

<p>然后使用以下命令推送代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交规范问题</title>
    <url>/2023/01/30/git-%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一直以来个人提交git都是做了啥直接写啥，虽然尽可能的写得很详细但是时间一久难免忘记当时到底是做什么功能。受到同事的提醒，他将他使用的git提交规范推荐给了我，使用了一段时间后感觉确实工作内容看起来更加清晰了，虽然只是几个简单规范，但是受益匪浅。</p>
<h2 id="git-提交规范"><a href="#git-提交规范" class="headerlink" title="git 提交规范"></a>git 提交规范</h2><p>为什么要制定提交规范？</p>
<ul>
<li>便于程序员对提交历史进行追溯，了解发生了什么情况。</li>
<li>一旦约束了 Commit Message ，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个git commit里面，这样一来整个代码改动的历史也将更加清晰。</li>
<li>格式化的 Commit Message 才可以用于自动化输出 Change log 。</li>
</ul>
<hr>
<p>业界通用的Git提交规范：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;):&lt;subject&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>type: 用于说明 Git Commit 的类别，只允许使用下面的标识。</li>
<li>scope: scope用于说明 Commit 影响的范围，比如数据层、控制层、视图层等，视项目不同而不同。</li>
<li>subject: subject是 Commit 目的的简短描述，一般不超过50个字符。</li>
</ul>
<p>这里简单记录一下基本的提交规范：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>emji</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>feat</td>
<td>✨</td>
<td>引入新功能</td>
</tr>
<tr>
<td>fix</td>
<td>🐛</td>
<td>修复 bug</td>
</tr>
<tr>
<td>style</td>
<td>💄</td>
<td>更新 UI 样式文按键</td>
</tr>
<tr>
<td>format</td>
<td>🥚</td>
<td>格式化代码</td>
</tr>
<tr>
<td>docs</td>
<td>📝</td>
<td>添加/更新文档</td>
</tr>
<tr>
<td>perf</td>
<td>👌</td>
<td>提高性能/优化</td>
</tr>
<tr>
<td>init</td>
<td>🎉</td>
<td>初次提交/初始化项目</td>
</tr>
<tr>
<td>test</td>
<td>✅</td>
<td>增加测试代码</td>
</tr>
<tr>
<td>refactor</td>
<td>🎨</td>
<td>改进代码结构/代码格式</td>
</tr>
<tr>
<td>patch</td>
<td>🚑</td>
<td>添加重要补丁</td>
</tr>
<tr>
<td>file</td>
<td>📦</td>
<td>添加新文件</td>
</tr>
<tr>
<td>publish</td>
<td>🚀</td>
<td>发布新版本</td>
</tr>
<tr>
<td>tag</td>
<td>📌</td>
<td>发布新版本</td>
</tr>
<tr>
<td>config</td>
<td>🔧</td>
<td>修改配置文件</td>
</tr>
<tr>
<td>git</td>
<td>🙈</td>
<td>添加或修改.gitignore 文件</td>
</tr>
</tbody></table>
<p>更加详细的规范可以参考这个： <a href="https://developer.aliyun.com/article/441408">https://developer.aliyun.com/article/441408</a></p>
<p>如果懒的话可以使用插件帮助，在vscode上提供很多辅助插件，比如 git-commit-lint-vscode</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin框架数据渲染</title>
    <url>/2022/10/06/go-Gin%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>json渲染</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">	r.GET(<span class="string">&quot;/someJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/moreJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方法二：使用结构体</span></span><br><span class="line">		<span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">			Name    <span class="type">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">			Message <span class="type">string</span></span><br><span class="line">			Age     <span class="type">int</span></span><br><span class="line">		&#125;</span><br><span class="line">		msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">		msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">		msg.Age = <span class="number">18</span></span><br><span class="line">		c.JSON(http.StatusOK, msg)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>xml渲染</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">	r.GET(<span class="string">&quot;/someXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">		c.XML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/moreXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方法二：使用结构体</span></span><br><span class="line">		<span class="keyword">type</span> MessageRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">			Name    <span class="type">string</span></span><br><span class="line">			Message <span class="type">string</span></span><br><span class="line">			Age     <span class="type">int</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> msg MessageRecord</span><br><span class="line">		msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">		msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">		msg.Age = <span class="number">18</span></span><br><span class="line">		c.XML(http.StatusOK, msg)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>xml与json可以互相转化，所以数据格式可以相似，只需要修改返回类型。</p>
</blockquote>
<hr>
<p>YMAL渲染</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someYAML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.YAML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;status&quot;</span>: http.StatusOK&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<p>protobuf渲染</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someProtoBuf&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	reps := []<span class="type">int64</span>&#123;<span class="type">int64</span>(<span class="number">1</span>), <span class="type">int64</span>(<span class="number">2</span>)&#125;</span><br><span class="line">	label := <span class="string">&quot;test&quot;</span></span><br><span class="line">	<span class="comment">// protobuf 的具体定义写在 testdata/protoexample 文件中。</span></span><br><span class="line">	data := &amp;protoexample.Test&#123;</span><br><span class="line">		Label: &amp;label,</span><br><span class="line">		Reps:  reps,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 请注意，数据在响应中变为二进制数据</span></span><br><span class="line">	<span class="comment">// 将输出被 protoexample.Test protobuf 序列化了的数据</span></span><br><span class="line">	c.ProtoBuf(http.StatusOK, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="格式介绍"><a href="#格式介绍" class="headerlink" title="格式介绍"></a>格式介绍</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。</p>
<h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><p>xml是一种纯文本格式的文件。xml指的是可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言；而XML文件一般指里面写有可扩展标记语言代码的文件。</p>
<h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>yaml文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的数据序列化格式，可读性强，可被支持YAML库的不同的编程语言程序导入，如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。它是以数据为核心的，比传统的xml方式更加简洁。其扩展名可以使用.yml或者.yaml。</p>
<h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>protobuf是一种数据交换格式，又称PB编码，由Google开源，类似于Json、XML，但其内部是纯二进制格式，比Json，XML等格式要更精炼，主要用于数据的序列化和反序列化，目前官方提供了JAVA、Python、C++等多种语言的实现。</p>
<p>PB格式的解析依赖于消息文件，在其实现中，.proto定义了各个消息项的id值。直观地，PB编码就是将一个结构体的内容编码成二进制流。例如一段json数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line"> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">176</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">24</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;xieyifenxi&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>.proto文件的定义如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="type">string</span> name = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我也是才知道<code>protobuf</code>这种格式</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>(go学习-1)变量</title>
    <url>/2022/11/28/go-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是非常年轻的一门语言，它的主要目标是“兼具 Python 等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性”。Go语言是编程语言设计的又一次尝试，是对类C语言的重大改进，它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。Go语言的用途众多，可以进行网络编程、系统编程、并发编程、分布式编程…一些碎碎念</p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><p>任何语言都需要一个hello world!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量、常量、全局变量"><a href="#变量、常量、全局变量" class="headerlink" title="变量、常量、全局变量"></a>变量、常量、全局变量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 单行注释</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *多行注释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 变量声明一</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    <span class="comment">// 变量声明二</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    <span class="comment">// 变量名 := 表达式</span></span><br><span class="line">    <span class="comment">// 在函数内部，可以使用更简略的 := 方式声明并初始化变量</span></span><br><span class="line">    <span class="comment">// 注意：短变量只能用于声明局部变量，不能用于全局变量声明</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类型不同多个变量, 全局变量, 局部变量不能使用这种方式</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        <span class="comment">// 内部声明类型</span></span><br><span class="line">        vname1 v_type1</span><br><span class="line">        vname2 v_type2</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先声明类型</span></span><br><span class="line">    <span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> (  </span><br><span class="line">        a <span class="type">int</span></span><br><span class="line">        b <span class="type">bool</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种不带声明格式的只能在函数体中出现</span></span><br><span class="line">    <span class="comment">//g, h := 123, &quot;hello&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;自动换行&quot;</span>)</span><br><span class="line">    fmt.Print(<span class="string">&quot;不自动换行&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, <span class="number">123</span>) <span class="comment">// 格式化输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量一旦被声明之后就不能赋值为其他类型的数据</p>
</blockquote>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<ul>
<li>显式类型定义： <code>const b string = &quot;abc&quot;</code></li>
<li>隐式类型定义： <code>const b = &quot;abc&quot;</code></li>
<li>多个相同类型： <code>const c_name1, c_name2 = value1, value2</code></li>
<li>枚举：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化参数 */</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">   b = <span class="number">20</span></span><br><span class="line">   g = a + b</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;结果： a = %d, b = %d and g = %d\n&quot;</span>, a, b, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><ul>
<li>变量一旦被声明就必须使用</li>
<li>函数返回的多余变量可以用 <code>_</code> 接收表示舍弃，这个符号被称为空白标识符</li>
<li>变量类型被声明后不能赋值其他类型</li>
<li>变量的使用必须严格按照作用域使用，局部优先级大于全局</li>
<li>如果想要交换两个变量的值，则可以简单地使用 <code>a, b = b, a</code></li>
</ul>
<h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p>iota是go语言的常量计数器，只能在常量的表达式中使用。使用iota时只需要记住以下两点</p>
<ul>
<li>iota在const关键字出现时将被重置为0。</li>
<li>const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。</li>
</ul>
<p>​ 使用iota能简化定义，在定义枚举时很有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		n3        <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		_		  <span class="comment">//丢弃该值，常用在错误处理中</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">		n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		_  = <span class="literal">iota</span></span><br><span class="line">		KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// &lt;&lt;移位操作，速度比乘除法快 </span></span><br><span class="line">		MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 1&lt;&lt;3 相当于1*2*2*2     0001 -&gt; 1000</span></span><br><span class="line">		GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">		c, d                      <span class="comment">//2,3</span></span><br><span class="line">		e, f                      <span class="comment">//3,4</span></span><br><span class="line">	)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言简单web</title>
    <url>/2022/10/06/go-%E7%AE%80%E5%8D%95web/</url>
    <content><![CDATA[<h2 id="vscode-插件安装"><a href="#vscode-插件安装" class="headerlink" title="vscode 插件安装"></a>vscode 插件安装</h2><p>由于我个人使用的是vscode进行的操作，所以需要安装一下相应的插件，在插件安装好之后会自动提示安装依赖，国内源不大行，需要进行以下操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GO111MODULE=on</span><br><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure>

<p>不一定即刻生效，如果失败可以考虑重启。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>go语言与其他语言一样，可以实现原生的web服务，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// http.ResponseWriter：代表响应，传递到前端的</span></span><br><span class="line"><span class="comment">// *http.Request：表示请求，从前端传递过来的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	_, _ = fmt.Fprintln(w, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, sayHello)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;http server failed, err:%v \n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接Fs调试运行或者使用命令<code>go run filename.go</code>,如果没有报错就可以访问以下地址查看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:9090/hello</span><br></pre></td></tr></table></figure>

<hr>
<p>当然，如果这样返回的内容同样也可以是HTML标签信息，页面会自动渲染，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	_, _ = fmt.Fprintln(w, <span class="string">&quot;&lt;h1 style=&#x27;color:red&#x27;&gt;hello Golang!&lt;h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着可以更进一步，尝试返回一个html文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// http.ResponseWriter：代表响应，传递到前端的</span></span><br><span class="line"><span class="comment">// *http.Request：表示请求，从前端传递过来的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	html, _ := ioutil.ReadFile(<span class="string">&quot;./template/hello.html&quot;</span>)</span><br><span class="line">	_, _ = fmt.Fprintln(w, <span class="type">string</span>(html));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, sayHello)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;http server failed, err:%v \n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上操作需要在同目录下防止对应的文件才可以实现这个效果。</p>
<h2 id="引入框架"><a href="#引入框架" class="headerlink" title="引入框架"></a>引入框架</h2><ul>
<li><strong>为什么要用框架?</strong>  </li>
</ul>
<p>通过上面的http包，就能够实现一个web的开发，但是框架的好处，就是别人帮我们搭建了一个舞台，同时提供了很多现成的轮子，让我们专注于业务的开发，同时让开发效率更高。</p>
<ul>
<li><strong>Gin框架介绍？</strong>  </li>
</ul>
<p>Gin是一个用Go语言编写的web框架。它是一个类似于martini但拥有更好性能的API框架, 由于使用了httprouter，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上Gin。</p>
<p>Go世界里最流行的Web框架，Github上有32K+star。 基于httprouter开发的Web框架。 中文文档齐全，简单易用的轻量级框架。</p>
<hr>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<h3 id="第一个案例"><a href="#第一个案例" class="headerlink" title="第一个案例"></a>第一个案例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line">	<span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上案例可以尝试更改方法进行不同的测试操作，如POST、DELETE等</p>
<hr>
<p>但是还是不够，可以更进一步，尝试实现一下HTML的渲染，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line">	<span class="comment">//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)</span></span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;users/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;users/index.html&quot;</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;title&quot;</span>: <span class="string">&quot;users/index&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里加载模板文件的时候有两种加载方式，依据情况使用</p>
</blockquote>
<p>模板文件如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;users/index.html&quot;&#125;&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>users/index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>个人感觉用到模板文件的场景已经很少了，现在几乎都是前后端分离的状态，所以没有必要继续针对模板语句相关知识学习下去了。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言操作txt文件</title>
    <url>/2022/09/04/go-%E6%93%8D%E4%BD%9Ctxt%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="打开txt"><a href="#打开txt" class="headerlink" title="打开txt"></a>打开txt</h2><p>二进制打开：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i, v := os.Open(<span class="string">&quot;test.txt&quot;</span>) <span class="comment">//打开文件</span></span><br><span class="line">	<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;                                                                      <span class="comment">//如果报错了进入if</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;打开文件失败&quot;</span>, v)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> i.Close()           <span class="comment">//最后关闭文件</span></span><br><span class="line">	<span class="keyword">var</span> k = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>) <span class="comment">//创建一个容量为128字节的切片</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		h, l := i.Read(k)                <span class="comment">//开始读取，把读取的数据放入切片k中，h是读取了多少字节，l是报错信息</span></span><br><span class="line">		fmt.Println(<span class="type">string</span>(k[:h]), h, l) <span class="comment">//打印读取的内容</span></span><br><span class="line">		<span class="keyword">if</span> h &lt; <span class="number">128</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按行打开：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i, v := os.Open(<span class="string">&quot;test.txt&quot;</span>) <span class="comment">//打开文件</span></span><br><span class="line">	<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;                                                                      <span class="comment">//如果报错了进入if</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;打开文件失败&quot;</span>, v)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> i.Close() <span class="comment">//最后关闭文件</span></span><br><span class="line">	h := bufio.NewReader(i)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		l, err := h.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//读到换行</span></span><br><span class="line">		fmt.Print(l)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123; <span class="comment">//如果读到末尾就会进入</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写入txt"><a href="#写入txt" class="headerlink" title="写入txt"></a>写入txt</h2><p>普通写入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    filePath := <span class="string">&quot;test.txt&quot;</span></span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//及时关闭file句柄</span></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入文件时，使用带缓存的 *Writer</span></span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        write.WriteString(<span class="string">&quot;test info&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Flush将缓存的文件真正写入到文件中</span></span><br><span class="line">    write.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以追加的形式写入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    filePath := <span class="string">&quot;test.txt&quot;</span></span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//及时关闭file句柄</span></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入文件时，使用带缓存的 *Writer</span></span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        write.WriteString(<span class="string">&quot;test info&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Flush将缓存的文件真正写入到文件中</span></span><br><span class="line">    write.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>git新增命令</title>
    <url>/2022/07/25/git-%E6%96%B0%E5%A2%9E%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在以前的git切换分支还有回滚版本的时候使用命令<code>checkout</code>，但是这略微繁琐了一点，也不容区分与记忆，因此后来git就更新了两个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch aaa <span class="comment"># 切换到 aaa分支</span></span><br><span class="line">$ git switch -c aaa <span class="comment"># 创建aaa，然后切换到 aaa分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git restore [--worktree] aaa <span class="comment"># 从staged中恢复aaa到worktree</span></span><br><span class="line">$ git restore --staged aaa <span class="comment"># 从repo中恢复aaa到staged</span></span><br><span class="line">$ git restore --staged --worktree aaa <span class="comment"># 从repo中恢复aaa到staged和worktree</span></span><br><span class="line">$ git restore --<span class="built_in">source</span> dev aaa <span class="comment"># 从指定commit中恢复aaa到worktree</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个更新是很早以前的事情了，但是碍于现在有时候开发git版本被统一，没有跟上导致查到命令没办法使用，所以记录一下而已，所以这篇文章的配乐也不是那么促进学习。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的四大特性</title>
    <url>/2022/05/01/mysql-%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><p>MySQL有四大特性，分别是：原子性、隔离性、永久性、一致性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性这个词是从字面意义上最不好理解的一个词。原子性的含义是：一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。</p>
<p>举个例子，在你使用移动支付的时候，你付钱出去的一瞬间，别人也需要收款到账，付钱与收钱必须是一致的，如果不一致那就说明有问题，某个操作在过程当中遗失了，而这一进一出的过程被视为一个单元操作，不可被分割。出错之后原子性必须具有回滚功能，即返回到操作之前的情况，如果不能做到就有可能引起重大事故。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性分为五种一致性，分别用于解决不同的问题：</p>
<ul>
<li>强一致性：读操作可以立即读到提交的更新操作。  </li>
<li>弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。  </li>
<li>最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。  </li>
<li>单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。</li>
<li>会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值</li>
</ul>
<p>一致性涉及到数据同步问题，也是在支付叫过程当场常常体现，当然还包括信息查询等业务情况。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。在事务并发操作时，可能出现的问题有：  </p>
<ul>
<li><strong>脏读：</strong> 事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。  </li>
<li><strong>不可重复读：</strong> 在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。 不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。</li>
<li><strong>幻读：</strong> 在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。 幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。</li>
</ul>
<p>为了解决这些问题就引入了“隔离级别”的概念。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）：</p>
<ul>
<li><strong>读未提交：</strong> 一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交：</strong> 一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读：</strong> 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化：</strong> 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li>
</ul>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>信息收集之ping</title>
    <url>/2022/11/26/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-ping/</url>
    <content><![CDATA[<p>如果需要知道当前某个IP段内有多少存活的机器，可以使用ping命令查看，虽然不是很准确，但是如果有IP响应了ping那么这个一定是一个存活的主机。</p>
<ul>
<li>当IP数据包在对方计算机处理过程中出现未知的发送错误时，ICMP会向发送者传送错误事实以及错误原因等</li>
<li>信息查询由一个请求和一个应答构成的。只需要向目标发送一个请求数据包，如果收到了来自目标的回应，就可以判断目标是活跃主机，否则可以判断目标是非活跃主机</li>
</ul>
<p>Ping命令是ICMP中较为常见的一种应用，经常使用这个命令来测试本地与目标之间的连通性，发送一个ICMP请求消息给目标主机，若源主机收到目标主机的应答响应消息，则表示目标可达，主机存在。</p>
<blockquote>
<p>$\color{yellow}{但是该方法也存在一定的缺陷，就是当网络设备，例如路由器、防火墙等对ICMP采取了屏蔽策略时，就会导致扫描结果不准确。} $ </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.layers.inet <span class="keyword">import</span> IP, ICMP, sr1</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> ipaddress <span class="keyword">import</span> ip_network</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping_single</span>(<span class="params">ip</span>):</span><br><span class="line">    ip_id = randint(<span class="number">1</span>, <span class="number">65535</span>)</span><br><span class="line">    icmp_id = randint(<span class="number">1</span>, <span class="number">65535</span>)</span><br><span class="line">    icmp_seq = randint(<span class="number">1</span>, <span class="number">65535</span>)</span><br><span class="line">    packet = IP(dst=ip, ttl=<span class="number">64</span>, <span class="built_in">id</span>=ip_id)/ICMP(<span class="built_in">id</span>=icmp_id, seq=icmp_seq)</span><br><span class="line">    response = sr1(packet, timeout=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> response:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] %s is alive&quot;</span> % <span class="built_in">str</span>(ip))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping_scan</span>(<span class="params">network</span>):</span><br><span class="line">    ip_list = ip_network(network)</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> ip_list:</span><br><span class="line">        t = Thread(target=ping_single, args=[<span class="built_in">str</span>(ip)])</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    host = <span class="string">&#x27;14.215.177.0/24&#x27;</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    ping_scan(host)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] 本次扫描共花费 %s 秒&quot;</span> % (t2 - t1))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode离线远程开发配置</title>
    <url>/2022/04/25/vscode-%E7%A6%BB%E7%BA%BF%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于各种原因，在开发过程当中需要做到网络的物理隔绝，因此离线部署环境或者部署开发工具就成为了面临的重大难题，尤其是当需要配置vscode离线远程开发的时候。当然使用pycharm可能不需要这么麻烦，但是个人习惯导致自己觉得vscode更加顺手，同时也更加美观，在后续的vscode更新当中丰富的插件也让我难以割舍，因此配置离线环境下vscode的远程安装就成了一大难题。  </p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="下载VScode"><a href="#下载VScode" class="headerlink" title="下载VScode"></a>下载VScode</h3><p>首先在Vscode官网：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> 点击下载；在浏览器或者下载软件中就可以看到一个下载地址如下图所示，由于国内下载速度非常缓慢，可以将图中红框内的链接部分：az764295.vo.msecnd.net替换为国内镜像：vscode.cdn.azure.cn来提升下载速度。</p>
<h3 id="插件下载与安装"><a href="#插件下载与安装" class="headerlink" title="插件下载与安装"></a>插件下载与安装</h3><p>在插件商店搜索插件，直接点击这里就能跳转到插件的页面上去，页面上提供离线包的下载，直接下载就行。<br><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/vscode%E7%A6%BB%E7%BA%BF%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/%E7%82%B9%E5%87%BB.png" alt="点击"></p>
<blockquote>
<p><strong>注意：</strong>插件伴随着vscode版本的更新而更新，因此需要注意版本的对应关系。</p>
</blockquote>
<h3 id="插件的离线安装"><a href="#插件的离线安装" class="headerlink" title="插件的离线安装"></a>插件的离线安装</h3><p>离线安装如下，选中安装包即可<br><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/vscode%E7%A6%BB%E7%BA%BF%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.png" alt="离线安装"></p>
<h3 id="配置远程开发环境"><a href="#配置远程开发环境" class="headerlink" title="配置远程开发环境"></a>配置远程开发环境</h3><p>在离线状态下，除了需要下载<code>remote-ssh</code>跟<code>Remote - SSH: Editing Configuration Files</code>两个插件以外，还需要下载远程包。即所需依赖包vscode-server-linux-x64.tar.gz，下载链接为：<br><a href="https://update.code.visualstudio.com/commit:[id]/server-linux-x64/stable">https://update.code.visualstudio.com/commit:[id]/server-linux-x64/stable</a><br>其中[id]用所使用的vscode commit ID进行替换，id在帮助-&gt;关于-&gt;提交，则完整下载链接应为如下案例：<br><a href="https://update.code.visualstudio.com/commit:507ce72a4466fbb27b715c3722558bb15afa9f48/server-linux-x64/stable">https://update.code.visualstudio.com/commit:507ce72a4466fbb27b715c3722558bb15afa9f48/server-linux-x64/stable</a></p>
<h3 id="远程配置"><a href="#远程配置" class="headerlink" title="远程配置"></a>远程配置</h3><ul>
<li><p>将下载好的依赖包复制到远程linux服务器用户目录下；</p>
</li>
<li><p>登录linux服务器，在用户目录下执行以下命令：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .vscode-server</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .vscode-server</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> ~/vscode-server-linux-x64.tar.gz bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"></span><br><span class="line">tar -zxvf vscode-server-linux-x64.tar</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> vscode-server-linux-x64 [<span class="built_in">id</span>] （注：[<span class="built_in">id</span>]为自己vscode的commit ID。）</span><br></pre></td></tr></table></figure>

<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>如此配置完之后就能够正常连接远程服务器了。过程当中需要注意以下几个点：</p>
<ul>
<li>目录文件不要通过尝试连接的方式去生成，要自己创建</li>
<li>如果始终连不上思考是否是<code>vscode-server-linux-x64.tar.gz</code>的id版本不同</li>
<li>连接过程当中注意用户与端口的对应关系</li>
<li>连接成功之后远程上是没有插件的，需要上传插件到服务器进程远程安装</li>
</ul>
]]></content>
      <categories>
        <category>琐事</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>信息收集之Whois与ip查询</title>
    <url>/2022/11/26/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-Whois%E4%B8%8Eip%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="Whois查询"><a href="#Whois查询" class="headerlink" title="Whois查询"></a>Whois查询</h3><p>Whois是用来查询域名的IP以及所有者信息的传输协议。简单地说，Whois就是一个数据库，用来查询域名是否已经被注册，以及注册域名的详细信息（如域名所有人、域名注册商等）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> whois <span class="keyword">import</span> whois</span><br><span class="line"></span><br><span class="line">data = whois(<span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<h2 id="ip查询"><a href="#ip查询" class="headerlink" title="ip查询"></a>ip查询</h2><p>没啥好说的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip = socket.gethostbyname(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ip)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>信息收集之子域名挖掘</title>
    <url>/2022/11/26/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<p>域名可以分为顶级域名、一级域名、二级域名等。子域名（<code>subdomain</code>）是顶级域名（一级域名或父域名）的下一级。例如，<code>mail.example.com</code>和<code>calendar.example.com</code>是<code>example.com</code>的两个子域，而<code>example.com</code>则是顶级域<code>.com</code>的子域。在测试过程中，测试目标主站时如果未发现任何相关漏洞，此时通常会考虑挖掘目标系统的子域名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bing_search</span>(<span class="params">site, pages</span>):</span><br><span class="line">    Subdomain = []</span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en-US,en;q=0.5&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip,deflate&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;referer&#x27;</span>: <span class="string">&quot;http://cn.bing.com/search?q=email+site%3abaidu.com&amp;qs=n&amp;sp=-1&amp;pq=emailsite%3abaidu.com&amp;first=2&amp;FORM=PERE1&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">int</span>(pages)+<span class="number">1</span>):</span><br><span class="line">        url = <span class="string">&quot;https://cn.bing.com/search?q=site%3a&quot;</span>+site+<span class="string">&quot;&amp;go=Search&amp;qs=ds&amp;first=&quot;</span>+ <span class="built_in">str</span>((<span class="built_in">int</span>(i)-<span class="number">1</span>)*<span class="number">10</span>) +<span class="string">&quot;&amp;FORM=PERE&quot;</span></span><br><span class="line">        conn = requests.session()</span><br><span class="line">        conn.get(<span class="string">&#x27;http://cn.bing.com&#x27;</span>, headers=headers)</span><br><span class="line">        html = conn.get(url, stream=<span class="literal">True</span>, headers=headers, timeout=<span class="number">8</span>)</span><br><span class="line">        soup = BeautifulSoup(html.content, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">        job_bt = soup.findAll(<span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> job_bt:</span><br><span class="line">            link = i.a.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">            domain = <span class="built_in">str</span>(urlparse(link).scheme + <span class="string">&quot;://&quot;</span> + urlparse(link).netloc)</span><br><span class="line">            <span class="keyword">if</span> domain <span class="keyword">in</span> Subdomain:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Subdomain.append(domain)</span><br><span class="line">                <span class="built_in">print</span>(domain)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    site=<span class="string">&#x27;baidu.com&#x27;</span> </span><br><span class="line">    page = <span class="number">15</span></span><br><span class="line">    <span class="comment"># if len(sys.argv) == 3:</span></span><br><span class="line">    <span class="comment">#     site = sys.argv[1]</span></span><br><span class="line">    <span class="comment">#     page = sys.argv[2]</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     print (&quot;usage: %s baidu.com 10&quot; % sys.argv[0])</span></span><br><span class="line">    <span class="comment">#     sys.exit(-1)</span></span><br><span class="line">    Subdomain = bing_search(site, page)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Monokai色彩方案</title>
    <url>/2025/02/15/vscode-Monokai%E8%89%B2%E5%BD%A9%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="Monokai色彩方案"><a href="#Monokai色彩方案" class="headerlink" title="Monokai色彩方案"></a>Monokai色彩方案</h2><p>在编程的早期，开发者一直在寻找一个能够使工作更轻松、更吸引人的环境。Monokai，以其鲜艳的色彩方案，成为了编辑器、IDE和终端中的热门选择。这篇文章深入探讨了这一标志性色彩方案的起源、发展和持久的吸引力。</p>
<h2 id="Monokai的诞生"><a href="#Monokai的诞生" class="headerlink" title="Monokai的诞生"></a>Monokai的诞生</h2><p>Monokai的旅程始于2006年，由荷兰设计师兼开发者Wimer Hazenberg发起。Wimer对现有的缺乏灵感、过于饱和的编辑器主题感到沮丧，决定创造一些新鲜且实用的东西——一个优先考虑可读性和美学的色彩方案。他的工具选择是macOS上的TextMate，在那里他尝试了一个深色背景和明亮、精心挑选的颜色：用于关键字的粉色，用于字符串的香草黄色，以及微妙的对比来突出代码结构，同时降低不太重要的元素（如注释）的亮度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fibonacci</span> = (<span class="params">n: number</span>) =&gt; &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Called fibonacci(<span class="subst">$&#123;n&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Base case: return n if 0 or 1</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Recursive calls</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原始Monokai颜色的示例代码</p>
<p>Wimer在TextMate的wiki上分享了他的主题，以他自己的互联网别名命名，没有多想。令他惊讶的是，Monokai迅速在编程社区中流行开来，与寻求新鲜替代品的开发者产生共鸣。从那时起，Monokai作为开发者友好、视觉上吸引人的方案的声誉传播开来。</p>
<h2 id="Monokai：一个有自己生命的名称"><a href="#Monokai：一个有自己生命的名称" class="headerlink" title="Monokai：一个有自己生命的名称"></a>Monokai：一个有自己生命的名称</h2><p>“Monokai”这个名字常常引起好奇，因为它听起来有点日本味，导致许多人将其与极简主义或禅宗美学联系起来。然而，它的真实起源更多是基于感觉。</p>
<p>“Monokai”是在2003年左右作为Wimer的互联网别名和公司名称创建的，它没有特定的含义，主要是“感觉对了”。然而，它也代表了一种个人化的项目方法。“Mono”部分表示专注于个人共鸣的想法，反映了设计和开发中的个人努力。与此同时，“kai”部分有一个有趣的声音和愉快的响声，“AI”微妙地暗示了他在人工智能方面的背景。</p>
<p>从一个个人项目名称开始，现在意外地与一个色彩方案联系在一起。要了解更多关于Wimer在他的Monokai别名下的个人项目，请访问monokai.com。</p>
<h2 id="混音和非官方移植"><a href="#混音和非官方移植" class="headerlink" title="混音和非官方移植"></a>混音和非官方移植</h2><p>随着Monokai在开发世界中的传播，它激发了无数混音和改编，产生了市场上几乎每个编辑器的非官方“Monokai启发”主题。Textmate主题的开放性质使其易于开发人员适应和定制以满足其特定需求，在各种编辑器中创造独特的衍生产品。虽然这些改编并非由Wimer创建，但它们的多样性突出了该方案对全球开发人员的影响和影响力。</p>
<h2 id="Sublime-Text的一个决定性时刻"><a href="#Sublime-Text的一个决定性时刻" class="headerlink" title="Sublime Text的一个决定性时刻"></a>Sublime Text的一个决定性时刻</h2><p>当Monokai成为<strong>Sublime Text</strong>的默认主题时，Monokai的受欢迎程度又跃升了一个台阶，Sublime Text是一个以其时尚设计和速度而闻名的编辑器。这一合作使Monokai面向更广泛的受众，将其确立为全球开发人员的首选主题。对许多人来说，Sublime和Monokai成为了新流线型代码编辑方法的不可分割的象征。</p>
<h2 id="Monokai-Pro：最终的现代版本"><a href="#Monokai-Pro：最终的现代版本" class="headerlink" title="Monokai Pro：最终的现代版本"></a>Monokai Pro：最终的现代版本</h2><p>随着Monokai的持续受欢迎，Wimer看到了完善和扩展他原始主题的机会。2017年，他推出了<strong>Monokai Pro</strong>——原始Monokai的现代、功能丰富的演变。</p>
<p>Monokai Pro不仅仅是一个简单的更新；它包括一系列增强功能，以满足当代开发人员的需求，包括用户界面设计和定制图标包。Monokai Pro提供几种颜色过滤器，如“Spectrum”、“Ristretto”和经典的“Monokai”，现在重新命名为<strong>Monokai Classic</strong>。这些选项允许开发人员选择最适合其工作空间的外观和感觉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchJson</span>(<span class="params">url: string</span>): <span class="title class_">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!response.<span class="property">ok</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid response&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchJson</span>(<span class="string">`<span class="subst">$&#123;API&#125;</span>/data.json`</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Fetch error:&#x27;</span>, error));</span><br></pre></td></tr></table></figure>

<p>Monokai Pro颜色的示例代码</p>
<p>Monokai Pro包括70多个定制图标包</p>
<p>与许多将UI和语法高亮分离的主题不同，Monokai Pro遵循<strong>集成设计方法</strong>，其中界面的每个元素都是协调一致且视觉上统一的。Wimer亲自使用并微调Monokai Pro，随着每次迭代对其进行演变，以保持其美学和功能吸引力。这种亲力亲为的方法使Monokai Pro保持其起源的真实性，同时适应现代编码的需求。</p>
<h2 id="关于设计色彩方案的注释"><a href="#关于设计色彩方案的注释" class="headerlink" title="关于设计色彩方案的注释"></a>关于设计色彩方案的注释</h2><p>选择正确的颜色是一项复杂的任务。在文本编辑器中，您希望颜色具有相同的亮度，以便代码可以轻松阅读。然而，并没有一个确定的数学公式来确定颜色的感知“亮度”，即使是像CIELAB和OKLAB这样的既定色彩空间也有其局限性。虽然可以建议使用对比度比率工具来提高可读性，但它们并不普遍适用于所有颜色组合。</p>
<p>在数学模型中捕捉颜色，以精确匹配我们的感知是一种幻觉。我们对颜色的感知是复杂和主观的，即使是最复杂的方法也无法完全在算法中捕捉到它。这使得选择色彩方案更多是一种艺术而不是科学，设计师依靠直觉、经验和反馈来创造和谐且功能性的组合。</p>
<h2 id="Monokai在流行文化中的地位"><a href="#Monokai在流行文化中的地位" class="headerlink" title="Monokai在流行文化中的地位"></a>Monokai在流行文化中的地位</h2><p>Monokai的影响力甚至扩展到了科技世界之外。它出现在《硅谷》、《黑客军团》等节目中，其可识别的颜色为屏幕上的开发人员环境增添了真实性。</p>
<p>它的色彩方案已被插画家、生成艺术家和各种领域的设计师使用。</p>
<h2 id="Monokai-Pro扩展：引入浅色主题"><a href="#Monokai-Pro扩展：引入浅色主题" class="headerlink" title="Monokai Pro扩展：引入浅色主题"></a>Monokai Pro扩展：引入浅色主题</h2><p>多年来，开发人员一直在请求Monokai Pro的浅色主题。接受这一挑战意味着不仅仅是亮化颜色——在浅色背景上对比度表现不同，大胆的色调很容易变得压倒性。</p>
<p>经过广泛的测试，Wimer在2024年引入了<strong>Monokai Pro Light</strong>及其新的“Sun”过滤器，旨在在明亮的环境中保持Monokai的清晰度和可读性。Monokai Pro Light提供温暖、平衡的色调，既易于眼睛又充满活力，使其非常适合自然光线的空间。浅色主题扩展了Monokai的吸引力，同时保持其深思熟虑的功能性设计，为开发人员提供了他们熟悉的经验，以一个清新、浅色的调色板。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">str: string</span>): boolean &#123;</span><br><span class="line">	<span class="keyword">const</span> sanitized = str.<span class="title function_">replace</span>(<span class="regexp">/[W_]/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sanitized === sanitized.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPalindrome</span>(<span class="string">&#x27;never odd or even&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Monokai Pro Light颜色的示例代码</p>
<h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>从一个简单的TextMate主题到一个标志性工具，Monokai的旅程突出了编码中深思熟虑的设计力量。Monokai Pro仍然是Wimer愿景的真实演变，不断适应现代软件需求，同时忠于其在清晰度和简洁性方面的根源。随着代码的演变，Monokai也在演变——这是如何精心设计可以增强开发人员工作空间中功能和流程的持久提醒。</p>
<p>文章来源：<a href="https://monokai.pro/history">https://www.monokai.pro/monokai/</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode的lunch.josn文件解析</title>
    <url>/2024/03/25/vscode-lunch-josn%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span>   </span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python: run_classifier.py&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/test.py&quot;,</span></span><br><span class="line">            <span class="comment">// &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/train.py&quot;,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/run_classifier.py&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integratedTerminal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// &quot;env&quot;: &#123;  </span></span><br><span class="line">            <span class="comment">//     &quot;CUDA_VISIBLE_DEVICES&quot;: &quot;0&quot;,</span></span><br><span class="line">            <span class="comment">//     // &quot;CUDA_LAUNCH_BLOCKING&quot;: &quot;1&quot;,</span></span><br><span class="line">            <span class="comment">// &#125;,</span></span><br><span class="line">            <span class="attr">&quot;justMyCode&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span>  <span class="comment">// 如果是false的话就会进到别的子程序里面，为了调试的直观，设置true比较好</span></span><br><span class="line"><span class="comment">// true就是调试的范围都是你写的代码</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                       <span class="string">&quot;--task_name&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CoLA&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                       <span class="string">&quot;--do_train&quot;</span><span class="punctuation">,</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--do_eval&quot;</span><span class="punctuation">,</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--data_dir&quot;</span><span class="punctuation">,</span> <span class="string">&quot;glue_data/CoLA&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--vocab_file&quot;</span><span class="punctuation">,</span> <span class="string">&quot;uncased_L-2_H-128_A-2/vocab.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--bert_config_file&quot;</span><span class="punctuation">,</span> <span class="string">&quot;uncased_L-2_H-128_A-2/bert_config.json&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                       <span class="string">&quot;--init_checkpoint&quot;</span><span class="punctuation">,</span> <span class="string">&quot;uncased_L-2_H-128_A-2/bert_model.ckpt&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                       <span class="string">&quot;--max_seq_length&quot;</span><span class="punctuation">,</span> <span class="string">&quot;128&quot;</span> <span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--train_batch_size&quot;</span><span class="punctuation">,</span> <span class="string">&quot;32&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--learning_rate&quot;</span><span class="punctuation">,</span> <span class="string">&quot;2e-5&quot;</span> <span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--num_train_epochs&quot;</span><span class="punctuation">,</span> <span class="string">&quot;3.0&quot;</span> <span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;--output_dir&quot;</span><span class="punctuation">,</span> <span class="string">&quot;tmp/CoLA_output&quot;</span>                   </span><br><span class="line">            <span class="punctuation">]</span>       </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置详情"><a href="#配置详情" class="headerlink" title="配置详情"></a>配置详情</h2><p>启动配置必须设定请求类型，属性request ， 分为launch(启动) 和 attach(附加)两种 ,看下面例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          ...</span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">//请求类型为启动</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span>， <span class="comment">//请求类型为附加</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面是launch 和 attach 类型共有的属性：</p>
<ul>
<li><code>protocol</code> 设置调试协议</li>
<li><code>auto</code> 尝试自动检测目标运行时使用的协议</li>
<li><code>inspector</code> 新的V8调试器协议，解决遗留版本的多数问题，node versions &gt;= 6.3 and Electron versions &gt;= 1.7.4.</li>
<li><code>legacy</code> 原始的v8调试器协议，node versions &lt; v8.0 and Electron versions &lt; 1.7.4.</li>
<li><code>port调试使用的端口</code></li>
<li><code>address</code> TCP/IP地址，用于远程调试</li>
<li><code>localRoot</code> 远程调试时映射的本地地址</li>
<li><code>remoteRoot</code> 远程调试时的远程目录地址</li>
<li><code>sourceMaps</code>  默认为true</li>
<li><code>outFiles</code> 当map文件不在js文件同目录时用于指定 sourceMaps的位置</li>
<li><code>restart</code> 自动重启调试</li>
<li><code>timeout</code> 配置自动附加的超时时间</li>
<li><code>stopOnEntry</code> 自动断点到第一行代码处</li>
<li><code>smartStep</code> 自动跳过未映射到源代码的代码</li>
<li><code>skipFiles</code> :[]String,指定跳过单步调试的代码</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;skipFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">   <span class="string">&quot;$&#123;workspaceFolder&#125;/node_modules/**/*.js&quot;</span><span class="punctuation">,</span>  <span class="comment">//跳过node_modules</span></span><br><span class="line">   <span class="string">&quot;$&#123;workspaceFolder&#125;/lib/**/*.js&quot;</span><span class="punctuation">,</span><span class="comment">//跳过lib</span></span><br><span class="line">   <span class="string">&quot;&lt;node_internals&gt;/**/*.js&quot;</span><span class="comment">//跳过node核心模块</span></span><br><span class="line"> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>trace启用诊断输出</p>
<p>以下是特定于类型 launch(启动)的配置属性：</p>
<ul>
<li><code>program</code> 指定调试入口文件地址</li>
<li><code>args</code> :[]String 传递给程序的参数,可在process.argv拿到</li>
<li><code>cwd</code>  指定程序启动调试的目录 ,当vscode启动目录不是项目根目录，并且调试npm script时非常有用</li>
<li><code>runtimeExecutable</code> 设置运行时可执行文件路径，默认是node,可以是其他的执行程序，如npm、nodemon</li>
<li><code>runtimeArgs</code> 传递给运行时可执行文件的参数,例如：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm launch app&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;runtimeExecutable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;runtimeArgs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;run-script&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;app&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;b&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">6666</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>打印参数可以发现 args 、runtimeArgs都会传给程序，但是runtimeArgs参数会紧跟可执行文件</p>
<ul>
<li><code>runtimeVersion</code> 设置运行时可执行程序的版本，如果使用nvm，可以切换node.js版本</li>
<li><code>env</code> 添加额外的环境变量</li>
<li><code>envFile</code> 文件加载环境变量</li>
<li><code>console</code> 配置终端可以是外部终端或者内部集成终端，默认值internalConsole</li>
<li><code>outputCapture</code> -如果设置为std，则进程stdout / stderr的输出将显示在调试控制台中，而不是侦听调试端口上的输出。这对于直接写入stdout / stderr流而不是使用console.*API的程序或日志库很有用。</li>
<li><code>autoAttachChildProcesses</code> 跟踪调试对象的所有子过程，并自动附加到在调试模式下启动的子过程</li>
</ul>
<p>以下是特定于类型 attach(附加)的配置属性：</p>
<p>processId 指定nodejs进程id,由于每次启动都会变，传入”${command:PickProcess}”<br>questions：</p>
<ol>
<li>如果使用了符号链接怎么调试？<br>传递参数:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;runtimeArgs&quot;</span>: [<span class="string">&quot;--preserve-symlinks&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果主脚本也在符号链接路径里面，需要再传递一个参数”–preserve-symlinks-main”，支持的版本是 Node 10+.</p>
<ol start="2">
<li>如何调试ECMAScript模块？</li>
</ol>
<p>如果使用esm或传递–experimental-modules给Node.js以便使用ECMAScript模块，则可以传递这些选项通过runtimeArgs属性：</p>
<ul>
<li><p>“runtimeArgs” : [“–experimental-modules”]  -使用Node v8.5.0 +中的实验性ECMAScript模块支持</p>
</li>
<li><p>“runtimeArgs” : [“-r”, “esm”] -使用esm ES模块加载器（请注意，[“-r esm”]如果没有逗号，则无法使用）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>vascode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>获取exe文件图标</title>
    <url>/2023/03/20/%E5%8F%96%E8%AF%81-exe%E6%96%87%E4%BB%B6%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p>lnk文件图标需要找到对应的exe文件所在真实路径才能获取图标，不能够直接获取。dll与没有指定图标的exe文件获取图标会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32ui</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> win32com.client</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pra_lnk</span>(<span class="params">file_path:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解析lnk文件&quot;&quot;&quot;</span></span><br><span class="line">    shell = win32com.client.Dispatch(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">    shortcut = shell.CreateShortCut(file_path)</span><br><span class="line">    <span class="keyword">return</span> shortcut.Targetpath</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ico_from_exe</span>(<span class="params">file_path:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取exe的ico图标&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># exePath = r&quot;D:\code\test\纷享销客.exe&quot;  # 替换</span></span><br><span class="line">    file_path = pra_lnk(file_path) <span class="keyword">if</span> <span class="string">&quot;.lnk&quot;</span> <span class="keyword">in</span> file_path <span class="keyword">else</span> file_path</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        large, small = win32gui.ExtractIconEx(<span class="string">f&#x27;<span class="subst">&#123;file_path&#125;</span>&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">        useIcon = large[<span class="number">0</span>]</span><br><span class="line">        destroyIcon = small[<span class="number">0</span>]</span><br><span class="line">        win32gui.DestroyIcon(destroyIcon)</span><br><span class="line">        hdc = win32ui.CreateDCFromHandle(win32gui.GetDC(<span class="number">0</span>))</span><br><span class="line">        hbmp = win32ui.CreateBitmap()</span><br><span class="line">        hbmp.CreateCompatibleBitmap(hdc, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">        hdc = hdc.CreateCompatibleDC()</span><br><span class="line">        hdc.SelectObject(hbmp)</span><br><span class="line">        hdc.DrawIcon((<span class="number">0</span>, <span class="number">0</span>), useIcon)</span><br><span class="line">        bmpstr = hbmp.GetBitmapBits(<span class="literal">True</span>)</span><br><span class="line">        img = Image.frombuffer(</span><br><span class="line">            <span class="string">&#x27;RGBA&#x27;</span>,</span><br><span class="line">            (<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">            bmpstr, <span class="string">&#x27;raw&#x27;</span>, <span class="string">&#x27;BGRA&#x27;</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        img.save(<span class="string">&#x27;icon.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;获取图标失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C:\Users\Administrator\Desktop\Synology Chat.lnk</span></span><br><span class="line">get_ico_from_exe(<span class="string">r&quot;C:\Users\Administrator\Desktop\Synology Chat.lnk&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>取证</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10取证基础之剪切板</title>
    <url>/2022/11/26/%E5%8F%96%E8%AF%81-windows%E5%89%AA%E5%88%87%E6%9D%BF/</url>
    <content><![CDATA[<p>win10其实自己有一个比较好用的剪切板功能就是win+v,可以查看历史多条记录，但是剪切板里面其实只有一条，并且可以存文本与图片流，如果是文件，就会存文件的路径，因此图片可以存路径或者流。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32clipboard</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageGrab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paste_pic</span>():</span><br><span class="line">    res = ImageGrab.grabclipboard()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(res, Image.Image):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;图片&quot;</span>)</span><br><span class="line">        res.save(<span class="string">r&#x27;pic.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(res,<span class="built_in">list</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件&quot;</span>,res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    win32clipboard.OpenClipboard()</span><br><span class="line">    text = win32clipboard.GetClipboardData(win32clipboard.CF_UNICODETEXT)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文本：&quot;</span>,text)</span><br><span class="line">    win32clipboard.CloseClipboard()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    paste_pic()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Win10取证</tag>
        <tag>剪切板</tag>
      </tags>
  </entry>
  <entry>
    <title>工具LastActivityView获取历史运行记录</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-LastActivityView%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E8%BF%90%E8%A1%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="LastActivityView"><a href="#LastActivityView" class="headerlink" title="LastActivityView"></a><code>LastActivityView</code></h2><p>查看电脑操作记录(<code>LastActivityView</code>)是一款简单而有用的软件，可以在列表中清清楚楚的看到你的电脑使用历史记录。该软件直接调用系统日志，能显示安装软件、系统启动、关机、网络连接、执行的程序等几乎所有的电脑使用日志，让你更熟悉电脑的行为。</p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>终止指定进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pe_name = <span class="string">&quot;LastActivityView.exe&quot;</span></span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> psutil.process_iter():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name = process.name()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> name == pe_name:</span><br><span class="line">            process.terminate()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        setting.log.error(<span class="string">&quot;终止垃圾进程失败,原因: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(e)))</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>这部分代码首先定义了一个要检查的进程名 <code>pe_name</code>，然后遍历所有正在运行的进程。如果发现进程名为 <code>LastActivityView.exe</code>，则尝试终止该进程，并记录日志。如果终止失败，也会记录日志并返回。</p>
<p>执行外部程序获取软件运行历史记录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tool_path = os.path.join(setting.PROJ_PATH, pe_name)</span><br><span class="line">csv_path = os.path.join(setting.PROJ_PATH, <span class="string">&quot;LastActivityView.csv&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;&#123;&#125; /scomma &#123;&#125;&quot;</span>.<span class="built_in">format</span>(tool_path, csv_path))</span><br></pre></td></tr></table></figure>
<p>这部分代码拼接了外部程序 <code>LastActivityView.exe</code> 的路径和保存<code>CSV</code>文件的路径，然后执行命令行命令，使用 <code>LastActivityView.exe</code> 生成软件运行历史记录的<code>CSV</code>文件。</p>
<p>解析CSV文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(csv_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;GB2312&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv.DictReader(file, delimiter=<span class="string">&quot;,&quot;</span>):</span><br><span class="line">        clean_data = get_line(self, row, self.display_list)</span><br><span class="line">        data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这部分代码打开<code>CSV</code>文件，使用 <code>csv.DictReader</code> 读取每一行数据，并将其转换为字典。然后，它调用 <code>get_line</code> 方法处理每一行数据，并将处理后的数据转换为 <code>JSON</code> 格式，最后写入到输出文件中。</p>
<p>删除临时<code>CSV</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(csv_path)</span><br></pre></td></tr></table></figure>
<p>这部分代码在处理完成后删除临时生成的<code>CSV</code>文件</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
        <tag>LastActivityView</tag>
      </tags>
  </entry>
  <entry>
    <title>获取windows的USB记录</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-windows%E7%9A%84USB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="USBDeview"><a href="#USBDeview" class="headerlink" title="USBDeview"></a>USBDeview</h2><p>某个刑侦专家说过，走过必定留下痕迹，所以在一台电脑上，存在过的USB记录也是可以获取的。当然想法去解析记录可以，也可以直接使用<code>USBDeview</code>，解析软件最终结果。<code>USBDeview</code> 是一款可以列出当前连接到你的计算机上或者曾经连接到你的计算机上的所有 <code>USB</code> 设备的小型实用工具。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>检查并终止指定进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pe_name = <span class="string">&quot;USBDeview.exe&quot;</span></span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> psutil.process_iter():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name = process.name()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> name == pe_name:</span><br><span class="line">            setting.log.error(<span class="string">&quot;检测到%s已在运行, 正在终止重启&quot;</span> % name)</span><br><span class="line">            process.terminate()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        setting.log.error(<span class="string">&quot;终止失败,原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>这部分代码首先定义了一个要检查的进程名 <code>pe_name</code>，然后遍历所有正在运行的进程。如果发现进程名为 <code>USBDeview.exe</code>，则尝试终止该进程，并记录日志。如果终止失败，也会记录日志并返回。</p>
<p>执行外部程序获取<code>USB</code>设备信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pe_path = os.path.join(setting.PROJ_PATH, pe_name)</span><br><span class="line">save_path = os.path.join(setting.PROJ_PATH, <span class="string">&quot;tmp.xml&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;%s /sxml %s&quot;</span> % (pe_path, save_path))</span><br></pre></td></tr></table></figure>
<p>这部分代码拼接了外部程序 <code>USBDeview.exe</code> 的路径和保存<code>XML</code>文件的路径，然后执行命令行命令，使用 <code>USBDeview.exe</code> 生成<code>USB</code>设备信息的<code>XML</code>文件。</p>
<p>解析<code>XML</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_path):</span><br><span class="line">    setting.log.error(<span class="string">&quot;获取usb信息失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">tree = ET.parse(save_path)</span><br><span class="line">root = tree.getroot()</span><br></pre></td></tr></table></figure>
<p>这部分代码检查<code>XML</code>文件是否存在，如果不存在则记录日志并返回。如果存在，则使用 <code>ElementTree</code> 模块解析<code>XML</code>文件，获取根节点。</p>
<p>遍历<code>XML</code>文件中的每个 <code>item</code> 节点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">&#x27;item&#x27;</span>):</span><br><span class="line">    <span class="comment"># 解析每个item节点中的各个子节点，获取相应的信息</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这部分代码遍历<code>XML</code>文件中的每个 <code>item</code> 节点，解析每个节点中的各个子节点，获取相应的信息。如果某个子节点不存在，则将相应的变量设置为空字符串。</p>
<p>构建源数据字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source_data = &#123;</span><br><span class="line">    <span class="string">&quot;DeviceName&quot;</span>: device_name,</span><br><span class="line">    <span class="string">&quot;Description&quot;</span>: description,</span><br><span class="line">    <span class="string">&quot;DeviceType&quot;</span>: device_type,</span><br><span class="line">    <span class="string">&quot;Connected&quot;</span>: connected,</span><br><span class="line">    <span class="string">&quot;Disabled&quot;</span>: disabled,</span><br><span class="line">    <span class="string">&quot;ConnectTime&quot;</span>: connect_time,</span><br><span class="line">    <span class="string">&quot;DisconnectTime&quot;</span>: disconnect_time,</span><br><span class="line">    <span class="string">&quot;ServiceDescription&quot;</span>: service_description,</span><br><span class="line">    <span class="string">&quot;DriveLetter&quot;</span>: drive_letter,</span><br><span class="line">    <span class="string">&quot;RegisterTime1&quot;</span>: registry_time_1,</span><br><span class="line">    <span class="string">&quot;RegisterTime2&quot;</span>: registry_time_2,</span><br><span class="line">    <span class="string">&quot;InstallTime&quot;</span>: install_time,</span><br><span class="line">    <span class="string">&quot;FirstInstallTime&quot;</span>: first_install_time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码将获取到的<code>USB</code>设备信息封装成一个字典。</p>
<p>处理数据并写入文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_data = get_line(self, source_data, self.display)</span><br><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这部分代码调用 <code>get_line</code> 方法处理 <code>source_data</code>，并将处理后的数据转换为 <code>JSON</code> 格式，然后写入到输出文件中。</p>
<p>删除临时<code>XML</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(save_path)</span><br></pre></td></tr></table></figure>
<p>这部分代码在处理完成后删除临时生成的<code>XML</code>文件。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>查询windows电脑当中的可移动设备</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-windows%E5%8F%AF%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h2 id="Win32-DiskDrive"><a href="#Win32-DiskDrive" class="headerlink" title="Win32_DiskDrive"></a><code>Win32_DiskDrive</code></h2><p>在<code>WMI（Windows Management Instrumentation）</code>中，<code>Win32_DiskDrive</code> 类的 <code>MediaType</code> 属性用于描述磁盘驱动器的媒体类型。根据微软的文档，<code>MediaType</code> 属性可以取以下值：</p>
<ul>
<li><code>Unknown</code>：未知的媒体类型</li>
<li><code>Fixed hard disk media</code>：固定硬盘媒体</li>
<li><code>Removable media</code>：可移动媒体，如<code>USB</code>闪存驱动器、软盘等</li>
<li><code>CD-ROM media</code>：<code>CD-ROM</code>媒体</li>
<li><code>RAM disk</code>：<code>RAM</code>磁盘</li>
<li><code>Flash memory</code>：闪存</li>
<li><code>Network disk</code>：网络磁盘</li>
<li><code>Virtual disk</code>：虚拟磁盘</li>
<li><code>Optical disk</code>：光盘</li>
<li><code>Magnetic disk</code>：磁盘</li>
<li><code>Other</code>：其他类型的媒体</li>
</ul>
<h2 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h2><p>当前代码的主要功能是通过<code>WMI（Windows Management Instrumentation）</code>查询<code>Windows</code>系统中的磁盘驱动器信息，并将结果存储在一个字典中。然后，它遍历这个字典，查找媒体类型为“可移动媒体”或“外部硬盘媒体”的逻辑磁盘<code>设备ID</code>，并打印这些<code>设备ID</code>。</p>
<p>导入wmi模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wmi</span><br></pre></td></tr></table></figure>
<p>这行代码导入了<code>Python</code>的<code>wmi</code>模块，该模块允许<code>Python</code>程序访问<code>Windows Management Instrumentation API</code>，从而可以查询和管理<code>Windows</code>系统的各种信息。</p>
<p>创建<code>WMI</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = wmi.WMI()</span><br></pre></td></tr></table></figure>
<p>这行代码创建了一个<code>WMI</code>对象<code>c</code>，用于后续的<code>WMI</code>查询。</p>
<p>查询磁盘驱动器信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drives = c.Win32_DiskDrive()</span><br></pre></td></tr></table></figure>
<p>这行代码查询系统中的所有磁盘驱动器信息，并将结果存储在<code>drives</code>变量中。</p>
<p>初始化字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drives_dict = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这行代码创建了一个空字典<code>drives_dict</code>，用于存储后续查询到的磁盘驱动器和逻辑磁盘的关联信息。</p>
<p>遍历磁盘驱动器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> drive <span class="keyword">in</span> drives:</span><br><span class="line">    partitions = drive.associators(<span class="string">&quot;Win32_DiskDriveToDiskPartition&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> partition <span class="keyword">in</span> partitions:</span><br><span class="line">        logical_disks = partition.associators(<span class="string">&quot;Win32_LogicalDiskToPartition&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> logical_disk <span class="keyword">in</span> logical_disks:</span><br><span class="line">            drives_dict[logical_disk.DeviceID] = drive.MediaType</span><br></pre></td></tr></table></figure>
<p>这段代码遍历每个磁盘驱动器，通过<code>WMI</code>的关联查询获取每个磁盘驱动器对应的磁盘分区，然后再获取每个磁盘分区对应的逻辑磁盘。最后，它将逻辑磁盘的设备<code>ID</code>和磁盘驱动器的媒体类型存储在<code>drives_dict</code>字典中。</p>
<p>遍历字典，查找特定媒体类型的逻辑磁盘：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> drives_dict.items():</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">in</span> [<span class="string">&#x27;Removable Media&#x27;</span>, <span class="string">&#x27;External hard disk media&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure>
<p>这段代码遍历<code>drives_dict</code>字典中的每个键值对，检查媒体类型是否为“可移动媒体”或“外部硬盘媒体”。如果是，它打印出逻辑磁盘的<code>设备ID</code>。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>获取windows的环境变量</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-windows%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>遍历系统环境变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> wmi.WMI().Win32_Environment():</span><br></pre></td></tr></table></figure>
<p>这部分代码使用 wmi 模块遍历系统中的所有环境变量。</p>
<p>提取每个环境变量的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = &#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="built_in">getattr</span>(path, <span class="string">&quot;Name&quot;</span>),</span><br><span class="line">    <span class="string">&quot;SystemVariable&quot;</span>: <span class="built_in">getattr</span>(path, <span class="string">&quot;SystemVariable&quot;</span>),</span><br><span class="line">    <span class="string">&quot;UserName&quot;</span>: <span class="built_in">getattr</span>(path, <span class="string">&quot;UserName&quot;</span>),</span><br><span class="line">    <span class="string">&quot;Description&quot;</span>: <span class="built_in">getattr</span>(path, <span class="string">&quot;Description&quot;</span>),</span><br><span class="line">    <span class="string">&quot;Caption&quot;</span>: <span class="built_in">getattr</span>(path, <span class="string">&quot;Caption&quot;</span>),</span><br><span class="line">    <span class="string">&quot;VariableValue&quot;</span>: <span class="built_in">getattr</span>(path, <span class="string">&quot;VariableValue&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码将每个环境变量的信息提取出来，并存储在一个字典 item 中。</p>
<p>处理获取到的环境变量信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_data = get_line(self, item, self.display_list)</span><br><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这部分代码调用 get_line 方法处理 item，并将处理后的数据转换为 JSON 格式。然后，它将 JSON 数据写入到输出文件中。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>主机驱动提取</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E4%B8%BB%E6%9C%BA%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>在网络取证中，获取主机驱动信息对于理解系统的配置和行为至关重要。可列举以下几点：</p>
<ul>
<li>确定系统组件：驱动程序是操作系统与硬件设备之间的桥梁，获取驱动信息可以帮助识别连接到系统的所有硬件设备，包括网络卡、存储设备、图形卡等 。</li>
<li>分析潜在风险：某些驱动程序可能包含已知的安全漏洞，通过分析驱动信息，取证专家可以识别可能被利用的脆弱点 。</li>
<li>检测恶意软件活动：攻击者有时会安装或修改驱动程序以隐藏其活动或获得对系统的更高权限。审查驱动程序可以帮助发现这些恶意更改 。</li>
<li>系统行为分析：驱动程序影响系统的行为和性能。通过审查驱动程序，可以了解系统在正常和异常情况下的行为模式 。</li>
<li>追踪网络活动：网络驱动程序特别重要，因为它们处理所有网络通信。取证专家可以通过分析网络驱动程序来追踪网络连接和数据流 。</li>
<li>支持法律程序：在法律诉讼中，可能需要提供系统驱动程序的信息作为证据，以证明或反驳与案件相关的技术方面的论点 。</li>
<li>系统恢复和重建：在事件响应中，获取驱动信息有助于重建受损系统的原始状态，这对于恢复服务和防止未来的攻击至关重要 。</li>
<li>兼容性和性能优化：驱动程序信息有助于确定系统组件之间的兼容性问题，并进行必要的调整以优化系统性能 。</li>
</ul>
<h2 id="windows上实现"><a href="#windows上实现" class="headerlink" title="windows上实现"></a>windows上实现</h2><p>定义要查找的进程名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pe_name = <span class="string">&quot;WinDriver.exe&quot;</span></span><br></pre></td></tr></table></figure>
<p>这行代码定义了一个字符串 <code>pe_name</code>，其值为 “WinDriver.exe”，即要查找的进程名称。</p>
<p>遍历所有进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> psutil.process_iter():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name = process.name()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> name == pe_name:</span><br><span class="line">            setting.log.error(<span class="string">&quot;检测到%s已在运行, 正在终止重启&quot;</span> % name)</span><br><span class="line">            process.terminate()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        setting.log.error(<span class="string">&quot;终止失败,原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>这段代码使用 <code>psutil.process_iter()</code> 遍历所有正在运行的进程。对于每个进程，它尝试获取进程的名称，并检查该名称是否与 <code>pe_name</code> 相匹配。如果匹配，它会尝试终止该进程，并记录错误信息。</p>
<p>获取驱动程序信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pe_path = os.path.join(setting.PROJ_PATH, pe_name)</span><br><span class="line">process = exe_cmd(pe_path)</span><br></pre></td></tr></table></figure>
<p>这两行代码首先构建了 <code>WinDriver.exe</code> 的完整路径，然后使用 <code>exe_cmd</code> 函数执行该程序，以获取驱动程序的信息。</p>
<p>处理驱动程序信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    item = process.stdout.readline().decode(<span class="string">&quot;gbk&quot;</span>)  <span class="comment"># type: ignore</span></span><br><span class="line">    <span class="keyword">if</span> item:</span><br><span class="line">        line = item.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        source_data = &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: line[<span class="number">0</span>],</span><br><span class="line">            <span class="string">&quot;Path&quot;</span>: line[<span class="number">1</span>],</span><br><span class="line">            <span class="string">&quot;Address&quot;</span>: line[<span class="number">2</span>],</span><br><span class="line">            <span class="string">&quot;Description&quot;</span>: line[<span class="number">3</span>],</span><br><span class="line">            <span class="string">&quot;Company&quot;</span>: line[<span class="number">4</span>],</span><br><span class="line">            <span class="string">&quot;Version&quot;</span>: line[<span class="number">5</span>],</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: line[<span class="number">6</span>],</span><br><span class="line">            <span class="string">&quot;Md5&quot;</span>: line[<span class="number">7</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        clean_data = get_line(self, source_data, self.display)</span><br><span class="line">        data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        write_file(self.file, data)</span><br><span class="line">    <span class="keyword">elif</span> process.poll() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>这段代码使用一个无限循环来读取 <code>WinDriver.exe</code> 进程的标准输出。对于每一行输出，它将其分割成多个部分，并将这些部分存储在 <code>source_data</code> 字典中。然后，它调用 <code>get_line</code> 方法处理 <code>source_data</code>，并将处理后的数据转换为 <code>JSON</code> 格式，然后写入到输出文件中。如果 <code>process.poll()</code> 返回非空值，则表示进程已经结束，循环也随之结束。</p>
<h2 id="Linux上实现"><a href="#Linux上实现" class="headerlink" title="Linux上实现"></a>Linux上实现</h2><p>执行 <code>lsmod</code> 命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = exe_cmd(<span class="string">&quot;lsmod&quot;</span>).split(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码执行 <code>lsmod</code> 命令，该命令用于列出当前系统中已加载的内核模块。执行结果以字符串形式返回，并通过 <code>split(&quot;\n&quot;)</code> 方法分割成多行。</p>
<p>遍历输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> t[<span class="number">1</span>:]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    module, size, depend = line.split(maxsplit=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码遍历 <code>lsmod</code> 命令的输出结果，跳过第一行（通常是标题行）。对于每一行，它使用 <code>split(maxsplit=2)</code> 方法将其分割成最多三个部分：模块名、大小和依赖项。</p>
<p>构建源数据字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source_data = &#123;</span><br><span class="line">    <span class="string">&quot;Module&quot;</span>: module,</span><br><span class="line">    <span class="string">&quot;Size&quot;</span>: size,</span><br><span class="line">    <span class="string">&quot;Depend&quot;</span>: depend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行代码将获取到的模块名、大小和依赖项封装成一个字典，其中键对应于 <code>display_list</code> 中的 <code>output</code> 字段。</p>
<p>处理数据并写入文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_data = get_line(self, source_data, self.display_list)</span><br><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这行代码调用 <code>get_line</code> 方法处理 <code>source_data</code>，并将处理后的数据转换为 <code>JSON</code> 格式，然后写入到输出文件中。</p>
<h2 id="拓展-lsmod"><a href="#拓展-lsmod" class="headerlink" title="拓展-lsmod"></a>拓展-<code>lsmod</code></h2><p><code>lsmod</code> 是一个用于在 <code>Linux</code> 系统上列出已加载内核模块的命令。内核模块是可加载的代码块，它们可以在系统运行时动态地插入到内核中，以提供额外的功能，比如硬件驱动程序、文件系统支持、网络协议等。</p>
<p><code>lsmod</code> 命令的输出通常包含以下列：</p>
<ul>
<li><code>Module</code>: 模块的名称。</li>
<li><code>Size</code>: 模块占用的内存大小（以字节为单位）。</li>
<li><code>Used by</code>: 依赖于该模块的其他模块数量。</li>
</ul>
<p>lsmod 命令的输出结果类似于以下示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Module                  Size  Used by</span><br><span class="line">nls_iso8859_1           16384  1 </span><br><span class="line">vfat                   20480  1 </span><br><span class="line">fat                    73728  1 vfat</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>nls_iso8859_1</code>、<code>vfat</code> 和 <code>fat</code> <code>是已加载的内核模块名称，Size</code> 列显示了每个模块占用的内存大小，<code>Used by</code> 列显示了依赖于该模块的其他模块数量。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>获取内存与系统镜像</title>
    <url>/2023/02/24/%E5%8F%96%E8%AF%81-%E5%86%85%E5%AD%98%E4%B8%8E%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>剪切板取证</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E5%89%AA%E5%88%87%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><p>打开剪贴板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">win32clipboard.OpenClipboard()</span><br></pre></td></tr></table></figure>
<p>这行代码打开剪贴板，以便读取其中的数据。</p>
<p>获取剪贴板中的文本数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = win32clipboard.GetClipboardData(win32clipboard.CF_UNICODETEXT)</span><br></pre></td></tr></table></figure>
<p>这行代码从剪贴板中获取 Unicode 文本数据。</p>
<p>构建源数据字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source_data = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;txt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行代码将获取到的文本数据封装成一个字典，其中 type 表示数据类型为文本，content 是文本的具体内容。</p>
<p>处理数据并写入文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_data = get_line(self, source_data, self.display)</span><br><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这行代码调用 get_line 方法处理 source_data，并将处理后的数据转换为 JSON 格式，然后写入到输出文件中。</p>
<p>关闭剪贴板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">win32clipboard.CloseClipboard()</span><br></pre></td></tr></table></figure>
<p>这行代码关闭剪贴板，释放资源。</p>
<p>处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    setting.log.info(<span class="string">&quot;剪切板当中没有文本数据！&quot;</span>)</span><br><span class="line">    self.paste_pic()</span><br></pre></td></tr></table></figure>
<p>这行代码捕获所有异常，并记录错误信息。如果剪贴板中没有文本数据，它会调用 self.paste_pic() 方法尝试获取图像数据并进行处理。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10取证基础之历史打开文档记录编码</title>
    <url>/2022/11/26/%E5%8F%96%E8%AF%81-%E5%8E%86%E5%8F%B2%E6%89%93%E5%BC%80%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>最近在<code>win10</code>上做取证相关的东西，记录一下一些有意思的东西，比如想要获取电脑的历史打开文档。这里有两个办法：</p>
<ul>
<li><code>win+r</code>输入<code>recent</code>查看</li>
<li>注册表编辑器输入路径：<code>计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs</code></li>
</ul>
<p>在处理注册表编辑器的时候，发现这个路径下的数据是编码，但是找了很久也没找到怎么去解码，有幸在别人的项目中找到了一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode_recent_docs_mru</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decodes recent docs MRU list</span></span><br><span class="line"><span class="string">    Returns an array with 1st element being the filename, the second element being the symbolic link name</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    value_decoded = []</span><br><span class="line">    index = value.find(<span class="string">b&quot;\x00\x00&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        </span><br><span class="line">        decoded = value[<span class="number">0</span>:index + <span class="number">1</span>].decode(<span class="string">&quot;utf-16-le&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            decoded = value[<span class="number">0</span>:index + <span class="number">1</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            decoded = <span class="string">&quot;&quot;</span>.join([c <span class="keyword">for</span> c <span class="keyword">in</span> value[<span class="number">0</span>:index + <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    value_decoded.append(decoded)</span><br><span class="line">    <span class="comment"># index+3 because the last char also ends with \x00 + null bytes \x00\x00, +14 is the offset for the link name</span></span><br><span class="line">    index_end_link_name = value.find(<span class="string">b&quot;\x00&quot;</span>, index + <span class="number">3</span> + <span class="number">14</span>)</span><br><span class="line">    value_decoded.append(value[index + <span class="number">3</span> + <span class="number">14</span>:index_end_link_name])</span><br><span class="line">    <span class="keyword">return</span> value_decoded</span><br></pre></td></tr></table></figure>

<p>需要注意的是，不是所有的文本都能够被正常解码，目前为止，都还是会出现乱码的情况。问题还在解决。。。</p>
<p><a href="https://github.com/SekoiaLab/Fastir_Collector">Github地址</a></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Win10取证</tag>
        <tag>历史记录</tag>
      </tags>
  </entry>
  <entry>
    <title>windows取证基础之命名管道获取</title>
    <url>/2022/11/28/%E5%8F%96%E8%AF%81-%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<p>“命名管道”又名“命名管线”（Named Pipes），是一种简单的进程间通信（IPC）机制，Microsoft Windows大都提供了对它的支持（但不包括Windows CE）。命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信。推荐用命名管道作为进程通信方案的一项重要的原因是它们充分利用了Windows内建的安全特性（ACL等）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">look_for_files</span>(<span class="params">dir_to_look</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Looks for windows in a given directory. Supports the * wildcard character&quot;&quot;&quot;</span></span><br><span class="line">    found_files = []</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;*&quot;</span> <span class="keyword">in</span> dir_to_look:</span><br><span class="line">        found_files += glob.glob(dir_to_look)</span><br><span class="line">    <span class="keyword">elif</span> os.path.exists(dir_to_look):</span><br><span class="line">        found_files.append(dir_to_look)</span><br><span class="line">    <span class="keyword">return</span> found_files</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> look_for_files(<span class="string">&#x27;\\\\.\\pipe\\*&#x27;</span>):</span><br><span class="line">        <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> test():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Win10取证</tag>
        <tag>命名管道</tag>
      </tags>
  </entry>
  <entry>
    <title>开机自启动</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><p>自启动程序是指在系统启动时自动运行的程序。这些程序可能会影响系统的启动速度和性能，因此了解如何获取和管理这些程序是非常重要的。本文将介绍一种使用 Python 实现的方法，通过调用系统命令和处理 CSV 文件来获取自启动程序的信息。</p>
<h2 id="windows代码实现"><a href="#windows代码实现" class="headerlink" title="windows代码实现"></a>windows代码实现</h2><p>确定 autorunsc 程序的名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">autorunsc_name = <span class="string">&quot;autorunsc64.exe&quot;</span> <span class="keyword">if</span> platform.architecture()[<span class="number">0</span>] == <span class="string">&quot;64bit&quot;</span> <span class="keyword">else</span> <span class="string">&quot;autorunsc32.exe&quot;</span></span><br></pre></td></tr></table></figure>

<p>这行代码根据当前系统的架构（64 位或 32 位）来确定 autorunsc 程序的文件名。<br>终止正在运行的 autorunsc 进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> psutil.process_iter():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name = process.name()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> name == autorunsc_name:</span><br><span class="line">            process.terminate()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        setting.log.error(<span class="string">&quot;终止垃圾进程失败,原因: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(e)))</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>这段代码遍历所有正在运行的进程，尝试终止名为 autorunsc 的进程，以确保没有其他实例在运行。</p>
<p>执行 autorunsc 命令并保存结果到临时文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">autoruns_path = os.path.join(setting.PROJ_PATH, autorunsc_name)</span><br><span class="line">result_temp_path = os.path.join(setting.PROJ_PATH, <span class="string">&#x27;res_h.csv&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&quot;&#123;&#125; /accepteula -a h -s -h -ct &gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(autoruns_path, result_temp_path))</span><br></pre></td></tr></table></figure>
<p>这行代码执行 autorunsc 命令，并将结果保存到一个临时的 CSV 文件中。</p>
<p>处理 CSV 文件中的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(result_temp_path, <span class="string">&quot;rt&quot;</span>, encoding=<span class="string">&quot;UTF-16&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv.DictReader(f, delimiter=<span class="string">&quot;\t&quot;</span>):</span><br><span class="line">        clean_data = get_line(self, row, self.display_list)</span><br><span class="line">        data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这段代码打开临时 CSV 文件，逐行读取数据，并使用 get_line 函数处理每一行数据。处理后的数据被转换为 JSON 格式，并写入到输出文件中。</p>
<p>删除临时文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(result_temp_path)</span><br></pre></td></tr></table></figure>
<p>最后，这行代码删除临时 CSV 文件，以保持文件系统的整洁。</p>
<p>这个方法通过调用 autorunsc 命令获取 Windows 自启动程序的信息，并将这些信息处理后写入到指定的文件中。</p>
<h2 id="Linux代码实现"><a href="#Linux代码实现" class="headerlink" title="Linux代码实现"></a>Linux代码实现</h2><p>下面是对代码的详细解释：<br>执行 systemctl list-unit-files 命令并获取结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res_list = exe_cmd(<span class="string">&quot;systemctl list-unit-files&quot;</span>).split(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码执行 systemctl list-unit-files 命令，并将结果按行分割成列表。</p>
<p>遍历结果列表，处理每一行数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> res_list[<span class="number">1</span>:-<span class="number">2</span>:]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        line = line.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">3</span>:</span><br><span class="line">            name, state, _ = line</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            name, state = line</span><br><span class="line"></span><br><span class="line">        source_data = &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: name,</span><br><span class="line">            <span class="string">&quot;State&quot;</span>: state</span><br><span class="line">        &#125;</span><br><span class="line">        clean_data = get_line(self, source_data, self.display)</span><br><span class="line">        data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        write_file(self.file, data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        setting.log.error(<span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<p>这段代码遍历结果列表，跳过第一行和最后两行，因为它们不包含服务信息。对于每一行数据，它尝试将其分割成两部分或三部分（取决于是否有额外的信息），然后将服务名和状态保存到 source_data 字典中。接着，它调用 get_line 函数处理 source_data，并将处理后的数据转换为 JSON 格式，最后写入到输出文件中。如果在处理过程中遇到异常，它会记录错误信息。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python注册windows服务</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E6%B3%A8%E5%86%8Cwindows%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="如何使用Python和instsrv-exe-srvany-exe创建Windows服务"><a href="#如何使用Python和instsrv-exe-srvany-exe创建Windows服务" class="headerlink" title="如何使用Python和instsrv.exe/srvany.exe创建Windows服务"></a>如何使用Python和instsrv.exe/srvany.exe创建Windows服务</h2><p>该博客将探讨如何使用Python脚本结合instsrv.exe和srvany.exe工具将任何程序转换为Windows服务。这不仅有助于程序以SYSTEM账户运行，还能实现随机器启动而自启动，并且可以隐藏不必要的窗口。以下是详细的步骤和代码示例。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Windows系统中，服务是一种特殊类型的程序，它在后台运行，通常没有用户界面。通过将程序转换为服务，我们可以确保程序在系统启动时自动运行，并且可以在后台持续运行，不受用户登录状态的影响。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始之前，你需要确保你的系统中安装了以下工具：</p>
<ol>
<li><strong>instsrv.exe</strong> 和 <strong>srvany.exe</strong>：这两个工具是Microsoft Windows Resource Kits的一部分，用于安装和卸载服务。</li>
<li><strong>Python</strong>：我们将使用Python编写脚本，因此需要确保Python环境已安装。</li>
</ol>
<h2 id="安装和配置服务"><a href="#安装和配置服务" class="headerlink" title="安装和配置服务"></a>安装和配置服务</h2><p>首先，我们需要将<code>instsrv.exe</code>和<code>srvany.exe</code>复制到<code>C:\Windows\System32\</code>目录下（对于64位系统，还需要复制到<code>C:\Windows\SysWow64\</code>目录）。接下来，我们将编写一个Python脚本来检查特定服务是否正在运行，并在未运行时启动该服务。</p>
<h2 id="Python脚本详解"><a href="#Python脚本详解" class="headerlink" title="Python脚本详解"></a>Python脚本详解</h2><p>以下是Python脚本的详细解释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">import</span> wmi</span><br><span class="line"><span class="keyword">import</span> winreg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    检查特定服务是否正在运行，如果没有，它会通过执行一些命令来启动该服务并退出程序。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">getattr</span>(sys, <span class="string">&quot;frozen&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">            pro_path = os.path.normpath(os.path.join(</span><br><span class="line">                sys.executable,</span><br><span class="line">                os.pardir,  <span class="comment"># 上一级目录(..)</span></span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pro_path = os.path.normpath(os.path.join(</span><br><span class="line">                os.path.abspath(__file__),</span><br><span class="line">                os.pardir,  <span class="comment"># 上一级目录(..)</span></span><br><span class="line">                os.pardir</span><br><span class="line">            ))</span><br><span class="line">        processes = []</span><br><span class="line">        <span class="keyword">for</span> proc <span class="keyword">in</span> psutil.process_iter():</span><br><span class="line">            processes.append(proc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查系统上是否正在运行名为“ssguard”的服务。</span></span><br><span class="line">        <span class="comment"># 如果未找到该服务，它将继续使用“instsrv.exe”和“srvany.exe”实用程序安装和配置该服务。</span></span><br><span class="line">        <span class="comment"># 然后，它为该服务创建一个注册表项并设置一些参数，例如应用程序路径和目录。最后，它使用“sc start”命令启动服务</span></span><br><span class="line">        <span class="comment"># 并退出程序。</span></span><br><span class="line">        wmiobj = wmi.WMI()</span><br><span class="line">        services = wmiobj.Win32_Service()</span><br><span class="line">        server_name = <span class="string">&quot;ssguard&quot;</span></span><br><span class="line">        <span class="keyword">if</span> server_name <span class="keyword">not</span> <span class="keyword">in</span> [i.Name <span class="keyword">for</span> i <span class="keyword">in</span> services]:</span><br><span class="line">            instsrv_path = os.path.join(pro_path, <span class="string">&quot;utils&quot;</span>, <span class="string">&quot;instsrv.exe&quot;</span>)</span><br><span class="line">            srvany_path = os.path.join(pro_path, <span class="string">&quot;utils&quot;</span>, <span class="string">&quot;srvany.exe&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">in</span> instsrv_path <span class="keyword">and</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">in</span> srvany_path:</span><br><span class="line">                os.system(<span class="string">f&#x27;&quot;<span class="subst">&#123;instsrv_path&#125;</span>&quot; <span class="subst">&#123;server_name&#125;</span> &quot;<span class="subst">&#123;srvany_path&#125;</span>&quot;&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">in</span> instsrv_path:</span><br><span class="line">                os.system(<span class="string">f&#x27;&quot;<span class="subst">&#123;instsrv_path&#125;</span>&quot; <span class="subst">&#123;server_name&#125;</span> <span class="subst">&#123;srvany_path&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">in</span> srvany_path:</span><br><span class="line">                os.system(<span class="string">f&#x27;<span class="subst">&#123;instsrv_path&#125;</span> <span class="subst">&#123;server_name&#125;</span> &quot;<span class="subst">&#123;srvany_path&#125;</span>&quot;&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.system(<span class="string">f&#x27;<span class="subst">&#123;instsrv_path&#125;</span> <span class="subst">&#123;server_name&#125;</span> <span class="subst">&#123;srvany_path&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;执行命令:&quot;</span>, <span class="string">f&#x27;<span class="subst">&#123;instsrv_path&#125;</span> <span class="subst">&#123;server_name&#125;</span> <span class="subst">&#123;srvany_path&#125;</span>&#x27;</span>)</span><br><span class="line">            root_key = winreg.OpenKey(</span><br><span class="line">                winreg.HKEY_LOCAL_MACHINE, <span class="string">r&quot;SYSTEM\CurrentControlSet\Services&quot;</span>)</span><br><span class="line">            server = winreg.CreateKey(root_key, server_name)</span><br><span class="line">            parameters = winreg.CreateKey(server, <span class="string">&quot;Parameters&quot;</span>)</span><br><span class="line">            winreg.SetValueEx(parameters, <span class="string">&quot;Application&quot;</span>, <span class="number">0</span>, winreg.REG_SZ,</span><br><span class="line">                              os.path.join(pro_path, <span class="string">&quot;deploymenttools.exe&quot;</span>))</span><br><span class="line">            winreg.SetValueEx(parameters, <span class="string">&quot;AppDirectory&quot;</span>,</span><br><span class="line">                              <span class="number">0</span>, winreg.REG_SZ, pro_path)</span><br><span class="line">            os.system(<span class="string">&quot;sc start ssguard&quot;</span>)</span><br><span class="line">            sys.exit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(traceback.format_exc())</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><strong>路径获取</strong>：首先，我们获取当前Python脚本的路径，这将用于定位<code>instsrv.exe</code>和<code>srvany.exe</code>工具。</li>
<li><strong>服务检查</strong>：使用<code>wmi</code>模块检查名为<code>ssguard</code>的服务是否正在运行。</li>
<li><strong>服务安装</strong>：如果服务未运行，使用<code>instsrv.exe</code>安装服务，并指定<code>srvany.exe</code>作为服务外壳。</li>
<li><strong>注册表配置</strong>：在注册表中设置服务的参数，包括应用程序路径和目录。</li>
<li><strong>服务启动</strong>：使用<code>sc start</code>命令启动服务。</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过上述步骤和代码，可以轻松地将任何程序转换为Windows服务，实现自动启动和后台运行。这种方法不仅提高了程序的稳定性和可用性，还有助于隐藏不必要的用户界面，使系统更加整洁。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器历史记录</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="浏览器历史记录"><a href="#浏览器历史记录" class="headerlink" title="浏览器历史记录"></a>浏览器历史记录</h2><p>浏览器历史记录会以db后缀文件的形式，以明文存放在本地目录，用户可以通过解析这个文件查看浏览器最近访问，包括访问时间，网站图标等等。chrome内核的浏览器跟Firefox浏览器虽然都是保存在db文件中，但是数据结构完全不一样，需要做区分处理。</p>
<h2 id="chrome浏览器"><a href="#chrome浏览器" class="headerlink" title="chrome浏览器"></a>chrome浏览器</h2><p>获取所有用户信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> wmi.WMI().Win32_UserAccount():</span><br><span class="line">    user_name = user.Name</span><br></pre></td></tr></table></figure>
<p>这行代码使用 wmi 模块获取所有用户账户信息，并遍历这些信息，提取每个用户的用户名。</p>
<p>初始化 MD5 列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md5_list = []</span><br></pre></td></tr></table></figure>
<p>这行代码创建了一个空列表，用于存储已经处理过的历史记录文件的 MD5 值，以避免重复处理。</p>
<p>获取每个用户的历史记录文件路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> self.get_path(user_name):</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>这行代码调用 self.get_path(user_name) 方法获取指定用户的历史记录文件路径，并遍历这些路径。如果路径是一个目录，则跳过。</p>
<p>计算文件的 MD5 值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md5_str = get_md5(path=path)</span><br><span class="line"><span class="keyword">if</span> md5_str <span class="keyword">in</span> md5_list:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    md5_list.append(md5_str)</span><br></pre></td></tr></table></figure>
<p>这行代码计算文件的 MD5 值，并检查这个值是否已经在 md5_list 中。如果是，则跳过这个文件；如果不是，则将这个值添加到 md5_list 中。</p>
<p>复制文件并连接到数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setting.log.info(<span class="string">&quot;正在处理: %s&quot;</span> % path)</span><br><span class="line">tmp_path = path + <span class="string">&quot;.backup&quot;</span></span><br><span class="line">shutil.copyfile(path, tmp_path)</span><br><span class="line">conn = sqlite3.connect(tmp_path)</span><br><span class="line">cur = conn.cursor()</span><br></pre></td></tr></table></figure>
<p>这行代码将历史记录文件复制到一个临时文件，并连接到这个临时文件的 SQLite 数据库。</p>
<p>查询历史记录数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> time, url, title <span class="keyword">in</span> cur.execute(</span><br><span class="line">        (<span class="string">&#x27;SELECT visits.visit_time,urls.url, urls.title FROM urls, visits WHERE urls.id = visits.url&#x27;</span>)):</span><br><span class="line">    source_data = &#123;</span><br><span class="line">        <span class="string">&quot;Time&quot;</span>: time,</span><br><span class="line">        <span class="string">&quot;URL&quot;</span>: url,</span><br><span class="line">        <span class="string">&quot;Title&quot;</span>: title</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这行代码执行一个 SQL 查询，从数据库中获取历史记录的时间、URL 和标题，并将这些信息存储在 source_data 字典中。</p>
<p>处理数据并写入文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_data = get_line(self,source_data, self.display)</span><br><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file,data)</span><br></pre></td></tr></table></figure>
<p>这行代码调用 get_line 方法处理 source_data，并将处理后的数据转换为 JSON 格式，然后写入到输出文件中。</p>
<p>关闭数据库连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>这行代码关闭数据库连接。</p>
<p>处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    setting.log.error(<span class="string">&quot;处理失败, 原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>
<p>这行代码捕获所有异常，并记录错误信息。</p>
<h2 id="Firefox浏览器"><a href="#Firefox浏览器" class="headerlink" title="Firefox浏览器"></a>Firefox浏览器</h2><p>获取所有用户信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> wmi.WMI().Win32_UserAccount():</span><br><span class="line">    user_name = user.Name</span><br></pre></td></tr></table></figure>
<p>这行代码使用 wmi 模块获取所有用户账户信息，并遍历这些信息，提取每个用户的用户名。</p>
<p>初始化 MD5 列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md5_list = []</span><br></pre></td></tr></table></figure>
<p>这行代码创建了一个空列表，用于存储已经处理过的历史记录文件的 MD5 值，以避免重复处理。</p>
<p>获取每个用户的历史记录文件路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> self.get_path(user_name):</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>这行代码调用 self.get_path(user_name) 方法获取指定用户的历史记录文件路径，并遍历这些路径。如果路径是一个目录，则跳过。</p>
<p>计算文件的 MD5 值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md5_str = get_md5(path=path)</span><br><span class="line"><span class="keyword">if</span> md5_str <span class="keyword">in</span> md5_list:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    md5_list.append(md5_str)</span><br></pre></td></tr></table></figure>
<p>这行代码计算文件的 MD5 值，并检查这个值是否已经在 md5_list 中。如果是，则跳过这个文件；如果不是，则将这个值添加到 md5_list 中。</p>
<p>复制文件并连接到数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setting.log.info(<span class="string">&quot;正在处理: %s&quot;</span> % path)</span><br><span class="line">tmp_path = path + <span class="string">&quot;.backup&quot;</span></span><br><span class="line">shutil.copyfile(path, tmp_path)</span><br><span class="line">conn = sqlite3.connect(tmp_path)</span><br><span class="line">cur = conn.cursor()</span><br></pre></td></tr></table></figure>
<p>这行代码将历史记录文件复制到一个临时文件，并连接到这个临时文件的 SQLite 数据库。</p>
<p>查询历史记录数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> time, url, title <span class="keyword">in</span> cur.execute(</span><br><span class="line">        (<span class="string">&#x27;SELECT moz_historyvisits.visit_date, moz_places.url, moz_places.title FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id&#x27;</span>)):</span><br><span class="line">    source_data = &#123;</span><br><span class="line">        <span class="string">&quot;Time&quot;</span>: time,</span><br><span class="line">        <span class="string">&quot;URL&quot;</span>: url,</span><br><span class="line">        <span class="string">&quot;Title&quot;</span>: title</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这行代码执行一个 SQL 查询，从数据库中获取历史记录的时间、URL 和标题，并将这些信息存储在 source_data 字典中。</p>
<p>处理数据并写入文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_data = get_line(self,source_data, self.display)</span><br><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file,data)</span><br></pre></td></tr></table></figure>
<p>这行代码调用 get_line 方法处理 source_data，并将处理后的数据转换为 JSON 格式，然后写入到输出文件中。</p>
<p>关闭数据库连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>这行代码关闭数据库连接。</p>
<p>处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    setting.log.error(<span class="string">&quot;处理失败, 原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>
<p>这行代码捕获所有异常，并记录错误信息。</p>
<h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p><code>glob.glob(path, recursive=True)</code> 是 <code>Python</code> 中 <code>glob</code> 模块的一个函数，用于根据指定的路径模式搜索文件和目录。这个函数的主要作用是匹配符合特定模式的文件路径，并返回一个列表，其中包含所有匹配的文件和目录的路径。</p>
<p>参数解释：</p>
<ul>
<li><code>path</code>: 一个字符串，表示要搜索的路径模式。这个模式可以包含通配符，如 *、? 和 []，用于匹配文件名或目录名的一部分。</li>
<li><code>recursive=True</code>: 一个布尔值，表示是否递归搜索子目录。如果设置为 <code>True</code>，则函数会搜索指定目录及其所有子目录中的文件；如果设置为 <code>False</code>，则只搜索指定目录中的文件。</li>
</ul>
<p>使用示例：</p>
<p>假设我们有一个目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\username\Documents\</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br><span class="line">└── subfolder\</span><br><span class="line">    ├── file3.txt</span><br><span class="line">    └── file4.txt</span><br></pre></td></tr></table></figure>
<p>如果我们使用 <code>glob.glob(path, recursive=True)</code> 来搜索这个目录，其中 <code>path</code> 是 <code>&quot;C:\\Users\\username\\Documents\\**\\*.txt&quot;</code>，那么它将返回以下列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;C:\\Users\\username\\Documents\\file1.txt&quot;</span>,</span><br><span class="line"> <span class="string">&quot;C:\\Users\\username\\Documents\\file2.txt&quot;</span>,</span><br><span class="line"> <span class="string">&quot;C:\\Users\\username\\Documents\\subfolder\\file3.txt&quot;</span>,</span><br><span class="line"> <span class="string">&quot;C:\\Users\\username\\Documents\\subfolder\\file4.txt&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这个列表包含了所有以 .txt 结尾的文件的路径，包括在子目录 <code>subfolder</code> 中的文件。</p>
<p>注意事项：</p>
<blockquote>
<ul>
<li><code>glob.glob</code> 函数返回的路径是字符串形式，并且是绝对路径（如果 <code>path</code> 是绝对路径）或相对于当前工作目录的路径（如果 <code>path</code> 是相对路径）。</li>
<li>如果 <code>path</code> 中的模式包含特殊字符，如 *、? 和 []，它们将被解释为通配符，用于匹配文件名或目录名的一部分。</li>
<li>如果 <code>recursive</code> 参数设置为 <code>True</code>，则搜索是递归的，这可能会导致性能问题，特别是在处理大型目录结构时。</li>
</ul>
</blockquote>
<p>我的代码中，<code>glob.glob(path, recursive=True)</code> 用于在指定的用户目录下搜索所有包含 <code>Chrome</code> 关键字的目录，并查找其中名为 <code>History</code> 的文件。如果找到了这样的文件，它的路径将被添加到 <code>files</code> 列表中。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10取证基础之浏览器记录</title>
    <url>/2022/11/26/%E5%8F%96%E8%AF%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>在<code>win10</code>当中，浏览器无论安装在那里其历史记录的存放点都是一样的，且内核一样的浏览器其历史记录格式也是一样的。因此可以轻松查询浏览器历史记录。</p>
<blockquote>
<p>浏览器正在使用当中的时候不能够进行历史记录获取操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bro_history</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.systemroot = os.environ[<span class="string">&quot;SYSTEMROOT&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_firefox_history</span>(<span class="params">self, path</span>):</span><br><span class="line">        path = os.path.join(self.systemroot, path)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> glob.glob(path):</span><br><span class="line">            p_tokens = p.split(<span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">            user = p_tokens[<span class="number">2</span>]</span><br><span class="line">            profile = p_tokens[<span class="built_in">len</span>(p_tokens) - <span class="number">2</span>]</span><br><span class="line">            con = sqlite3.connect(p)</span><br><span class="line">            cur = con.cursor()</span><br><span class="line">            <span class="keyword">for</span> time, url <span class="keyword">in</span> cur.execute(</span><br><span class="line">                    (<span class="string">&quot;SELECT datetime(moz_historyvisits.visit_date/1000000, &#x27;unixepoch&#x27;, &#x27;localtime&#x27;), moz_places.url &quot;</span></span><br><span class="line">                        <span class="string">&quot;FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id;&quot;</span>)):</span><br><span class="line">                <span class="keyword">yield</span> time, url, user, profile</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_chrome_history</span>(<span class="params">self, path</span>):</span><br><span class="line">        path = os.path.join(self.systemroot, path)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> glob.glob(path):</span><br><span class="line">            p_tokens = p.split(<span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">            user = p_tokens[<span class="number">2</span>]</span><br><span class="line">            profile = p_tokens[<span class="built_in">len</span>(p_tokens) - <span class="number">2</span>]</span><br><span class="line">            con = sqlite3.connect(p)</span><br><span class="line">            cur = con.cursor()</span><br><span class="line">            <span class="built_in">print</span>(p)</span><br><span class="line">            <span class="keyword">for</span> time, url, title <span class="keyword">in</span> cur.execute(</span><br><span class="line">                    (<span class="string">&#x27;SELECT datetime(((visits.visit_time/1000000)-11644473600), &quot;unixepoch&quot;), &#x27;</span></span><br><span class="line">                        <span class="string">&#x27;urls.url, urls.title FROM urls, visits WHERE urls.id = visits.url;&#x27;</span>)):</span><br><span class="line">                <span class="keyword">yield</span> time, url, title, user, profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = bro_history()</span><br><span class="line"><span class="comment"># 谷歌浏览器</span></span><br><span class="line"><span class="comment"># for i in test._chrome_history(&#x27;\\Users\\*\\AppData\\Local\\Google\\Chrome\\User Data\\*\\History&#x27;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment"># 火狐浏览器</span></span><br><span class="line"><span class="comment"># for i in _firefox_history(&#x27;\\Users\\*\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\*.default\\places.sqlite&#x27;)</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment"># QQ浏览器</span></span><br><span class="line"><span class="comment"># for i in test._chrome_history(&#x27;\\Users\\*\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\*\\History&#x27;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment"># Edge浏览器</span></span><br><span class="line"><span class="comment"># for i in test._chrome_history(&#x27;\\Users\\*\\AppData\\Local\\Microsoft\\Edge\\User Data\\*\\History&#x27;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment"># brave浏览器</span></span><br><span class="line"><span class="comment"># for i in test._chrome_history(&#x27;\\Users\\*\\AppData\\Local\\BraveSoftware\\Brave-Browser-Beta\\User Data\\*\\History&#x27;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment"># Opera浏览器</span></span><br><span class="line"><span class="comment"># for i in test._chrome_history(&#x27;\\Users\\*\\AppData\\Roaming\\Opera Software\\Opera Stable\\History&#x27;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment"># Vivaldi浏览器</span></span><br><span class="line"><span class="comment"># for i in test._chrome_history(&#x27;\\Users\\*\\AppData\\Local\\Vivaldi\\User Data\\*\\History&#x27;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment"># 360浏览器</span></span><br><span class="line"><span class="comment"># for i in test._chrome_history(&#x27;\\Users\\*\\AppData\\Roaming\\360se6\\User Data\\*\\360History&#x27;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br></pre></td></tr></table></figure>

<p>比较有意思的是，在获取浏览器历史记录的时候由于知道浏览器历史记录的存放点，QQ浏览器竟然在没有经过我同意的情况下读取了谷歌浏览器的历史记录，并且堂而皇之的放到了自己的历史记录当中。QQ浏览器是真的6</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Win10取证</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>百度网盘windows取证</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/</url>
    <content><![CDATA[<h2 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h2><p>在windows操作系统当中，当安装了百度网盘之后，BaiduYunCacheFileV0当中会保存百度网盘的所有文件信息以及文件下载上传记录，即时没办法登录百度网盘也能够通过BaiduYunCacheFileV0获取全部信息。以下将展示基于python实现的百度网盘信息获取。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是对代码的详细解释</p>
<p>获取百度网盘安装目录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users_path = os.path.join(self.get_baidu_pan_install_dir(), <span class="string">&quot;users&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码调用 get_baidu_pan_install_dir 方法获取百度网盘的安装目录，并拼接上 “users” 文件夹的路径，得到用户文件夹的路径。</p>
<p>遍历用户文件夹：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> md5 <span class="keyword">in</span> os.listdir(users_path):</span><br><span class="line">    md5_path = os.path.join(users_path, md5)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(md5_path):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(md5_path):</span><br></pre></td></tr></table></figure>
<p>这段代码遍历用户文件夹中的每个子文件夹（以 MD5 值命名），并进一步遍历每个子文件夹中的文件和文件夹。</p>
<p>处理用户文件夹：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i!= <span class="string">&quot;AutoBackupFileList&quot;</span> <span class="keyword">and</span> os.path.isdir(os.path.join(md5_path, i)):</span><br><span class="line">    source_data = &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: i,</span><br><span class="line">        <span class="string">&quot;FilePath&quot;</span>: <span class="string">&quot;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&quot;ParentPath&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Size&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Md5&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;iconMd5&quot;</span>: <span class="string">&quot;folder&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpdateTime&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;User&quot;</span>: i</span><br><span class="line">    &#125;</span><br><span class="line">    user_path = <span class="string">&quot;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    clean_data = get_line(self, source_data, self.display)</span><br><span class="line">    data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这段代码处理用户文件夹，如果文件夹名不是 “AutoBackupFileList”，则创建一个包含文件夹信息的 source_data 字典，并将其写入到输出文件中。</p>
<p>判断数据库文件是否存在：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_file_db = os.path.join(md5_path, <span class="string">&quot;BaiduYunCacheFileV0.db&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(all_file_db):</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>这段代码检查每个用户文件夹中是否存在名为 “BaiduYunCacheFileV0.db” 的数据库文件，如果不存在，则跳过该用户文件夹。</p>
<p>读取数据库文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = sqlite3.connect(all_file_db)</span><br><span class="line">    conn.row_factory = self.dict_factory</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    <span class="comment"># 同理，上传下载分别是download_history_file、upload_history_file</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cursor.execute(<span class="string">&quot;select * from cache_file&quot;</span>):</span><br><span class="line">        parent_path = item.get(<span class="string">&quot;parent_path&quot;</span>)</span><br><span class="line">        server_filename = item.get(<span class="string">&quot;server_filename&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            iconMd5 = server_filename.split(<span class="string">&quot;.&quot;</span>, maxsplit=<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            iconMd5 = <span class="string">&quot;folder&quot;</span></span><br><span class="line">        source_data = &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: server_filename,</span><br><span class="line">            <span class="string">&quot;FilePath&quot;</span>: user_path + os.path.join(parent_path, server_filename),</span><br><span class="line">            <span class="string">&quot;ParentPath&quot;</span>: user_path + parent_path[:-<span class="number">1</span>:],</span><br><span class="line">            <span class="string">&quot;Size&quot;</span>: item.get(<span class="string">&quot;file_size&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Md5&quot;</span>: item.get(<span class="string">&quot;md5&quot;</span>),</span><br><span class="line">            <span class="string">&quot;iconMd5&quot;</span>: iconMd5,</span><br><span class="line">            <span class="string">&quot;ServerMtime&quot;</span>: item.get(<span class="string">&quot;server_mtime&quot;</span>),</span><br><span class="line">            <span class="string">&quot;LocalMtime&quot;</span>: item.get(<span class="string">&quot;local_mtime&quot;</span>),</span><br><span class="line">            <span class="string">&quot;User&quot;</span>: i</span><br><span class="line">        &#125;</span><br><span class="line">        clean_data = get_line(self, source_data, self.display)</span><br><span class="line">        data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        write_file(self.file, data)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    setting.log.error(e)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这段代码尝试连接到数据库文件，并读取其中的 “cache_file” 表中的所有数据。对于每一条数据，它创建一个包含文件信息的 source_data 字典，并将其写入到输出文件中。如果在处理过程中遇到异常，它会记录错误信息并跳过当前用户文件夹。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10取证基础之系统日志分析1</title>
    <url>/2022/11/26/%E5%8F%96%E8%AF%81-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%901/</url>
    <content><![CDATA[<p>这段代码需要在管理员权限下才能运行，不然没有权限访问系统日志文件。其实直接读取也不会有什么问题，只是我个人为了安全起见，拷贝了一份。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes, sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> evtx <span class="keyword">import</span> PyEvtxParser</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    shutil.copy(<span class="string">&quot;C:/Windows/System32/winevt/Logs/System.evtx&quot;</span>, <span class="string">&quot;D:/项目/Windows取证/data_file/System.evtx&quot;</span>)</span><br><span class="line">    parser = PyEvtxParser(<span class="string">&quot;D:/项目/Windows取证/data_file/System.evtx&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> parser.records():</span><br><span class="line">        <span class="keyword">if</span> record[<span class="string">&quot;event_record_id&quot;</span>] == <span class="number">6005</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Event Record ID: <span class="subst">&#123;record[<span class="string">&quot;event_record_id&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Event Timestamp: <span class="subst">&#123;record[<span class="string">&quot;timestamp&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(record[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Event Record ID: <span class="subst">&#123;record[<span class="string">&quot;event_record_id&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_admin</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ctypes.windll.shell32.IsUserAnAdmin()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Win10取证</tag>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10取证基础之系统日志分析2</title>
    <url>/2022/11/26/%E5%8F%96%E8%AF%81-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%902/</url>
    <content><![CDATA[<p>之前的时候为了解析系统的日志文件找库，找了之后又遇到不少问题，使用起来并不方便，然后就知道了原来是可以通过官方接口直接获取的，绝了….</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32evtlog </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hand = win32evtlog.OpenEventLog(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;System&quot;</span>)</span><br><span class="line">flags = win32evtlog.EVENTLOG_SEQUENTIAL_READ|win32evtlog.EVENTLOG_FORWARDS_READ</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events = win32evtlog.ReadEventLog(hand, flags,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> events:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">            EventID = event.EventID &amp; <span class="number">0x1FFFFFFF</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Event ID:&#x27;</span>, event.EventID &amp; <span class="number">0x1FFFFFFF</span>) <span class="comment"># 事件标识id</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Event Type&#x27;</span>,event.EventType)<span class="comment"># 事件等级</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Event Category&#x27;</span>,event.EventCategory) <span class="comment"># 事件类别</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;ComputerName&#x27;</span>, event.ComputerName) <span class="comment"># 电脑名字</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Time Generated&#x27;</span>, event.TimeGenerated) <span class="comment"># 生成时间</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Time Written&#x27;</span>, event.TimeWritten) <span class="comment"># 写入时间</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;source&#x27;</span>,event.SourceName) <span class="comment"># 来源</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;RecordNumber&#x27;</span>,event.RecordNumber)<span class="comment"># 记录编号</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Source Name&#x27;</span>,event.SourceName) <span class="comment"># 来源名</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Event Data&#x27;</span>,event.Data) <span class="comment"># 事件信息</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>但是这个并不完整，有很多其实获取不到，比如进程id之类的，因此有另一个解决方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32evtlog</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># open event file</span></span><br><span class="line">query_handle = win32evtlog.EvtQuery(<span class="string">&#x27;D:/**/System.evtx&#x27;</span>,</span><br><span class="line">    win32evtlog.EvtQueryFilePath)</span><br><span class="line"></span><br><span class="line">read_count = <span class="number">0</span></span><br><span class="line">att_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events = win32evtlog.EvtNext(query_handle, <span class="number">100</span>)</span><br><span class="line">    read_count += <span class="built_in">len</span>(events)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(events) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">        xml_content = win32evtlog.EvtRender(event, win32evtlog.EvtRenderEventXml)</span><br><span class="line">        xml = ET.fromstring(xml_content)</span><br><span class="line">        ns = <span class="string">&#x27;&#123;http://schemas.microsoft.com/win/2004/08/events/event&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">        event_id = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>EventID&#x27;</span>).text</span><br><span class="line">        Version = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Version&#x27;</span>).text</span><br><span class="line">        level = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Level&#x27;</span>).text</span><br><span class="line">        Task = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Task&#x27;</span>).text</span><br><span class="line">        Opcode = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Opcode&#x27;</span>).text</span><br><span class="line">        Keywords = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Keywords&#x27;</span>).text</span><br><span class="line">        TimeCreated = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>TimeCreated&#x27;</span>).get(<span class="string">&#x27;SystemTime&#x27;</span>)</span><br><span class="line">        EventRecordID = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>EventRecordID&#x27;</span>).text</span><br><span class="line">        execution = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Execution&#x27;</span>)</span><br><span class="line">        process_id = execution.get(<span class="string">&#x27;ProcessID&#x27;</span>)</span><br><span class="line">        thread_id = execution.get(<span class="string">&#x27;ThreadID&#x27;</span>)</span><br><span class="line">        channel = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Channel&#x27;</span>).text</span><br><span class="line">        Computer = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Computer&#x27;</span>).text</span><br><span class="line">        EventData_list = [&#123;i.attrib.get(<span class="string">&#x27;Name&#x27;</span>):i.text&#125; <span class="keyword">for</span> i <span class="keyword">in</span> xml.findall(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>Data&#x27;</span>)]</span><br><span class="line">        user_data = xml.find(<span class="string">f&#x27;.//<span class="subst">&#123;ns&#125;</span>UserData&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> event_id == <span class="string">&#x27;******&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(&#123;<span class="string">&#x27;event_id&#x27;</span>:event_id,<span class="string">&#x27;Version&#x27;</span>:Version,<span class="string">&#x27;level&#x27;</span>:level,</span><br><span class="line">                    <span class="string">&#x27;Task&#x27;</span>:Task,<span class="string">&#x27;Opcode&#x27;</span>:Opcode,<span class="string">&#x27;Keywords&#x27;</span>:Keywords,</span><br><span class="line">                    <span class="string">&#x27;TimeCreated&#x27;</span>:TimeCreated,<span class="string">&#x27;EventRecordID&#x27;</span>:EventRecordID,</span><br><span class="line">                    <span class="string">&#x27;process_id&#x27;</span>:process_id,<span class="string">&#x27;thread_id&#x27;</span>:thread_id,<span class="string">&#x27;channel&#x27;</span>:channel,</span><br><span class="line">                    <span class="string">&#x27;Computer&#x27;</span>:Computer,<span class="string">&#x27;EventData_list&#x27;</span>:EventData_list,<span class="string">&#x27;user_data&#x27;</span>:user_data&#125;)</span><br><span class="line">            att_count+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># user_data has possible any data</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Read <span class="subst">&#123;read_count&#125;</span> records ----<span class="subst">&#123;att_count&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个方案就能够直接拿到原始结构解析数据。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Win10取证</tag>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>在windows中获取硬件信息</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>遍历系统中的所有逻辑设备：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> device <span class="keyword">in</span> wmi.WMI().CIM_LogicalDevice():</span><br></pre></td></tr></table></figure>
<p>这部分代码使用 wmi 模块遍历系统中的所有逻辑设备。</p>
<p>提取每个逻辑设备的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = &#123;</span><br><span class="line">    <span class="string">&quot;PNPDeviceID&quot;</span>: device.PNPDeviceID <span class="keyword">if</span> <span class="built_in">hasattr</span>(device, <span class="string">&quot;PNPDeviceID&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Description&quot;</span>: device.Description <span class="keyword">if</span> <span class="built_in">hasattr</span>(device, <span class="string">&quot;Description&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Caption&quot;</span>: device.Caption <span class="keyword">if</span> <span class="built_in">hasattr</span>(device, <span class="string">&quot;Caption&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Manufacturer&quot;</span>: device.Manufacturer <span class="keyword">if</span> <span class="built_in">hasattr</span>(device, <span class="string">&quot;Manufacturer&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PNPClass&quot;</span>: device.PNPClass <span class="keyword">if</span> <span class="built_in">hasattr</span>(device, <span class="string">&quot;PNPClass&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ClassGuid&quot;</span>: device.ClassGuid <span class="keyword">if</span> <span class="built_in">hasattr</span>(device, <span class="string">&quot;ClassGuid&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码将每个逻辑设备的信息提取出来，并存储在一个字典 item 中。如果某个属性不存在，它会将该属性的值设置为空字符串。</p>
<p>处理获取到的逻辑设备信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_data = get_line(self, item, self.display_list)</span><br><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这部分代码调用 get_line 方法处理 item，并将处理后的数据转换为 JSON 格式。然后，它将 JSON 数据写入到输出文件中。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>windows软件安装记录</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="注册表Uninstall"><a href="#注册表Uninstall" class="headerlink" title="注册表Uninstall"></a>注册表Uninstall</h2><p><code>Microsoft\Windows\CurrentVersion\Uninstall</code> 是 Windows 注册表中的一个键（key），它包含了用户通过“控制面板”中的“程序和功能”（以前称为“添加或删除程序”）安装的所有应用程序的列表。这个注册表键位于 <code>HKEY_LOCAL_MACHINE</code> 分支下。</p>
<p>当你通过“程序和功能”卸载应用程序时，<code>Windows</code> 会在这个注册表键下为每个应用程序创建一个子键（<code>subkey</code>）。每个子键都包含了与该应用程序相关的卸载信息，包括：</p>
<ul>
<li>应用程序的显示名称</li>
<li>发行者</li>
<li>卸载字符串（Uninstall String），指向卸载程序的路径</li>
<li>版本号</li>
<li>安装源（安装介质的路径，如果是从网络或CD安装）</li>
<li>估计大小</li>
<li>安装日期</li>
<li>状态（是否已安装、正在安装等）</li>
<li>系统组件（是否是系统必需的应用程序）</li>
<li>其他与卸载相关的信息</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>初始化列表和集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key_list = []</span><br><span class="line">t = []  <span class="comment"># 去重列表</span></span><br></pre></td></tr></table></figure>
<p>这部分代码初始化了两个列表：<code>key_list</code> 用于存储打开的注册表键，<code>t</code> 用于存储已处理数据的MD5哈希值，用于去重。</p>
<p>尝试打开注册表键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sub_key = <span class="string">r&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall&quot;</span></span><br><span class="line">    setting.log.info(<span class="string">&quot;正在打开: HKEY_LOCAL_MACHINE\\%s&quot;</span> % sub_key)</span><br><span class="line">    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, sub_key)</span><br><span class="line">    key_list.append(key)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    setting.log.error(<span class="string">&quot;打开失败, 原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>
<p>这部分代码尝试打开注册表中的 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</code> 键，并将打开的键添加到 <code>key_list</code> 中。如果打开失败，会记录错误日志。</p>
<p>重复上述步骤，尝试打开其他注册表键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sub_key = <span class="string">r&quot;SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall&quot;</span></span><br><span class="line">    setting.log.info(<span class="string">&quot;正在打开: HKEY_LOCAL_MACHINE\\%s&quot;</span> % sub_key)</span><br><span class="line">    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, sub_key)</span><br><span class="line">    key_list.append(key)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    setting.log.error(<span class="string">&quot;打开失败, 原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sub_key = <span class="string">r&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall&quot;</span></span><br><span class="line">    setting.log.info(<span class="string">&quot;正在打开: HKEY_CURRENT_USER\\%s&quot;</span> % sub_key)</span><br><span class="line">    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, sub_key)</span><br><span class="line">    key_list.append(key)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    setting.log.error(<span class="string">&quot;打开失败, 原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>
<p>这部分代码重复上述步骤，尝试打开 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall</code> 和 <code>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</code> 键，并将打开的键添加到 <code>key_list</code> 中。如果打开失败，会记录错误日志。</p>
<p>遍历每个打开的注册表键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> key_list:</span><br><span class="line">    sub_num, _, _ = winreg.QueryInfoKey(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sub_num):</span><br><span class="line">        name = winreg.EnumKey(key, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            setting.log.info(<span class="string">&quot;正在打开: %s&quot;</span> % name)</span><br><span class="line">            key_1 = winreg.OpenKey(key, name)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            setting.log.error(<span class="string">&quot;打开失败, 原因: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            display_name = winreg.QueryValueEx(key_1, <span class="string">&quot;DisplayName&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            display_name = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            display_version = winreg.QueryValueEx(</span><br><span class="line">                key_1, <span class="string">&quot;DisplayVersion&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            display_version = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _, _, timestamp = winreg.QueryInfoKey(key_1)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            timestamp = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这部分代码遍历每个打开的注册表键，获取每个子键的名称，并尝试打开这些子键。然后，它尝试获取每个子键中的 <code>DisplayName</code>、<code>DisplayVersion</code> 和 <code>timestamp</code> 值。如果获取失败，会将相应的值设置为空字符串或0。</p>
<p>处理获取到的软件信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> display_name:</span><br><span class="line">    source_data = &#123;</span><br><span class="line">        <span class="string">&quot;DisplayName&quot;</span>: display_name,</span><br><span class="line">        <span class="string">&quot;InstallTime&quot;</span>: timestamp,</span><br><span class="line">        <span class="string">&quot;DisplayVersion&quot;</span>: display_version</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clean_data = get_line(self, source_data, self.display)</span><br><span class="line">    data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    md5 = get_md5(data)</span><br><span class="line">    <span class="keyword">if</span> md5 <span class="keyword">not</span> <span class="keyword">in</span> t:</span><br><span class="line">        write_file(self.file, data)</span><br><span class="line">        t.append(md5)</span><br></pre></td></tr></table></figure>
<p>这部分代码检查 <code>display_name</code> 是否存在，如果存在，则将获取到的软件信息封装成一个字典 <code>source_data</code>。然后，它调用 <code>get_line</code> 方法处理 <code>source_data</code>，并将处理后的数据转换为 <code>JSON</code> 格式。接着，它计算 <code>JSON</code> 数据的 <code>MD5</code> 哈希值，并检查该哈希值是否已存在于 <code>t</code> 中。如果不存在，它将 <code>JSON</code> 数据写入到输出文件中，并将 <code>MD5</code> 哈希值添加到 <code>t</code> 中。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch之python总结</title>
    <url>/2022/05/12/%E5%B7%A5%E5%85%B7-ElasticSearch/</url>
    <content><![CDATA[<h2 id="对于ES"><a href="#对于ES" class="headerlink" title="对于ES"></a>对于ES</h2><p>ES数据库本身作为一种分布式的、查询优势、拓展优势、容错优势…..等等众多优点的数据库。更多的特点还是自行百度吧</p>
<h2 id="python操作"><a href="#python操作" class="headerlink" title="python操作"></a>python操作</h2><p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install elasticsearch</span><br></pre></td></tr></table></figure>

<p>安装也就那样吧。</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>过热推荐，如果需要学习一个新的库的使用的时候，看源码与看官方文档是一个好习惯，因此本文仅列出少数操作，以使用入门讲解为主要核心。首先附上官方文档：<a href="https://elasticsearch-py.readthedocs.io/">https://elasticsearch-py.readthedocs.io/</a>  点击链接会直接跳转到最新版本的官方文档。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>在使用python进行操作的时候，首先需要连接数据库，在启动数据库之后采用以下代码进行数据库连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个ip为localhost，端口为9200，允许超时一小时的es对象</span></span><br><span class="line">client = Elasticsearch(<span class="string">&quot;http://IP:9200&quot;</span>) <span class="comment"># 替换成对应IP</span></span><br></pre></td></tr></table></figure>

<p>但是其实还有更多可选参数，在VScode当中只需要按住ctrl后点击Elasticsearch就能够看到源码，源码给出了更多可选参数与可选参数类型对数据库lz做了配置,部分源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        hosts: t.<span class="type">Optional</span>[_TYPE_HOSTS] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        *,</span></span><br><span class="line"><span class="params">        <span class="comment"># API</span></span></span><br><span class="line"><span class="params">        cloud_id: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        api_key: t.<span class="type">Optional</span>[t.<span class="type">Union</span>[<span class="built_in">str</span>, t.<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        basic_auth: t.<span class="type">Optional</span>[t.<span class="type">Union</span>[<span class="built_in">str</span>, t.<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        bearer_auth: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        opaque_id: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        <span class="comment"># Node</span></span></span><br><span class="line"><span class="params">        headers: t.<span class="type">Union</span>[DefaultType, t.Mapping[<span class="built_in">str</span>, <span class="built_in">str</span>]] = DEFAULT,</span></span><br><span class="line"><span class="params">        connections_per_node: t.<span class="type">Union</span>[DefaultType, <span class="built_in">int</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        http_compress: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        verify_certs: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        ca_certs: t.<span class="type">Union</span>[DefaultType, <span class="built_in">str</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        client_cert: t.<span class="type">Union</span>[DefaultType, <span class="built_in">str</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        client_key: t.<span class="type">Union</span>[DefaultType, <span class="built_in">str</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        ssl_assert_hostname: t.<span class="type">Union</span>[DefaultType, <span class="built_in">str</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        ssl_assert_fingerprint: t.<span class="type">Union</span>[DefaultType, <span class="built_in">str</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        ssl_version: t.<span class="type">Union</span>[DefaultType, <span class="built_in">int</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        ssl_context: t.<span class="type">Union</span>[DefaultType, t.<span class="type">Any</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        ssl_show_warn: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        <span class="comment"># Transport</span></span></span><br><span class="line"><span class="params">        transport_class: t.<span class="type">Type</span>[Transport] = Transport,</span></span><br><span class="line"><span class="params">        request_timeout: t.<span class="type">Union</span>[DefaultType, <span class="literal">None</span>, <span class="built_in">float</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        node_class: t.<span class="type">Union</span>[DefaultType, t.<span class="type">Type</span>[BaseNode]] = DEFAULT,</span></span><br><span class="line"><span class="params">        node_pool_class: t.<span class="type">Union</span>[DefaultType, t.<span class="type">Type</span>[NodePool]] = DEFAULT,</span></span><br><span class="line"><span class="params">        randomize_nodes_in_pool: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        node_selector_class: t.<span class="type">Union</span>[DefaultType, t.<span class="type">Type</span>[NodeSelector]] = DEFAULT,</span></span><br><span class="line"><span class="params">        dead_node_backoff_factor: t.<span class="type">Union</span>[DefaultType, <span class="built_in">float</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        max_dead_node_backoff: t.<span class="type">Union</span>[DefaultType, <span class="built_in">float</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        serializer: t.<span class="type">Optional</span>[Serializer] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        serializers: t.<span class="type">Union</span>[DefaultType, t.Mapping[<span class="built_in">str</span>, Serializer]] = DEFAULT,</span></span><br><span class="line"><span class="params">        default_mimetype: <span class="built_in">str</span> = <span class="string">&quot;application/json&quot;</span>,</span></span><br><span class="line"><span class="params">        max_retries: t.<span class="type">Union</span>[DefaultType, <span class="built_in">int</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        retry_on_status: t.<span class="type">Union</span>[DefaultType, <span class="built_in">int</span>, t.Collection[<span class="built_in">int</span>]] = DEFAULT,</span></span><br><span class="line"><span class="params">        retry_on_timeout: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        sniff_on_start: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        sniff_before_requests: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        sniff_on_node_failure: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        sniff_timeout: t.<span class="type">Union</span>[DefaultType, <span class="literal">None</span>, <span class="built_in">float</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        min_delay_between_sniffing: t.<span class="type">Union</span>[DefaultType, <span class="literal">None</span>, <span class="built_in">float</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        sniffed_node_callback: t.<span class="type">Optional</span>[</span></span><br><span class="line"><span class="params">            t.<span class="type">Callable</span>[[t.<span class="type">Dict</span>[<span class="built_in">str</span>, t.<span class="type">Any</span>], NodeConfig], t.<span class="type">Optional</span>[NodeConfig]]</span></span><br><span class="line"><span class="params">        ] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        meta_header: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        timeout: t.<span class="type">Union</span>[DefaultType, <span class="literal">None</span>, <span class="built_in">float</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        randomize_hosts: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        host_info_callback: t.<span class="type">Optional</span>[</span></span><br><span class="line"><span class="params">            t.<span class="type">Callable</span>[</span></span><br><span class="line"><span class="params">                [t.<span class="type">Dict</span>[<span class="built_in">str</span>, t.<span class="type">Any</span>], t.<span class="type">Dict</span>[<span class="built_in">str</span>, t.<span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]]],</span></span><br><span class="line"><span class="params">                t.<span class="type">Optional</span>[t.<span class="type">Dict</span>[<span class="built_in">str</span>, t.<span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]]],</span></span><br><span class="line"><span class="params">            ]</span></span><br><span class="line"><span class="params">        ] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        sniffer_timeout: t.<span class="type">Union</span>[DefaultType, <span class="literal">None</span>, <span class="built_in">float</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        sniff_on_connection_fail: t.<span class="type">Union</span>[DefaultType, <span class="built_in">bool</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        http_auth: t.<span class="type">Union</span>[DefaultType, t.<span class="type">Any</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        maxsize: t.<span class="type">Union</span>[DefaultType, <span class="built_in">int</span>] = DEFAULT,</span></span><br><span class="line"><span class="params">        <span class="comment"># Internal use only</span></span></span><br><span class="line"><span class="params">        _transport: t.<span class="type">Optional</span>[Transport] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>)</span><br></pre></td></tr></table></figure>

<p>源码对参数进行可分类，分别是：API、Node、Transport、Internal use only四个大类，还有一个必选的host参数。其实根据参数已经能够明白该库该如何使用了，以API为例，对应ES数据库的实际使用即可创建API接口。</p>
<p>同理，在源码中给出了一些其他操作，如create、delete、close等等。</p>
]]></content>
      <categories>
        <category>错误</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradio基础尝试</title>
    <url>/2024/12/01/%E5%B7%A5%E5%85%B7-Gradio%E5%9F%BA%E7%A1%80%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Gradio库：快速构建机器学习应用界面"><a href="#Gradio库：快速构建机器学习应用界面" class="headerlink" title="Gradio库：快速构建机器学习应用界面"></a>Gradio库：快速构建机器学习应用界面</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Gradio是一个Python库，它允许我们快速构建机器学习模型的Web界面。通过简单的代码，我们可以将复杂的机器学习模型转变为易于使用的Web应用。本文将带你了解Gradio的基本用法，包括<code>Interface</code>、<code>ChatInterface</code>和<code>TabbedInterface</code>三种界面的构建方法。</p>
<h2 id="Gradio-Interface基础"><a href="#Gradio-Interface基础" class="headerlink" title="Gradio Interface基础"></a>Gradio Interface基础</h2><h3 id="什么是Interface？"><a href="#什么是Interface？" class="headerlink" title="什么是Interface？"></a>什么是Interface？</h3><p><code>Interface</code>是Gradio中最基础的界面类型，它允许我们围绕一个函数构建一个Web界面。这个函数可以是一个机器学习模型的预测函数，每个参数对应一个输入组件，函数返回值对应输出组件。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h2 id="Gradio-Interface案例：由浅入深"><a href="#Gradio-Interface案例：由浅入深" class="headerlink" title="Gradio Interface案例：由浅入深"></a>Gradio Interface案例：由浅入深</h2><h3 id="案例一：简单的文本反转"><a href="#案例一：简单的文本反转" class="headerlink" title="案例一：简单的文本反转"></a>案例一：简单的文本反转</h3><p>这是最简单的Gradio Interface案例，我们将创建一个Web界面，用户输入文本后，界面返回文本的反转。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，接受一个字符串并返回其反转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> text[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Gradio Interface创建Web界面</span></span><br><span class="line"><span class="comment"># 输入和输出都是文本类型</span></span><br><span class="line">iface = gr.Interface(fn=reverse_text, inputs=<span class="string">&quot;text&quot;</span>, outputs=<span class="string">&quot;text&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器，用户可以在浏览器中访问这个界面</span></span><br><span class="line">iface.launch()</span><br></pre></td></tr></table></figure>

<h3 id="案例二：图像识别"><a href="#案例二：图像识别" class="headerlink" title="案例二：图像识别"></a>案例二：图像识别</h3><p>在这个案例中，我们将创建一个图像识别的Web界面，用户上传一张图片，模型识别图片中的内容并返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> some_image_recognition_library  <span class="comment"># 假设的图像识别库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义图像识别函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recognize_image</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 使用图像识别库处理图片</span></span><br><span class="line">    result = some_image_recognition_library.recognize(image)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Interface实例</span></span><br><span class="line"><span class="comment"># 输入是图像，输出是文本</span></span><br><span class="line">iface = gr.Interface(fn=recognize_image, inputs=gr.Image(), outputs=<span class="string">&quot;text&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">iface.launch()</span><br></pre></td></tr></table></figure>

<h3 id="案例三：自定义机器学习模型预测"><a href="#案例三：自定义机器学习模型预测" class="headerlink" title="案例三：自定义机器学习模型预测"></a>案例三：自定义机器学习模型预测</h3><p>在这个高级案例中，我们将创建一个Web界面，用于自定义机器学习模型的预测。假设我们有一个训练好的模型<code>my_model</code>，我们希望用户能够输入特征数据，模型返回预测结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> my_machine_learning_library <span class="keyword">import</span> my_model  <span class="comment"># 假设的机器学习模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型预测函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 将输入数据转换为模型需要的格式</span></span><br><span class="line">    data = np.array(data)</span><br><span class="line">    <span class="comment"># 使用模型进行预测</span></span><br><span class="line">    prediction = my_model.predict(data)</span><br><span class="line">    <span class="keyword">return</span> prediction</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Interface实例</span></span><br><span class="line"><span class="comment"># 输入是数字滑块，输出是图表</span></span><br><span class="line">iface = gr.Interface(</span><br><span class="line">    fn=predict,</span><br><span class="line">    inputs=[gr.Slider(minimum=<span class="number">0</span>, maximum=<span class="number">10</span>, step=<span class="number">1</span>, label=<span class="string">&quot;Feature 1&quot;</span>), </span><br><span class="line">            gr.Slider(minimum=<span class="number">0</span>, maximum=<span class="number">10</span>, step=<span class="number">1</span>, label=<span class="string">&quot;Feature 2&quot;</span>)],</span><br><span class="line">    outputs=gr.Plot()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">iface.launch()</span><br></pre></td></tr></table></figure>

<h2 id="Gradio-ChatInterface"><a href="#Gradio-ChatInterface" class="headerlink" title="Gradio ChatInterface"></a>Gradio ChatInterface</h2><h3 id="什么是ChatInterface？"><a href="#什么是ChatInterface？" class="headerlink" title="什么是ChatInterface？"></a>什么是ChatInterface？</h3><p><code>ChatInterface</code>是Gradio提供的一种聊天界面，适用于构建聊天机器人应用。它可以接受文本输入，并显示与聊天机器人的交互历史。</p>
<h3 id="案例一：基础聊天机器人"><a href="#案例一：基础聊天机器人" class="headerlink" title="案例一：基础聊天机器人"></a>案例一：基础聊天机器人</h3><p>在这个基础案例中，我们将创建一个简单的聊天机器人界面，用户可以输入文本，机器人返回一个固定的回复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个简单的聊天机器人函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chatbot</span>(<span class="params">input_message, chat_history</span>):</span><br><span class="line">    <span class="comment"># 这里只是一个简单的回复，实际应用中应根据input_message和chat_history来生成回复</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好！这是一个基础的聊天机器人。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Gradio ChatInterface创建聊天界面</span></span><br><span class="line">chatbot_interface = gr.ChatInterface(fn=chatbot, multimodal=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器，用户可以在浏览器中访问这个界面</span></span><br><span class="line">chatbot_interface.launch()</span><br></pre></td></tr></table></figure>

<h3 id="案例二：智能问答系统"><a href="#案例二：智能问答系统" class="headerlink" title="案例二：智能问答系统"></a>案例二：智能问答系统</h3><p>在这个案例中，我们将创建一个智能问答系统，用户可以输入问题，系统根据预设的问答对返回答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预设的问答对</span></span><br><span class="line">qa_pairs = &#123;</span><br><span class="line">    <span class="string">&quot;你是谁？&quot;</span>: <span class="string">&quot;我是一个智能问答系统。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;你来自哪里？&quot;</span>: <span class="string">&quot;我来自云端。&quot;</span>,</span><br><span class="line">    <span class="comment"># 更多的问答对...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义问答系统函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">answer_question</span>(<span class="params">input_message, chat_history</span>):</span><br><span class="line">    <span class="comment"># 根据用户的问题返回答案</span></span><br><span class="line">    <span class="keyword">return</span> qa_pairs.get(input_message, <span class="string">&quot;对不起，我不知道如何回答这个问题。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ChatInterface实例</span></span><br><span class="line">chatbot_interface = gr.ChatInterface(fn=answer_question, multimodal=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">chatbot_interface.launch()</span><br></pre></td></tr></table></figure>

<h3 id="案例三：基于机器学习的聊天机器人"><a href="#案例三：基于机器学习的聊天机器人" class="headerlink" title="案例三：基于机器学习的聊天机器人"></a>案例三：基于机器学习的聊天机器人</h3><p>在这个高级案例中，我们将创建一个基于机器学习模型的聊天机器人，用户可以输入文本，机器人利用模型生成回复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> some_chat_model_library  <span class="comment"># 假设的聊天模型库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设的聊天模型</span></span><br><span class="line">chat_model = some_chat_model_library.load_model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义聊天机器人函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chatbot</span>(<span class="params">input_message, chat_history</span>):</span><br><span class="line">    <span class="comment"># 使用聊天模型生成回复</span></span><br><span class="line">    response = chat_model.generate_response(input_message, chat_history)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ChatInterface实例</span></span><br><span class="line">chatbot_interface = gr.ChatInterface(fn=chatbot, multimodal=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">chatbot_interface.launch()</span><br></pre></td></tr></table></figure>

<h2 id="Gradio-TabbedInterface"><a href="#Gradio-TabbedInterface" class="headerlink" title="Gradio TabbedInterface"></a>Gradio TabbedInterface</h2><h3 id="什么是TabbedInterface？"><a href="#什么是TabbedInterface？" class="headerlink" title="什么是TabbedInterface？"></a>什么是TabbedInterface？</h3><p><code>TabbedInterface</code>允许我们将多个<code>Interface</code>或<code>Blocks</code>组织在一个带有标签页的界面中。每个<code>Interface</code>或<code>Blocks</code>都会在单独的标签页中渲染。</p>
<h3 id="案例一：基础标签页界面"><a href="#案例一：基础标签页界面" class="headerlink" title="案例一：基础标签页界面"></a>案例一：基础标签页界面</h3><p>在这个基础案例中，我们将创建一个包含两个标签页的界面，每个标签页都有一个简单的文本输入和输出功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个简单的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">farewell</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Goodbye &quot;</span> + name + <span class="string">&quot;!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个Interface实例</span></span><br><span class="line">greet_interface = gr.Interface(fn=greet, inputs=<span class="string">&quot;text&quot;</span>, outputs=<span class="string">&quot;text&quot;</span>, title=<span class="string">&quot;Greeting&quot;</span>)</span><br><span class="line">farewell_interface = gr.Interface(fn=farewell, inputs=<span class="string">&quot;text&quot;</span>, outputs=<span class="string">&quot;text&quot;</span>, title=<span class="string">&quot;Farewell&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用TabbedInterface将两个Interface组合在一起</span></span><br><span class="line">tabbed_demo = gr.TabbedInterface([greet_interface, farewell_interface], [<span class="string">&quot;Greet&quot;</span>, <span class="string">&quot;Farewell&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">tabbed_demo.launch()</span><br></pre></td></tr></table></figure>

<h3 id="案例二：包含图像处理的标签页界面"><a href="#案例二：包含图像处理的标签页界面" class="headerlink" title="案例二：包含图像处理的标签页界面"></a>案例二：包含图像处理的标签页界面</h3><p>在这个案例中，我们将创建一个包含三个标签页的界面，其中两个标签页用于图像处理（一个用于图像上传，一个用于图像转换），另一个标签页用于文本处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数：图像上传</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 这里只是一个示例，实际应用中应根据需要处理图像</span></span><br><span class="line">    image = image.convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转换为灰度图</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数：文本反转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> text[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Interface实例</span></span><br><span class="line">image_upload_interface = gr.Interface(fn=process_image, inputs=gr.Image(), outputs=gr.Image(), title=<span class="string">&quot;Upload Image&quot;</span>)</span><br><span class="line">text_reverse_interface = gr.Interface(fn=reverse_text, inputs=<span class="string">&quot;text&quot;</span>, outputs=<span class="string">&quot;text&quot;</span>, title=<span class="string">&quot;Reverse Text&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TabbedInterface实例</span></span><br><span class="line">tabbed_demo = gr.TabbedInterface([image_upload_interface, text_reverse_interface], [<span class="string">&quot;Image Processing&quot;</span>, <span class="string">&quot;Text&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">tabbed_demo.launch()</span><br></pre></td></tr></table></figure>

<h3 id="案例三：复杂的多标签页机器学习应用界面"><a href="#案例三：复杂的多标签页机器学习应用界面" class="headerlink" title="案例三：复杂的多标签页机器学习应用界面"></a>案例三：复杂的多标签页机器学习应用界面</h3><p>在这个高级案例中，我们将创建一个包含多个标签页的界面，每个标签页都用于不同的机器学习任务，如图像分类、语音识别和自然语言处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> some_ml_library  <span class="comment"># 假设的机器学习库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数：图像分类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify_image</span>(<span class="params">image</span>):</span><br><span class="line">    classification = some_ml_library.image_classification_model.predict(image)</span><br><span class="line">    <span class="keyword">return</span> classification</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数：语音识别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recognize_speech</span>(<span class="params">speech</span>):</span><br><span class="line">    transcription = some_ml_library.speech_recognition_model.transcribe(speech)</span><br><span class="line">    <span class="keyword">return</span> transcription</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数：自然语言处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="comment"># 假设的自然语言处理任务：情感分析</span></span><br><span class="line">    sentiment = some_ml_library.nlp_model.analyze_sentiment(text)</span><br><span class="line">    <span class="keyword">return</span> sentiment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Interface实例</span></span><br><span class="line">image_classification_interface = gr.Interface(fn=classify_image, inputs=gr.Image(), outputs=<span class="string">&quot;text&quot;</span>, title=<span class="string">&quot;Image Classification&quot;</span>)</span><br><span class="line">speech_recognition_interface = gr.Interface(fn=recognize_speech, inputs=gr.Audio(), outputs=<span class="string">&quot;text&quot;</span>, title=<span class="string">&quot;Speech Recognition&quot;</span>)</span><br><span class="line">nlp_interface = gr.Interface(fn=process_text, inputs=<span class="string">&quot;text&quot;</span>, outputs=<span class="string">&quot;text&quot;</span>, title=<span class="string">&quot;Natural Language Processing&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TabbedInterface实例</span></span><br><span class="line">tabbed_ml_app = gr.TabbedInterface([image_classification_interface, speech_recognition_interface, nlp_interface], [<span class="string">&quot;Image Classification&quot;</span>, <span class="string">&quot;Speech Recognition&quot;</span>, <span class="string">&quot;NLP&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">tabbed_ml_app.launch()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Gradio提供了强大的工具，使得我们可以快速地将机器学习模型转化为易于使用的Web应用。通过<code>Interface</code>、<code>ChatInterface</code>和<code>TabbedInterface</code>三种界面类型，我们可以根据不同的应用场景选择合适的界面类型，快速构建出既美观又实用的Web界面。希望本文能帮助你快速上手Gradio，构建出自己的机器学习应用。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MobaXterm解除会话限制</title>
    <url>/2023/11/06/%E5%B7%A5%E5%85%B7-MobaXterm%E8%A7%A3%E9%99%A4%E4%BC%9A%E8%AF%9D%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>MobaXterm的会话一般来说是14个，更多的会话可以使用但不能保存，解除会话限制工具：</p>
<p><a href="https://github.com/flygon2018/MobaXterm-keygen.git">https://github.com/flygon2018/MobaXterm-keygen.git</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>autorunsc工具获取计划任务</title>
    <url>/2024/12/01/%E5%8F%96%E8%AF%81-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="解析autorunsc工具的Python调用流程"><a href="#解析autorunsc工具的Python调用流程" class="headerlink" title="解析autorunsc工具的Python调用流程"></a>解析autorunsc工具的Python调用流程</h2><p>本文将深入探讨一段Python取证代码，该代码用于调用<code>autorunsc</code>工具，这是一个用于列出当前系统上所有自启动程序。现在将按照代码的执行流程，分块解释每一部分的功能和实现方式。</p>
<h3 id="环境变量检查和文件名选择"><a href="#环境变量检查和文件名选择" class="headerlink" title="环境变量检查和文件名选择"></a>环境变量检查和文件名选择</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">autorunsc_name = <span class="string">&quot;autorunsc64.exe&quot;</span> <span class="keyword">if</span> <span class="string">&quot;PROGRAMFILES(X86)&quot;</span> <span class="keyword">in</span> os.environ <span class="keyword">else</span> <span class="string">&quot;autorunsc32.exe&quot;</span></span><br></pre></td></tr></table></figure>
<p>这一部分代码检查系统环境变量中是否存在<code>PROGRAMFILES(X86)</code>，以确定系统是32位还是64位，并据此选择相应的<code>autorunsc</code>工具版本。</p>
<h3 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">autoruns_path = os.path.join(setting.PROJ_PATH, autorunsc_name)</span><br><span class="line">result_temp_path = os.path.join(setting.PROJ_PATH, <span class="string">&#x27;res_h.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里，我们使用<code>os.path.join</code>函数来拼接路径，获取<code>autorunsc</code>工具的完整路径和结果临时文件的路径。<code>setting.PROJ_PATH</code>是一个预定义的项目路径。</p>
<h3 id="调用autorunsc工具"><a href="#调用autorunsc工具" class="headerlink" title="调用autorunsc工具"></a>调用autorunsc工具</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(</span><br><span class="line">    <span class="string">&quot;&#123;&#125; /accepteula -a t -s -h -ct &gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        autoruns_path, result_temp_path)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这一行代码通过<code>os.system</code>函数调用<code>autorunsc</code>工具，执行参数包括<code>/accepteula</code>（接受EULA），<code>-a t</code>（显示所有项目），<code>-s</code>（静默模式），<code>-h</code>（隐藏窗口），<code>-ct</code>（输出为CSV格式）。输出结果被重定向到<code>result_temp_path</code>指定的临时文件中。</p>
<h3 id="读取和处理CSV文件"><a href="#读取和处理CSV文件" class="headerlink" title="读取和处理CSV文件"></a>读取和处理CSV文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(result_temp_path, <span class="string">&quot;rt&quot;</span>, encoding=<span class="string">&quot;UTF-16&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv.DictReader(f, delimiter=<span class="string">&quot;\t&quot;</span>):</span><br><span class="line">        clean_data = get_line(self, row, self.display_list)</span><br></pre></td></tr></table></figure>
<p>这段代码打开临时CSV文件，并使用<code>csv.DictReader</code>以字典形式读取每一行。<code>delimiter=&quot;\t&quot;</code>指定了字段分隔符为制表符。对于每一行，调用<code>get_line</code>函数（未在代码中给出）进行数据清洗和处理。</p>
<h3 id="数据序列化和写入文件"><a href="#数据序列化和写入文件" class="headerlink" title="数据序列化和写入文件"></a>数据序列化和写入文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = json.dumps(clean_data, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">write_file(self.file, data)</span><br></pre></td></tr></table></figure>
<p>这里，将清洗后的数据<code>clean_data</code>使用<code>json.dumps</code>函数序列化为JSON格式的字符串，<code>ensure_ascii=False</code>参数确保非ASCII字符被正确处理。然后，调用<code>write_file</code>函数（未在代码中给出）将序列化后的数据写入到某个文件中。</p>
<h3 id="清理临时文件"><a href="#清理临时文件" class="headerlink" title="清理临时文件"></a>清理临时文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(result_temp_path)</span><br></pre></td></tr></table></figure>
<p>最后，代码使用<code>os.remove</code>函数删除临时CSV文件，以清理系统资源。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA环境安装</title>
    <url>/2024/03/25/%E5%B7%A5%E5%85%B7-NVIDIA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="操作系统环境"><a href="#操作系统环境" class="headerlink" title="操作系统环境"></a>操作系统环境</h2><p>系统信息: <code>Linux user-Super-Server 5.15.0-97-generic #107~20.04.1-Ubuntu SMP Fri Feb 9 14:20:11 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</code></p>
<h2 id="驱动环境"><a href="#驱动环境" class="headerlink" title="驱动环境"></a>驱动环境</h2><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><ul>
<li>cuda版本: <code>cuda_12.2.2_535.104.05_linux.run</code></li>
<li>NVIDIA版本: <code>NVIDIA-Linux-x86_64-535.154.05.run</code></li>
</ul>
<hr>
<h4 id="错误备注"><a href="#错误备注" class="headerlink" title="错误备注"></a>错误备注</h4><ul>
<li>cuda安装包当中包含NVIDIA的驱动，但是不能直接安装cuda,会导致模型加载出错，必须分开安装</li>
<li>cuda12.3版本不可用，禁止安装，可能导致驱动损坏问题以及模型加载过慢问题</li>
<li>安装之前一定保证原始环境当中没有cuda与NVIDIA的任何信息，否则可能导致安装冲突失败</li>
<li>确认卸载后驱动挂载还会存在，需要重启电脑才能保证驱动挂载被清理掉</li>
<li>禁止使用Ubuntu官方源进行安装</li>
</ul>
<h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><h4 id="安装NVIDIA"><a href="#安装NVIDIA" class="headerlink" title="安装NVIDIA"></a>安装NVIDIA</h4><p>1、查看操作系统</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">root@user-Super-Server:~<span class="comment"># lsb_release -d</span></span><br><span class="line">Description:    Ubuntu 20.04.6 LTS</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、查看显卡信息</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">root@user-Super-Server:~<span class="comment"># lspci | grep VGA</span></span><br><span class="line">03:00.0 VGA compatible controller: ASPEED Technology, Inc. ASPEED Graphics Family (rev 52)</span><br><span class="line">31:00.0 VGA compatible controller: NVIDIA Corporation Device 2684 (rev a1)</span><br><span class="line">4b:00.0 VGA compatible controller: NVIDIA Corporation Device 2684 (rev a1)</span><br><span class="line">b1:00.0 VGA compatible controller: NVIDIA Corporation Device 2684 (rev a1)</span><br><span class="line">ca:00.0 VGA compatible controller: NVIDIA Corporation Device 2684 (rev a1)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<a href="http://pci-ids.ucw.cz/mods/PC/10de?action=help?help=pci">pci-ids.ucw.cz</a>输入上面的 2684 得出当前显卡信息为：AD102 [GeForce RTX 4090]</p>
</blockquote>
<p>也可以使用以下命令查看显卡更多信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lshw -numeric  -C display</span><br></pre></td></tr></table></figure>

<p>3、安装GCC、G++、make等工具</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"><span class="comment"># gcc --version 验证gcc是否安装成功</span></span><br><span class="line">sudo apt-get install g++</span><br><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure>

<p>安装结果如下</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">root@user-Super-Server:~<span class="comment"># gcc --version</span></span><br><span class="line">gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">root@user-Super-Server:~<span class="comment"># g++ --version</span></span><br><span class="line">g++ (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">root@user-Super-Server:~<span class="comment"># make --version</span></span><br><span class="line">GNU Make 4.2.1</span><br><span class="line">为 x86_64-pc-linux-gnu 编译</span><br><span class="line">Copyright (C) 1988-2016 Free Software Foundation, Inc.</span><br><span class="line">许可证：GPLv3+：GNU 通用公共许可证第 3 版或更新版本&lt;http://gnu.org/licenses/gpl.html&gt;。</span><br><span class="line">本软件是自由软件：您可以自由修改和重新发布它。</span><br><span class="line">在法律允许的范围内没有其他保证。</span><br></pre></td></tr></table></figure>

<p>4、卸载nvidia旧驱动</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo /usr/bin/nvidia-uninstall</span><br><span class="line">sudo apt-get --purge remove nvidia*</span><br><span class="line">sudo apt-get purge nvidia*</span><br><span class="line">sudo apt-get purge libnvidia*</span><br></pre></td></tr></table></figure>

<blockquote>
<p>直到命令不输出任何内容：<code>sudo dpkg --list | grep nvidia-*</code> 为保证驱动正常被取消挂载，请重启电脑后再次确认</p>
</blockquote>
<p>5、根据显卡型号，下载对应的显卡驱动</p>
<p>下载驱动网址：<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">Official Drivers | NVIDIA</a></p>
<blockquote>
<p>可以选择版本下载，点击 <a href="https://www.nvidia.com/Download/Find.aspx?lang=en-us">Official Advanced Driver Search | NVIDIA</a>根据自己的显卡型号，查找驱动，我这里选择<code>NVIDIA-Linux-x86_64-535.154.05.run</code>安装驱动之前,需要禁用<code>nouveau</code>（<code>nouveau</code> 是专门用来逆向工程 <code>NVIDIA</code> 闭源驱动的开源驱动项目）,因为<code>ubuntu</code>安装时会默认安装<code>nouveau</code>驱动，如果不禁用，会阻碍<code>NVIDIA</code>官方驱动的安装。</p>
</blockquote>
<p>禁用<code>nouveau</code>方法如下:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure>

<p>在文件末尾添加：</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm‐nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line"><span class="built_in">alias</span> nouveau off</span><br><span class="line"><span class="built_in">alias</span> lbm‐nouveau off</span><br></pre></td></tr></table></figure>

<ul>
<li>对刚才修改的文件进行更新：<code>sudo update-initramfs -u</code></li>
<li>重启计算机：<code>sudo reboot</code></li>
</ul>
<blockquote>
<p>查看<code>nouveau</code>是否禁用成功：<code>lsmod | grep nouveau</code>，执行完这句，如没有任何输出，表示禁用成功。</p>
</blockquote>
<p>6、关闭图形界面(选择性操作)</p>
<p>进入tty模式(具体操作依情况而定)输入：<code>sudo service lightdm stop</code></p>
<p>7、开始安装驱动</p>
<p>进入驱动所在目录，给驱动文件付权限，然后安装：</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> +x NVIDIA-Linux-x86_64-535.154.05.run</span><br><span class="line">sudo sh NVIDIA-Linux-x86_64-535.154.05.run  -no-opengl-files -no-x-check -no-nouveau-check</span><br></pre></td></tr></table></figure>

<p>参数说明:  </p>
<ul>
<li>-no-x-check：安装驱动时关闭 X 服务</li>
<li>-no-nouveau-check：安装驱动时禁用 nouveau</li>
<li>-no-opengl-files：只安装驱动文件，不安装 OpenGL 文件</li>
</ul>
<p>操作项说明:  </p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">Would you like to register the kernel module souces with DKMS? This will allow DKMS to automatically build a new module, <span class="keyword">if</span> you install a different kernel later?  </span><br><span class="line">选择 No 继续。</span><br><span class="line">Nvidia<span class="string">&#x27;s 32-bit compatibility libraries? </span></span><br><span class="line"><span class="string">选择 No 继续。</span></span><br><span class="line"><span class="string">Would you like to run the nvidia-xconfigutility to automatically update your x configuration so that the NVIDIA x driver will be used when you restart x? Any pre-existing x confile will be backed up.  </span></span><br><span class="line"><span class="string">选择 Yes  继续</span></span><br></pre></td></tr></table></figure>

<p>8、挂载 Nvidia 驱动</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo modprobe nvidia</span><br></pre></td></tr></table></figure>

<p>9、查看驱动是否安装成功</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>

<p>输出结果如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@user-Super-Server:~<span class="comment"># nvidia-smi</span></span><br><span class="line">Thu Feb 29 15:25:16 2024</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 535.104.05             Driver Version: 535.104.05   CUDA Version: 12.2     |</span><br><span class="line">|-----------------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                      |               MIG M. |</span><br><span class="line">|=========================================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce RTX 4090        Off | 00000000:31:00.0 Off |                  Off |</span><br><span class="line">| 55%   47C    P2              90W / 450W |  20175MiB / 24564MiB |    100%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line">|   1  NVIDIA GeForce RTX 4090        Off | 00000000:4B:00.0 Off |                  Off |</span><br><span class="line">| 46%   48C    P2             112W / 450W |  20431MiB / 24564MiB |    100%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line">|   2  NVIDIA GeForce RTX 4090        Off | 00000000:B1:00.0 Off |                  Off |</span><br><span class="line">| 52%   48C    P2             106W / 450W |  17871MiB / 24564MiB |    100%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line">|   3  NVIDIA GeForce RTX 4090        Off | 00000000:CA:00.0 Off |                  Off |</span><br><span class="line">| 69%   49C    P2             115W / 450W |  22477MiB / 24564MiB |    100%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                            |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |</span><br><span class="line">|        ID   ID                                                             Usage      |</span><br><span class="line">|=======================================================================================|</span><br><span class="line">|    0   N/A  N/A   1828292      C   ...onda3/envs/llama_factory/bin/python    20142MiB |</span><br><span class="line">|    1   N/A  N/A   1828293      C   ...onda3/envs/llama_factory/bin/python    20398MiB |</span><br><span class="line">|    2   N/A  N/A   1828294      C   ...onda3/envs/llama_factory/bin/python    17838MiB |</span><br><span class="line">|    3   N/A  N/A   1828295      C   ...onda3/envs/llama_factory/bin/python    22444MiB |</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h4><p>1、查看自己电脑的驱动程序版本</p>
<p><code>nvidia-smi</code>命令结果输出右上角可以看到最高版本的cuda不能大于12.2,具体驱动程序对应的cuda版本可以通过<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/">官网查看</a></p>
<p>2、下载cuda</p>
<p>官网地址：<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a></p>
<p>这里依据个人情况自定义去下载，当前文档使用版本为:<code>cuda_12.2.2_535.104.05_linux.run</code></p>
<p>3、卸载旧版本</p>
<p>开始卸载旧版本CUDA(确保一定没有cuda环境):  </p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo apt-get --purge remove <span class="string">&quot;*cuda*&quot;</span> <span class="string">&quot;*cublas*&quot;</span> <span class="string">&quot;*cufft*&quot;</span> <span class="string">&quot;*cufile*&quot;</span> <span class="string">&quot;*curand*&quot;</span>  <span class="string">&quot;*cusolver*&quot;</span> <span class="string">&quot;*cusparse*&quot;</span> <span class="string">&quot;*gds-tools*&quot;</span> <span class="string">&quot;*npp*&quot;</span> <span class="string">&quot;*nvjpeg*&quot;</span> <span class="string">&quot;nsight*&quot;</span> <span class="string">&quot;*nvvm*&quot;</span></span><br><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure>
<p>或  </p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo /usr/local/cuda-12.1/bin/cuda-uninstaller</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用空格选择所有cuda相关文件，确认，需要一会儿提示成功卸载。</p>
</blockquote>
<p>最后确认删除磁盘文件,手动删除命令：<code>sudo rm -rf /usr/local/cuda-12...</code></p>
<p>4、开始准备安装</p>
<p>修改安装包:  </p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">vi cuda_12.2.2_535.104.05_linux.run</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编辑修改/tmp为/data/tmp ==(就在开头几行不用往下找)==</p>
</blockquote>
<p>执行安装cuda:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo sh cuda_12.2.2_535.104.05_linux.run</span><br></pre></td></tr></table></figure>

<p>配置环境变量:  </p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo  vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在文件末尾添加：  </p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda-12.2/lib64</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda-12.2/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>重新加载环境变量:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>5、看看cuda安装是否正常：</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">root@user-Super-Server:~<span class="comment"># nvcc  -V</span></span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2023 NVIDIA Corporation</span><br><span class="line">Built on Tue_Aug_15_22:02:13_PDT_2023</span><br><span class="line">Cuda compilation tools, release 12.2, V12.2.140</span><br><span class="line">Build cuda_12.2.r12.2/compiler.33191640_0</span><br></pre></td></tr></table></figure>

<h2 id="python-环境"><a href="#python-环境" class="headerlink" title="python 环境"></a>python 环境</h2><p>==为方便环境安装部署迁移等操作，python环境统一为miniconda==</p>
<h3 id="安装与卸载miniconda"><a href="#安装与卸载miniconda" class="headerlink" title="安装与卸载miniconda"></a>安装与卸载miniconda</h3><p>安装可以从<a href="https://www.baidu.com/link?url=MlS43r54KznxORhbbMO60R9LgfVLpBy9CWEbQHGU6ULHYOwG-ojmm_tRL8e12hnf&wd=&eqid=872456a00001007e0000000365e03679">官网</a>进行下载安装，也可以使用<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">清华国内源</a>，尽可能使用最高版本，最高版本可以创建更多其他版本的虚拟环境。</p>
<p>当前主机下载的版本为: <code>Miniconda3-py310_23.11.0-2-Linux-x86_64.sh</code>，可以直接运行安装，所有选项均可为默认选项。</p>
<blockquote>
<p>Linux自带python环境，因此需要注意的是，安装好miniconda之后miniconda会覆盖掉原本的python环境，因此如果你有需求使用原始的python环境，需要注意环境变量覆盖的问题。</p>
</blockquote>
<p>安装成功演示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) root@user-Super-Server:~<span class="comment"># python</span></span><br><span class="line">Python 3.10.13 (main, Sep 11 2023, 13:44:35) [GCC 11.2.0] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>(base)</code> 关键词是成功激活<code>conda</code>环境的关键标识,不同的虚拟环境标识会显示对应虚拟环境的名字，之后的文档都将会出现这样标识以指定<code>python</code>环境信息。</p>
</blockquote>
<p>如何卸载miniconda如下：</p>
<p>查看miniconda信息:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">(base) root@user-Super-Server:~<span class="comment"># conda info</span></span><br><span class="line"></span><br><span class="line">     active environment : base</span><br><span class="line">    active <span class="built_in">env</span> location : /root/miniconda3</span><br><span class="line">            shell level : 1</span><br><span class="line">       user config file : /root/.condarc</span><br><span class="line"> populated config files :</span><br><span class="line">          conda version : 24.1.2</span><br><span class="line">    conda-build version : not installed</span><br><span class="line">         python version : 3.10.13.final.0</span><br><span class="line">                 solver : libmamba (default)</span><br><span class="line">       virtual packages : __archspec=1=icelake</span><br><span class="line">                          __conda=24.1.2=0</span><br><span class="line">                          __cuda=12.2=0</span><br><span class="line">                          __glibc=2.31=0</span><br><span class="line">                          __linux=5.15.0=0</span><br><span class="line">                          __unix=0=0</span><br><span class="line">       base environment : /root/miniconda3  (writable)</span><br><span class="line">      conda av data <span class="built_in">dir</span> : /root/miniconda3/etc/conda</span><br><span class="line">  conda av metadata url : None</span><br><span class="line">           channel URLs : https://repo.anaconda.com/pkgs/main/linux-64</span><br><span class="line">                          https://repo.anaconda.com/pkgs/main/noarch</span><br><span class="line">                          https://repo.anaconda.com/pkgs/r/linux-64</span><br><span class="line">                          https://repo.anaconda.com/pkgs/r/noarch</span><br><span class="line">          package cache : /root/miniconda3/pkgs</span><br><span class="line">                          /root/.conda/pkgs</span><br><span class="line">       envs directories : /root/miniconda3/envs</span><br><span class="line">                          /root/.conda/envs</span><br><span class="line">               platform : linux-64</span><br><span class="line">             user-agent : conda/24.1.2 requests/2.31.0 CPython/3.10.13 Linux/5.15.0-97-generic ubuntu/20.04.6 glibc/2.31 solver/libmamba conda-libmamba-solver/23.12.0 libmambapy/1.5.3</span><br><span class="line">                UID:GID : 0:0</span><br><span class="line">             netrc file : None</span><br><span class="line">           offline mode : False</span><br></pre></td></tr></table></figure>

<p>进入安装目录后执行卸载命令:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">bash /path/to/miniconda3/uninstall-miniconda.sh -u</span><br></pre></td></tr></table></figure>

<p>随后手动清除对应的环境变量文件(~/.bashrc或/etc/profile)当中的内容之后重新加载环境变量文件<br>来更新配置:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">或</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><ul>
<li>创建虚拟环境: <code>conda create -n 环境名 python=3.9</code></li>
<li>进入虚拟环境: <code>conda activate 环境名</code></li>
<li>退出虚拟环境: <code>conda deactivate</code></li>
<li>查看虚拟环境列表: <code>conda env list</code></li>
<li>删除虚拟环境: <code>conda remove -n 环境名 --all</code> 或 <code>conda env remove --name 环境名</code></li>
<li>复制虚拟环境: <code>conda create -n 新环境名 --clone 旧环境名</code></li>
</ul>
<h3 id="安装python库等操作"><a href="#安装python库等操作" class="headerlink" title="安装python库等操作"></a>安装python库等操作</h3><p>安装可以使用pip安装或conda命令安装:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">pip install xxx</span><br><span class="line">conda install xxx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>conda不是python，conda是一个环境管理工具，conda命令安装的库稳定性更好更安全也更不容易在安装过程当中出错，并且conda当中包含很多属于自己的工具，但是pip作为python指定安装工具，包含更多更新的工具，也包含==未验证的工具==，两者在大多数时候可以搭配使用。</p>
</blockquote>
<p>安装速度过慢可以采用临时源解决：</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">pip install 指定安装的库 -i https://pypi.tuna.tsinghua.edu.cn/simple </span><br></pre></td></tr></table></figure>
<p>提供以下国内几种源:  </p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学: https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/ </span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>

<h4 id="必须安装的库"><a href="#必须安装的库" class="headerlink" title="必须安装的库"></a>必须安装的库</h4><p>项目当中往往需要使用到环境迁移配置好的环境想要进行有效迁移往往很麻烦，<code>conda</code>提供一个优秀的环境打包工具:<code>conda-pack</code>,该工具可以在同类型操作系统之间快速迁移<code>python</code>的工作环境，并且不会对原始环境有任何影响。</p>
<p>安装:</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">conda install conda-pack</span><br></pre></td></tr></table></figure>

<p>使用(激活conda环境后):</p>
<figure class="highlight bash"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">conda pack -n 环境名称</span><br><span class="line"><span class="comment"># -o 参数指定打包路径和名称，把虚拟环境 my_env 打包为 out_name.tar.gz</span></span><br><span class="line">conda pack -n 环境名称 -o out_name.tar.gz</span><br><span class="line"><span class="comment"># 把某个特定路径的虚拟环境打包为 my_env.tar.gz</span></span><br><span class="line">conda pack -p /explicit/path/to/环境名称</span><br></pre></td></tr></table></figure>

<p>迁移到其他机器上：</p>
<ul>
<li>进入对应的同操作系统类型机器</li>
<li>创建一个环境放置的目录</li>
<li>将condapack打包后的文件放置在该目录下后解压</li>
</ul>
<p>激活环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line"><span class="built_in">source</span> .../bin/activate</span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line">.../bin/activate/activate.bat</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>RGB与CMYK</title>
    <url>/2022/08/01/%E5%B7%A5%E5%85%B7-RGB%E4%B8%8ECMYK/</url>
    <content><![CDATA[<p>在最近的工作中经常遇到图像处理相关知识，因此做一个记录：</p>
<h3 id="RGB模式"><a href="#RGB模式" class="headerlink" title="RGB模式"></a>RGB模式</h3><p>RGB模式是以色光三原色为基础建立的色彩模式，RGB图像只使用三种颜色，当不等量的三种色光进行叠加混合时，即会在屏幕上重现自然界各种各样的颜色。红、绿、蓝每一种颜色各有256级亮度，用数字表示为从0、1、2…..直到255，256级的RGB色彩总共能组合出约1678万种色彩。RGB模式是电脑、手机、投影仪、电视等屏幕显示的最佳颜色模式。</p>
<h3 id="CMYK模式"><a href="#CMYK模式" class="headerlink" title="CMYK模式"></a>CMYK模式</h3><p>CMYK是4种印刷油墨名称的首字母：青色Cyan、洋红色Magenta、黄色Yellow和黑色Black。之所以没有缩写成B（Black），是为了和RGB的B区分开，此外表示K印版是起关键作用的印版，在图像中能起到一种”骨架”的作用。CMYK主要应用于印刷，它的颜色由四个通道组成。印刷时，C、M、Y、K各出一张菲林。</p>
<blockquote>
<p>两者都是作为计算机颜色的表示工具，前者更适合电脑，后者更适合打印，前者的色域更广，后者略微少，但是两者都有自己独特的色域。</p>
</blockquote>
<blockquote>
<p>补充</p>
</blockquote>
<h3 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h3><p>RGB 是以三原色为基础的图像，因此被成为三通道图，而灰度图就是单通道图，只有一个颜色阶级，因此图像总体呈现灰色。在一些算法或者特征提取的时候，总是要将图片转化为灰度图，这是因为相比于三通道，单通道能够减少运算量，利于梯度计算等优势。</p>
<h3 id="图像二值化"><a href="#图像二值化" class="headerlink" title="图像二值化"></a>图像二值化</h3><p>二值化就是将图像像素的灰度值设置成只有最大值和最小值两种取值，使整个图像呈现出 “非黑即白” 的效果，是最简单的图像分割的方法。相比于灰度图，图像二值化为了更加凸显图像的边缘、线条、轮廓，会将图像转变为仅有黑白两色的图像，使得图像更加利于计算。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx基础概念</title>
    <url>/2022/09/04/%E5%B7%A5%E5%85%B7-Nginx%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>在操作web的时候常常会遇到一个关键词叫做<code>Nginx</code>代理，或者说在提到负载均衡的时候也会提到这个关键词，但是很久都没有去关注这个是啥</p>
<h2 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是<code>Nginx</code></h2><p><code>Nginx</code>是一款轻量级的<code>Web服务器/反向代理服务器</code>及<code>电子邮件（IMAP/POP3）代理服务器</code>。<code>Nginx</code>本身是一个<code>web</code>服务器也可以用来做<strong>负载均衡</strong>及<strong>反向代理</strong>使用，目前使用最多的就是负载均衡。其特点是<strong>占有内存少</strong>，<strong>并发能力强</strong>。<code>nginx</code>的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p>
<p>这里涉及两个关键词，一个是<strong>负载均衡</strong>，另一个是<strong>反向代理</strong>。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><strong>负载均衡（Load Balance，简称 LB）</strong>是高并发、高可用系统必不可少的关键组件，目标是尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性。当服务端涉及多个服务器的时候，每一个服务器所能够接受或者处理数据的能力是不同的，因此负载均衡就是需要根据不同服务器的性能状态分配给不同的服务器不同的数据处理量，实现动态的维护整体工作效率。</p>
<p>负载均衡的主要作用如下：</p>
<ul>
<li><strong>高并发：</strong> 负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。</li>
<li><strong>伸缩性：</strong> 添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li>
<li><strong>高可用：</strong> 负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li>
<li><strong>安全防护：</strong> 有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li>
</ul>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p><strong>反向代理（Reverse Proxy）</strong>实际运行方式是指以代理服务器来接受<code>internet</code>上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给<code>internet</code>上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>简单来说就是在互联网上的资源需要通过一个中间服务器作为跳板才能将数据正常返回到我们的客户端电脑上，当数据传输面临某些限制或者需要负载均衡的时候就需要这样一个服务器作为数据传输的桥梁。反向代理具有以下特点：</p>
<ul>
<li>使用反向代理，可以对客户端隐藏服务器的IP地址 。保证内网的安全，阻止web攻击，大型网站通常将反向代理作为公网访问地址，Web服务器是内网。</li>
<li>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。</li>
<li>为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</li>
<li>负载均衡，通过反向代理服务器来优化网站的负载。反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上</li>
<li>提高访问速度：反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li>
</ul>
<h2 id="Nginx使用场景"><a href="#Nginx使用场景" class="headerlink" title="Nginx使用场景"></a><code>Nginx</code>使用场景</h2><!-- Nginx包含负载均衡以及反向代理的作用， -->

<p>在实际开发过程当中，以前的时候可能是一个服务器作为服务端。但是伴随着工作业务的扩展，带来一个问题，访问量不够了，需要更多的计算资源。当涉及到添加多台服务器用于处理数据的时候需要考虑到以下几个问题：</p>
<ul>
<li>多台服务器需要一个统一的出口保证数据不会混乱</li>
<li>多台服务器需要被管理</li>
<li>服务器硬件的差异导致整体工作效率有差异，需要动态调整</li>
</ul>
<p>而这些问题恰好可以被Nginx解决，在部署过程当中，可以将多台2服务器当中的某一台作为代理服务器，在代理服务器上安装Nginx。</p>
<p>而Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。</p>
<hr>
<p>轮询指的是后台有多个服务器，代理服务器按照顺序给每一个服务发送请求。而加权轮询则是根据每一个服务器的权重不同，分配不同量级的请求。</p>
<p>并且有一点值得注意的是，网站的资源分为动态资源与静态资源，动态资源是需要通过后台服务器计算的资源，而静态资源是不需要计算的资源，可以直接访问服务器的资源。因此可以在代理服务器上做动静分离操作，静态资源直接访问静态资源对应的服务器，反之亦如此。</p>
<blockquote>
<p> 动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>decouple库介绍</title>
    <url>/2025/02/15/%E5%B7%A5%E5%85%B7-decouple%E5%BA%93%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="python-decouple：简化配置管理的利器"><a href="#python-decouple：简化配置管理的利器" class="headerlink" title="python-decouple：简化配置管理的利器"></a>python-decouple：简化配置管理的利器</h2><p>在现代软件开发中，合理地管理配置文件是确保项目安全性和可维护性的关键。<code>python-decouple</code>是一个强大的库，它帮助开发者将配置信息从代码中分离出来，使得项目更加灵活和安全。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装<code>python-decouple</code>非常简单，只需一条pip命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install python-decouple</span><br></pre></td></tr></table></figure>

<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ul>
<li><strong>简化配置管理</strong>：通过简单易用的API，方便开发者管理配置信息。</li>
<li><strong>解耦配置与代码</strong>：避免硬编码配置，提高代码的可维护性。</li>
<li><strong>支持多种文件格式</strong>：支持读取和解析多种配置文件格式，如<code>.env</code>、<code>.ini</code>、<code>.yaml</code>等。</li>
<li><strong>增强安全性</strong>：安全地存储敏感信息，如密码、API密钥等。</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>在项目根目录下创建一个<code>.env</code>文件，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># .env文件内容示例</span><br><span class="line">DEBUG=True</span><br><span class="line">SECRET_KEY=supersecretkey</span><br><span class="line">DATABASE_URL=postgresql://user:pass@localhost/mydb</span><br></pre></td></tr></table></figure>

<h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><p>使用<code>python-decouple</code>读取配置文件中的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decouple <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置信息</span></span><br><span class="line">debug_mode = config(<span class="string">&#x27;DEBUG&#x27;</span>, cast=<span class="built_in">bool</span>)</span><br><span class="line">secret_key = config(<span class="string">&#x27;SECRET_KEY&#x27;</span>)</span><br><span class="line">db_url = config(<span class="string">&#x27;DATABASE_URL&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用<code>config</code>函数读取<code>.env</code>文件中的配置信息，并通过<code>cast=bool</code>将<code>DEBUG</code>的值转换为布尔类型。</p>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="支持不同配置文件格式"><a href="#支持不同配置文件格式" class="headerlink" title="支持不同配置文件格式"></a>支持不同配置文件格式</h3><p><code>python-decouple</code>不仅限于<code>.env</code>文件，它还支持<code>.ini</code>和<code>.yaml</code>等格式。例如，使用<code>.ini</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decouple <span class="keyword">import</span> Config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Config对象并读取.ini格式配置文件</span></span><br><span class="line">config = Config(<span class="string">&#x27;settings.ini&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置信息</span></span><br><span class="line">debug_mode = config(<span class="string">&#x27;DEBUG&#x27;</span>, cast=<span class="built_in">bool</span>)</span><br><span class="line">secret_key = config(<span class="string">&#x27;SECRET_KEY&#x27;</span>)</span><br><span class="line">db_url = config(<span class="string">&#x27;DATABASE_URL&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="环境变量覆盖"><a href="#环境变量覆盖" class="headerlink" title="环境变量覆盖"></a>环境变量覆盖</h3><p><code>python-decouple</code>允许环境变量覆盖配置文件中的值，这在不同环境（如开发、测试、生产）中非常有用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decouple <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取环境变量或配置文件中的值</span></span><br><span class="line">debug_mode = config(<span class="string">&#x27;DEBUG&#x27;</span>, default=<span class="literal">False</span>, cast=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>

<p>如果环境变量<code>DEBUG</code>存在，它将覆盖<code>.env</code>文件中的值。</p>
<h3 id="安全存储敏感信息"><a href="#安全存储敏感信息" class="headerlink" title="安全存储敏感信息"></a>安全存储敏感信息</h3><p>对于敏感信息，<code>python-decouple</code>提供了安全存储的解决方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decouple <span class="keyword">import</span> Config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Config对象并读取加密配置信息</span></span><br><span class="line">config = Config(<span class="string">&#x27;secrets.enc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密并读取配置信息</span></span><br><span class="line">secret_key = config(<span class="string">&#x27;SECRET_KEY&#x27;</span>, default=<span class="string">&#x27;defaultkey&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过加密配置文件，敏感信息得到保护。</p>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><h3 id="Django项目配置"><a href="#Django项目配置" class="headerlink" title="Django项目配置"></a>Django项目配置</h3><p>在Django项目中，使用<code>python-decouple</code>管理数据库连接、调试模式等配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> decouple <span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置信息</span></span><br><span class="line">db_url = config(<span class="string">&#x27;DATABASE_URL&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Django环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;myproject.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取WSGI应用</span></span><br><span class="line">application = get_wsgi_application()</span><br></pre></td></tr></table></figure>

<h3 id="Flask应用配置"><a href="#Flask应用配置" class="headerlink" title="Flask应用配置"></a>Flask应用配置</h3><p>在Flask应用中，配置密钥、API地址等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> decouple <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置信息</span></span><br><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = config(<span class="string">&#x27;SECRET_KEY&#x27;</span>)</span><br><span class="line">app.config[<span class="string">&#x27;API_URL&#x27;</span>] = config(<span class="string">&#x27;API_URL&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=config(<span class="string">&#x27;DEBUG&#x27;</span>, default=<span class="literal">True</span>, cast=<span class="built_in">bool</span>))</span><br></pre></td></tr></table></figure>

<h3 id="DevOps环境配置"><a href="#DevOps环境配置" class="headerlink" title="DevOps环境配置"></a>DevOps环境配置</h3><p>在DevOps环境中，配置服务器地址、API密钥等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decouple <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置信息</span></span><br><span class="line">server_url = config(<span class="string">&#x27;SERVER_URL&#x27;</span>)</span><br><span class="line">api_key = config(<span class="string">&#x27;API_KEY&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据环境配置部署</span></span><br><span class="line">env = config(<span class="string">&#x27;ENV&#x27;</span>, default=<span class="string">&#x27;development&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> env == <span class="string">&#x27;production&#x27;</span>:</span><br><span class="line">    deploy_to_production(server_url, api_key)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    deploy_to_staging(server_url, api_key)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>python-decouple</code>是一个功能强大的配置管理工具，它通过解耦配置信息和代码，提高了项目的可维护性和安全性。支持多种配置文件格式和环境变量管理，使得它在Django、Flask等项目中非常有用。通过<code>python-decouple</code>，开发者可以轻松管理敏感信息，并在不同环境下灵活配置项目。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>md5加密与AES加密</title>
    <url>/2022/08/21/%E5%B7%A5%E5%85%B7-md5%E5%8A%A0%E5%AF%86%E4%B8%8EAES%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h2 id="md5加密"><a href="#md5加密" class="headerlink" title="md5加密"></a>md5加密</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>消息摘要算法第五版（英语：Message-Digest Algorithm 5，缩写为MD5），是当前计算机领域用于确保信息传输完整一致而广泛使用的散列算法之一（又译哈希算法、摘要算法等），主流编程语言普遍已有MD5的实现。将数据 （如一段文字）运算变为另一固定长度值，是散列算法的基础原理，MD5的前身有MD2、MD3和MD4。MD5由MD4、MD3、MD2改进而来，主要增强算法复杂度和不可逆性。目前，MD5算法因其普遍、稳定、快速的特点，仍广泛应用于普通 数据的错误检查领域。例如在一些BitTorrent下载中，软件将通过计算MD5检验下载到的文件片段的完整性。MD5已经广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供一个MD5校验和，用户下载完文件以后， 用MD5算法计算下载文件的MD5校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。MD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算,得出结果。</p>
<h3 id="md5算法描述"><a href="#md5算法描述" class="headerlink" title="md5算法描述"></a>md5算法描述</h3><p>假设输入信息(input message)的长度为b(bit)，我们想要产生它的报文摘要，在此处b为任意的非负整数：b也可能为0，也不一定为8的整数倍，且可能是任意大的长度。设该信息的比特流表示如下： M[0] M[1] M[2] … M[b-1] 计算此信息的报文摘要需要如下5步：</p>
<h4 id="补位"><a href="#补位" class="headerlink" title="补位"></a>补位</h4><p>信息计算前先要进行位补位，设补位后信息的长度为LEN(bit)，则LEN%512 = 448(bit)，即数据扩展至 K * 512 + 448(bit)。即K * 64+56(byte)，K为整数。补位操作始终要执行，即使补位前信息的长度对512求余的结果是448。具体补位操作：补一个1，然后补0至满足上述要求。总共最少要补1bit，最多补512bit。</p>
<h4 id="尾部加上信息长度"><a href="#尾部加上信息长度" class="headerlink" title="尾部加上信息长度"></a>尾部加上信息长度</h4><p>将输入信息的原始长度b(bit)表示成一个64-bit的数字，把它添加到上一步的结果后面(在32位的机器上，这64位将用2个字来表示并且低位在前)。当遇到b大于2^64这种极少的情况时，b的高位被截去，仅使用b的低64位。经过上面两步，数据就被填补成长度为512(bit)的倍数。也就是说，此时的数据长度是16个字(32byte)的整数倍。此时的数据表示为： M[0 … N-1] 其中的N是16的倍数。</p>
<h4 id="初始化缓存区"><a href="#初始化缓存区" class="headerlink" title="初始化缓存区"></a>初始化缓存区</h4><p>用一个四个字的缓冲器(A，B，C，D)来计算报文摘要，A,B,C,D分别是32位的寄存器，初始化使用的是十六进制表示的数字，注意低字节在前：<br>        word A: 01 23 45 67<br>        word B: 89 ab cd ef<br>        word C: fe dc ba 98<br>        word D: 76 54 32 10</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>首先定义4个辅助函数，每个函数的输入是三个32位的字，输出是一个32位的字：<br>        F(X,Y,Z) = XY v not(X) Z<br>        G(X,Y,Z) = XZ v Y not(Z)<br>        H(X,Y,Z) = X xor Y xor Z<br>        I(X,Y,Z) = Y xor (X v not(Z))</p>
<pre><code>    FF(a,b,c,d,Mj,s,ti）表示 a = b + ((a + F(b,c,d) + Mj + ti) &lt;&lt; s)
    GG(a,b,c,d,Mj,s,ti）表示 a = b + ((a + G(b,c,d) + Mj + ti) &lt;&lt; s)
    HH(a,b,c,d,Mj,s,ti）表示 a = b + ((a + H(b,c,d) + Mj + ti) &lt;&lt; s)
    Ⅱ（a,b,c,d,Mj,s,ti）表示 a = b + ((a + I(b,c,d) + Mj + ti) &lt;&lt; s)
</code></pre>
<p>这四轮（64步）是：</p>
<p>第一轮</p>
<p>FF(a,b,c,d,M0,7,0xd76aa478）<br>FF(d,a,b,c,M1,12,0xe8c7b756）<br>FF(c,d,a,b,M2,17,0x242070db)<br>FF(b,c,d,a,M3,22,0xc1bdceee)<br>FF(a,b,c,d,M4,7,0xf57c0faf)<br>FF(d,a,b,c,M5,12,0x4787c62a)<br>FF(c,d,a,b,M6,17,0xa8304613）<br>FF(b,c,d,a,M7,22,0xfd469501）<br>FF(a,b,c,d,M8,7,0x698098d8）<br>FF(d,a,b,c,M9,12,0x8b44f7af)<br>FF(c,d,a,b,M10,17,0xffff5bb1）<br>FF(b,c,d,a,M11,22,0x895cd7be)<br>FF(a,b,c,d,M12,7,0x6b901122）<br>FF(d,a,b,c,M13,12,0xfd987193）<br>FF(c,d,a,b,M14,17,0xa679438e)<br>FF(b,c,d,a,M15,22,0x49b40821）</p>
<p>第二轮</p>
<p>GG(a,b,c,d,M1,5,0xf61e2562）<br>GG(d,a,b,c,M6,9,0xc040b340）<br>GG(c,d,a,b,M11,14,0x265e5a51）<br>GG(b,c,d,a,M0,20,0xe9b6c7aa)<br>GG(a,b,c,d,M5,5,0xd62f105d)<br>GG(d,a,b,c,M10,9,0x02441453）<br>GG(c,d,a,b,M15,14,0xd8a1e681）<br>GG(b,c,d,a,M4,20,0xe7d3fbc8）<br>GG(a,b,c,d,M9,5,0x21e1cde6）<br>GG(d,a,b,c,M14,9,0xc33707d6）<br>GG(c,d,a,b,M3,14,0xf4d50d87）<br>GG(b,c,d,a,M8,20,0x455a14ed)<br>GG(a,b,c,d,M13,5,0xa9e3e905）<br>GG(d,a,b,c,M2,9,0xfcefa3f8）<br>GG(c,d,a,b,M7,14,0x676f02d9）<br>GG(b,c,d,a,M12,20,0x8d2a4c8a)</p>
<p>第三轮</p>
<p>HH(a,b,c,d,M5,4,0xfffa3942）<br>HH(d,a,b,c,M8,11,0x8771f681）<br>HH(c,d,a,b,M11,16,0x6d9d6122）<br>HH(b,c,d,a,M14,23,0xfde5380c)<br>HH(a,b,c,d,M1,4,0xa4beea44）<br>HH(d,a,b,c,M4,11,0x4bdecfa9）<br>HH(c,d,a,b,M7,16,0xf6bb4b60）<br>HH(b,c,d,a,M10,23,0xbebfbc70）<br>HH(a,b,c,d,M13,4,0x289b7ec6）<br>HH(d,a,b,c,M0,11,0xeaa127fa)<br>HH(c,d,a,b,M3,16,0xd4ef3085）<br>HH(b,c,d,a,M6,23,0x04881d05）<br>HH(a,b,c,d,M9,4,0xd9d4d039）<br>HH(d,a,b,c,M12,11,0xe6db99e5）<br>HH(c,d,a,b,M15,16,0x1fa27cf8）<br>HH(b,c,d,a,M2,23,0xc4ac5665）</p>
<p>第四轮</p>
<p>Ⅱ（a,b,c,d,M0,6,0xf4292244）<br>Ⅱ（d,a,b,c,M7,10,0x432aff97）<br>Ⅱ（c,d,a,b,M14,15,0xab9423a7）<br>Ⅱ（b,c,d,a,M5,21,0xfc93a039）<br>Ⅱ（a,b,c,d,M12,6,0x655b59c3）<br>Ⅱ（d,a,b,c,M3,10,0x8f0ccc92）<br>Ⅱ（c,d,a,b,M10,15,0xffeff47d)<br>Ⅱ（b,c,d,a,M1,21,0x85845dd1）<br>Ⅱ（a,b,c,d,M8,6,0x6fa87e4f)<br>Ⅱ（d,a,b,c,M15,10,0xfe2ce6e0)<br>Ⅱ（c,d,a,b,M6,15,0xa3014314）<br>Ⅱ（b,c,d,a,M13,21,0x4e0811a1）<br>Ⅱ（a,b,c,d,M4,6,0xf7537e82）<br>Ⅱ（d,a,b,c,M11,10,0xbd3af235）<br>Ⅱ（c,d,a,b,M2,15,0x2ad7d2bb)<br>Ⅱ（b,c,d,a,M9,21,0xeb86d391）</p>
<h3 id="MD5算法总结"><a href="#MD5算法总结" class="headerlink" title="MD5算法总结"></a>MD5算法总结</h3><p>MD5算法本质上是将数据按照长度进行补位后，成为可以被算法处理长度的数据，然后按照64字节也就是512位进行切割，切割后会对每一个64字节进行计算。第一次计算会输入四个长度为16字节的固定幻数，每一次计算完成后也会得到相应的四个数，并将计算结果用于下一个64字节计算的输入值，反复如此直到所有的字节全部被运算完毕，最后得出的值就是加密后的结果。正式因为设计到长度和反复计算，因此每增加一个或者减少一个字节都会对最后结果产生巨大影响。</p>
<h2 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h2><p>AES是一种经典的对称加密算法，也是一种区块加密算法，对称加密算法是指加密解密使用的是同一个密钥，区块加密指的是加密过程当中会将加密对象切分成块进程逐步加密，AES加密过程当中区块长出被限制在128位，但是密码长度有三种可选，分别是：128位、192位、256位。</p>
<h2 id="加密计算过程"><a href="#加密计算过程" class="headerlink" title="加密计算过程"></a>加密计算过程</h2><p>以128位为例，加密过程是以126位一块明文信息与128位密钥作为输入，得出128位的密文信息，在加密过程当中明文区块会经过十一次计算才能得出最后结果。而原始的密钥会在这个过程当中生成11个子密码分别参与到该过程当中。</p>
<p>十一步的第一步是是对加密信息进行诸位异或运算，接着是对同一个子模块循环递归十次计算。在加密子模块当中一共有四步操作，前三次分别是非线性运算-&gt;线性运算-&gt;非线性运算，最后是异或运算，输入的内容依然是明文与密钥，但是密钥仅仅参与最后一次异或运算当中。</p>
<h3 id="第一次线性运算"><a href="#第一次线性运算" class="headerlink" title="第一次线性运算"></a>第一次线性运算</h3><p>第一次的线性运算hui将输入的值也就是一个128位16比特的数据按照矩阵进行排列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B1 B5 B9 B13  </span><br><span class="line">B2 B6 B10 B14  </span><br><span class="line">B3 B7 B11 B15  </span><br><span class="line">B4 B8 B12 B16  </span><br></pre></td></tr></table></figure>

<p>随后这个矩阵会被一个固定的映射表按照对应的映射关系替换掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A1 A5 A9 A13  </span><br><span class="line">A2 A6 A10 A14  </span><br><span class="line">A3 A7 A11 A15  </span><br><span class="line">A4 A8 A12 A16  </span><br></pre></td></tr></table></figure>

<h3 id="第二次运算"><a href="#第二次运算" class="headerlink" title="第二次运算"></a>第二次运算</h3><p>第二次运算将改变矩阵结构对每一行进行移位得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A1 A5 A9 A13  </span><br><span class="line">A6 A10 A14 A2  </span><br><span class="line">A11 A15 A3 A7  </span><br><span class="line">A16 A4 A8 A12 </span><br></pre></td></tr></table></figure>

<p>也就是第一行第0个移到第一行的最右边，第二行移1个，第三行2个，第四行3个。</p>
<h3 id="第三次运算"><a href="#第三次运算" class="headerlink" title="第三次运算"></a>第三次运算</h3><p>第三次运算会诸列取出数据，并将每一列与一个4x4的矩阵进程乘法操作，然后将结果放回矩阵当中，由此三次运算结束。</p>
<p>反复进过多次加密子模块的处理后，最终输出加密密文。</p>
<h2 id="python-AES-加密"><a href="#python-AES-加密" class="headerlink" title="python AES 加密"></a>python AES 加密</h2><p>最后附上python的AES加密</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&#x27;1234567812345678&#x27;</span> <span class="comment">#秘钥，b就是表示为bytes类型</span></span><br><span class="line">text = <span class="string">b&#x27;abcdefghijklmnhi&#x27;</span> <span class="comment">#需要加密的内容，bytes类型</span></span><br><span class="line">aes = AES.new(password,AES.MODE_ECB) <span class="comment">#创建一个aes对象</span></span><br><span class="line"><span class="comment"># AES.MODE_ECB 表示模式是ECB模式</span></span><br><span class="line">en_text = aes.encrypt(text) <span class="comment">#加密明文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;密文：&quot;</span>,en_text) <span class="comment">#加密明文，bytes类型</span></span><br><span class="line">den_text = aes.decrypt(en_text) <span class="comment"># 解密密文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明文：&quot;</span>,den_text)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j基础</title>
    <url>/2022/09/03/%E5%B7%A5%E5%85%B7-neo4j%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>曾经使用neo4j实现了一个娱乐圈明星关系网络，那次在安装的时候耗费了我一上午的时间，距离上次使用之后我已经一年没使用过了，忘得差不多了，现在有需要要重新使用neo4j。再次使用docker安装使用想要记录一下。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="neo4j简介"><a href="#neo4j简介" class="headerlink" title="neo4j简介"></a><code>neo4j</code>简介</h3><p><code>neo4j</code>是一种图数据库，与常见的关系型数据库不同，图数据库不以表结构存储数据。图数据库本身属于<code>NoSql</code>数据库中的一种，是基于数学中图论实现的一种数据库。图数据库将数据和数据之间的关系存在节点和边中，在图数据库中这被称作<strong>节点</strong>和<strong>关系</strong>。没有了库表字段的概念，相当于是把数据存在了一张大宽表中。</p>
<p><code>Neo4j</code>是图数据库中一个主要代表，其开源，且用<code>Java</code>实现。经过几年的发展，已经可以用于生产环境。其有两种运行方式，一种是服务的方式，对外提供REST接口；另外一种是嵌入式模式，数据以文件的形式存放在本地，可以直接对本地文件进行操作。</p>
<p>举一个简单但不是很恰当的案例，图数据库将数据按<strong>图数据结构</strong>进行存储数据，按数据节点与关系进行存储，保存节点和关系的数据以及其属性信息。</p>
<hr>
<h3 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h3><p><code>docker</code>的英文意思是 码头工人，意思就是搬运东西的意思，其实这和<code>docker</code>的特点是一样的，<code>docker</code>提供的就是一种容器化搬运东西（我们的软件、程序）的过程。<code>docker</code>自己本来是运行在操作系统上一个程序软件，它会提供一个容器环境，使我们的程序独立地运行在容器中。</p>
<p>举一个简单但不是很恰当的案例，如果需要拷贝自己电脑上的环境给别人，最好的办法是把环境搞成虚拟机，直接把虚拟机给别人，但是这样太过于庞大。<code>docker</code>创建了一个容器，可以达到仅仅拷贝环境就行的程度，并且这个容器可以被迁移到其他有<code>docker</code>的机器上正常运行。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于自己是基于docker进行安装的，所以安装十分简单,访问docker<a href="https://hub.docker.com/_/neo4j">官网</a>,按照教程输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">docker pull neo4j</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run --publish=7474:7474 --publish=7687:7687 --volume=<span class="variable">$HOME</span>/neo4j/data:/data neo4j</span><br></pre></td></tr></table></figure>

<p>安装启动好之后，需要访问对应端口设置账号密码，初始帐号密码为：<code>neo4j/neo4j</code></p>
<blockquote>
<p>个人推荐通过portainer管理docker</p>
</blockquote>
<h2 id="基础语法-增删改查"><a href="#基础语法-增删改查" class="headerlink" title="基础语法(增删改查)"></a>基础语法(增删改查)</h2><p>neo4j的语法非常简单，语法本身就像画图一样，这里只列举简单操作。</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>作为图数据库，一定存在两种对象，一是节点，二是关系。当需要创建节点时候需要明确节点信息，假设我们需要创建一个<strong>Cat</strong>类别，并且具有以下属性的节点：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;tom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span><span class="string">&quot;blue&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;1940-?&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">92</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="string">&quot;man&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hobby&quot;</span><span class="punctuation">:</span><span class="string">&quot;Catch mice&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>改写成数据库语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> (n:Cat &#123;name:&quot;tom&quot;,color:&quot;blue&quot;,age:&quot;1940-?&quot;,height:<span class="number">92</span>,sex:&quot;man&quot;,hobby:&quot;Catch mice&quot;&#125;) <span class="keyword">return</span> n;</span><br></pre></td></tr></table></figure>

<p>其中Cat是属性，n是对当前节点起的别名，其他字母也行，注意return的时候一致。</p>
<hr>
<p>对于关系，一样的有这样的信息，因此sql语句也类似。但是关系不是凭空出现的，一定是两个节点存在才能够创建关系，因此要么创建关系的时候也创建节点，要么就需要优先找到关系，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MATCH</span> (a:Cat), (b:Mouse) <span class="keyword">WHERE</span> a.name <span class="operator">=</span> &quot;tom&quot; <span class="keyword">AND</span> b.name <span class="operator">=</span> &quot;jerry&quot; </span><br><span class="line"><span class="keyword">CREATE</span> (a)<span class="operator">-</span>[r:Catch &#123;<span class="keyword">function</span>:&quot;chase&quot;&#125;]<span class="operator">-</span><span class="operator">&gt;</span>(b) </span><br><span class="line"><span class="keyword">RETURN</span> a, b</span><br></pre></td></tr></table></figure>

<p>如果没有节点就想要关系，就需要创建节点的时候一并创建关系,简写如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (fb1:FaceBookProfile1)<span class="operator">-</span>[<span class="keyword">like</span>:LIKES]<span class="operator">-</span><span class="operator">&gt;</span>(fb2:FaceBookProfile2) </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>关系的创建只能够单向创建，不能够创建双向关系。</p>
</blockquote>
<p>就这么简单，像画图一样</p>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>对于删除，涉及到删除节点、删除关系、删除属性，其中删除节点与删除关系类似。但是删除了节点之后，节点附带的所有关系也会被一并删除，因此删除节点需要十分小心。</p>
<p>删除节点或者关系：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MATCH</span>(node:Cat&#123;name:&quot;Tom&quot;&#125;)</span><br><span class="line">DETACH <span class="keyword">DELETE</span> node</span><br></pre></td></tr></table></figure>

<p>这种删除模式本质上都是先找定位到这个节点或者关系，然后删除掉。</p>
<hr>
<p>当涉及到删除其属性信息的时候语法需要做一点点改变:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MATCH</span>(node:Cat)</span><br><span class="line">REMOVE node.property_name </span><br><span class="line"><span class="comment">-- 或者可以将属性制空</span></span><br><span class="line"><span class="keyword">MATCH</span>(node:Cat)</span><br><span class="line"><span class="keyword">SET</span> node.name <span class="operator">=</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">return</span>  node</span><br></pre></td></tr></table></figure>

<hr>
<p>最后说一种，由于自己是实验，因此常常用到全部删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> (n) detach <span class="keyword">delete</span> n</span><br></pre></td></tr></table></figure>

<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>修改一般来说就是修改属性信息，关系的指向不能够被修改，只能删除重建。修改属性如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MATCH</span>(node:Cat)</span><br><span class="line"><span class="keyword">SET</span> node.mood <span class="operator">=</span> good</span><br><span class="line"><span class="keyword">return</span>  node</span><br></pre></td></tr></table></figure>

<p>新增亦如此</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>查询其实在上面已经被提及过了即<code>MATCH</code>，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MATCH</span>(node:Cat) <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>以上仅为简单使用操作</strong></p>
</blockquote>
<h2 id="python操作"><a href="#python操作" class="headerlink" title="python操作"></a>python操作</h2><p>python当中很早便为neo4j提供了便利的操作API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> py2neo <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line">graph = Graph(<span class="string">&quot;http://localhost:7474&quot;</span>, auth=(<span class="string">&quot;neo4j&quot;</span>, <span class="string">&quot;test123&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>python 当中既包含操作的函数同时也提供直接的sql语句操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = Node(<span class="string">&quot;概念&quot;</span>, name=<span class="string">&quot;向量&quot;</span>, chapter = <span class="number">1</span> , ID = <span class="number">100</span>)</span><br><span class="line">B = Node(<span class="string">&quot;属性&quot;</span>, name=<span class="string">&quot;向量叉积&quot;</span>, chapter = <span class="number">2</span> , ID = <span class="number">99</span>)</span><br><span class="line">graph.create(A)</span><br><span class="line">graph.create(B)</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph_.run(<span class="string">&#x27;MATCH (n) detach delete n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>篇幅所限就不展开详述讲解了</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>Neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>minio</title>
    <url>/2022/11/14/%E5%B7%A5%E5%85%B7-minio/</url>
    <content><![CDATA[<h1 id="对象存储MinIO入门介绍"><a href="#对象存储MinIO入门介绍" class="headerlink" title="对象存储MinIO入门介绍"></a>对象存储MinIO入门介绍</h1><h2 id="常见的对象存储方式对比"><a href="#常见的对象存储方式对比" class="headerlink" title="常见的对象存储方式对比"></a>常见的对象存储方式对比</h2><ul>
<li><p>直接将图片保存到服务的硬盘</p>
<ul>
<li>优点：开发便捷，成本低</li>
<li>缺点：扩容困难</li>
</ul>
</li>
<li><p>使用分布式文件系统进行存储</p>
<ul>
<li>优点：容易实现扩容</li>
<li>缺点：开发复杂度稍大（尤其是开发复杂的功能）</li>
</ul>
</li>
<li><p>使用nfs做存储</p>
<ul>
<li>优点：开发较为便捷</li>
<li>缺点：需要有一定的运维知识进行部署和维护</li>
</ul>
</li>
<li><p>使用第三方的存储服务</p>
<ul>
<li>优点：开发简单，拥有强大功能，免维护</li>
<li>缺点：付费</li>
</ul>
</li>
</ul>
<h2 id="对象存储MinIO"><a href="#对象存储MinIO" class="headerlink" title="对象存储MinIO"></a>对象存储MinIO</h2><p>MinIO是世界上最快的对象存储服务器，在标准硬件上，读写速度分贝为183GB/s 和 171GB/s，对象存储可以作为主要存储层，用于Spark，Presto，TensorFlow，H20.ai 以及替代产品等各种工作负载用于Hadoop HDFS</p>
<p>MinIO是一种高性能的分布式对象存储系统，它是软件定义的，可在行业标准硬件上运行，并且在Apache 2.0许可下，百分百开放源代码。</p>
<p>文档地址：<a href="https://docs.min.io/cn/">https://docs.min.io/cn/</a></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>set_your_key_here使用的是Docker的方式安装MinIO，首先拉取对应的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure>

<p>然后set_your_key_here需要创建两个目录，用于保存set_your_key_here的文件和配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /home/minio/data</span><br><span class="line"><span class="built_in">mkdir</span> -p /home/minio/config</span><br></pre></td></tr></table></figure>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器，后面有个目录，就是需要挂载的硬盘目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 9000:9000 --name minio \</span><br><span class="line">-e <span class="string">&quot;MINIO_ACCESS_KEY=set_your_key_here&quot;</span> \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-e <span class="string">&quot;MINIO_SECRET_KEY=set_your_key_here&quot;</span> \</span><br><span class="line">-v /home/minio/data:/data \</span><br><span class="line">-v /home/minio/config:/root/.minio \</span><br><span class="line">minio/minio server /data</span><br></pre></td></tr></table></figure>

<p>上面的配置中，包含两个重要的信息【以后登录时会用到，可以修改成自己的】</p>
<ul>
<li>MINIO_ACCESS_KEY：公钥</li>
<li>MINIO_SECRET_KEY：密钥</li>
</ul>
<p>如果需要后台运行，使用这条语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --privileged -d -it -p 9000:9000 --name minio \</span><br><span class="line">-e <span class="string">&quot;MINIO_ACCESS_KEY=set_your_key_here&quot;</span> \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-e <span class="string">&quot;MINIO_SECRET_KEY=set_your_key_here&quot;</span> \</span><br><span class="line">-v /home/minio/data:/data \</span><br><span class="line">-v /home/minio/config:/root/.minio \</span><br><span class="line">minio/minio server /data</span><br></pre></td></tr></table></figure>

<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>成功启动之后就可以在相对应的端口打开对应的web界面了。这里指定port为9000，实际情况可以自己随意调整。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>minio</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv识别颜色与线段</title>
    <url>/2022/09/07/%E5%B7%A5%E5%85%B7-opencv%E8%AF%86%E5%88%AB%E9%A2%9C%E8%89%B2%E4%B8%8E%E7%BA%BF%E6%AE%B5/</url>
    <content><![CDATA[<p>在使用opencv的过程中，实际情况常常需要对线段、圆形、颜色等条件的判断，但是网上多给出一些图像处理的数据，没有给出我需要的判定结果。在尝试后记录了两端代码供之后使用</p>
<h2 id="对于线段的判断"><a href="#对于线段的判断" class="headerlink" title="对于线段的判断"></a>对于线段的判断</h2><p>输出结果为线段长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;data/img/file.jpeg&quot;</span>)</span><br><span class="line">img=img[<span class="number">0</span>:<span class="built_in">int</span>(img.shape[<span class="number">0</span>]*<span class="number">0.9</span>),<span class="number">0</span>:<span class="built_in">int</span>(img.shape[<span class="number">1</span>]*<span class="number">0.9</span>)]</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>, apertureSize=<span class="number">3</span>)</span><br><span class="line">lines = cv2.HoughLinesP(edges,<span class="number">1</span>,np.pi/<span class="number">360</span>,<span class="number">100</span>,minLineLength=<span class="built_in">int</span>(img.shape[<span class="number">1</span>]*<span class="number">0.7</span>),maxLineGap=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_line</span>(<span class="params">img,lines</span>):</span><br><span class="line">    <span class="comment"># 绘制直线</span></span><br><span class="line">    <span class="keyword">for</span> line_points <span class="keyword">in</span> lines:</span><br><span class="line">        lenth = (line_points.<span class="built_in">max</span>()-line_points.<span class="built_in">min</span>())/img.shape[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(lenth)</span><br><span class="line">        cv2.line(img,(line_points[<span class="number">0</span>][<span class="number">0</span>],line_points[<span class="number">0</span>][<span class="number">1</span>]),(line_points[<span class="number">0</span>][<span class="number">2</span>],line_points[<span class="number">0</span>][<span class="number">3</span>]),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;line_img&quot;</span>, img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">draw_line(img,lines)</span><br></pre></td></tr></table></figure>

<h2 id="对于颜色判断"><a href="#对于颜色判断" class="headerlink" title="对于颜色判断"></a>对于颜色判断</h2><p>红色的色域十分特殊，有两端色域，因此需要将两次结果相加，但是需要注意的是，图像上呈现的视觉颜色并不一定是色域颜色，你看到蓝色可能是参杂了红色的蓝色，因此判断可能会有一点点误差。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">red_img</span>(<span class="params">path:<span class="built_in">str</span>=<span class="string">&quot;data/img/file.jpeg&quot;</span></span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">    img = cv2.imread(path)</span><br><span class="line">    img=img[<span class="number">0</span>:<span class="built_in">int</span>(img.shape[<span class="number">0</span>]/<span class="number">3</span>),<span class="number">0</span>:<span class="built_in">int</span>(img.shape[<span class="number">1</span>]/<span class="number">10</span>)]  <span class="comment">#高，宽</span></span><br><span class="line">    <span class="comment"># 在彩色图像的情况下，解码图像将以b g r顺序存储通道。</span></span><br><span class="line">    grid_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从RGB色彩空间转换到HSV色彩空间</span></span><br><span class="line">    grid_HSV = cv2.cvtColor(grid_RGB, cv2.COLOR_RGB2HSV)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数inRange将不是这个色域的地方全部改为0，因此可以通过这样的方式判断究竟多少部分被划分为了指定的颜色</span></span><br><span class="line">    <span class="comment"># H、S、V范围一：</span></span><br><span class="line">    lower1 = np.array([<span class="number">0</span>, <span class="number">43</span>, <span class="number">46</span>])</span><br><span class="line">    upper1 = np.array([<span class="number">10</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    mask1 = cv2.inRange(grid_HSV, lower1, upper1)       <span class="comment"># mask1 为二值图像</span></span><br><span class="line">    res1 = cv2.bitwise_and(grid_RGB, grid_RGB, mask=mask1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # H、S、V范围二：</span></span><br><span class="line">    lower2 = np.array([<span class="number">156</span>, <span class="number">43</span>, <span class="number">46</span>])</span><br><span class="line">    upper2 = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    mask2 = cv2.inRange(grid_HSV, lower2, upper2)</span><br><span class="line">    res2 = cv2.bitwise_and(grid_RGB, grid_RGB, mask=mask2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 将两个二值图像结果 相加</span></span><br><span class="line">    mask3 = mask1 + mask2</span><br><span class="line">    <span class="comment"># cv2.imshow(&quot;mask3&quot;, mask3)</span></span><br><span class="line">    <span class="comment"># cv2.imshow(&quot;grid_RGB&quot;, grid_RGB[:, :, ::-1])</span></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line">    list_info = [i.<span class="built_in">max</span>() <span class="keyword">for</span> i <span class="keyword">in</span> mask3]</span><br><span class="line">    <span class="keyword">if</span> list_info.count(<span class="number">255</span>)/<span class="built_in">len</span>(list_info) &gt; <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 如果红色面积大于10%则判定为红色</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl安装教程</title>
    <url>/2023/10/31/%E5%B7%A5%E5%85%B7-openssl%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>下载网址<code>http://www.openssl.org/source/</code></p>
<p>下载openssl到/usr/local/src目录下然后开始安装，一次执行以下命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf openssl-0.9.8k.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-0.9.8k</span><br><span class="line">./config shared zlib</span><br><span class="line">make</span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line">make install</span><br><span class="line"><span class="built_in">mv</span> /usr/bin/openssl /usr/bin/openssl.save</span><br><span class="line"><span class="built_in">mv</span> /usr/include/openssl /usr/include/openssl.save</span><br><span class="line"><span class="built_in">mv</span> /usr/lib/libssl.so /usr/lib/libssl.so.save</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/ssl/bin/openssl /usr/bin/openssl</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/ssl/include/openssl /usr/include/openssl</span><br><span class="line"><span class="built_in">ln</span> -sv /usr/local/ssl/lib/libssl.so.0.9.8 /usr/lib/libssl.so</span><br></pre></td></tr></table></figure>

<p>到此安装完毕，然后配置库文件搜索路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/ssl/lib&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig -v</span><br></pre></td></tr></table></figure>


<p>最后检测一下安装结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>pipreqs的使用</title>
    <url>/2024/12/01/%E5%B7%A5%E5%85%B7-pipreqs%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="pipreqs：自动化Python项目依赖管理的利器"><a href="#pipreqs：自动化Python项目依赖管理的利器" class="headerlink" title="pipreqs：自动化Python项目依赖管理的利器"></a>pipreqs：自动化Python项目依赖管理的利器</h1><p>在Python项目的开发过程中，依赖管理是一个不可或缺的步骤。一个清晰、准确的<code>requirements.txt</code>文件对于项目的共享、部署和维护至关重要。今天，我们要介绍的是一个名为<code>pipreqs</code>的神奇工具，它能够自动化地生成这个文件，从而简化你的项目依赖管理流程。</p>
<h2 id="pipreqs是什么？"><a href="#pipreqs是什么？" class="headerlink" title="pipreqs是什么？"></a>pipreqs是什么？</h2><p><code>pipreqs</code>是一个Python工具，它通过分析你的项目源代码，自动检测项目中使用的第三方库，并生成一个包含这些库及其版本信息的<code>requirements.txt</code>文件。这个工具的出现，极大地方便了开发者在不同环境间迁移和部署项目，确保了依赖库的一致性。</p>
<h2 id="pipreqs的主要功能"><a href="#pipreqs的主要功能" class="headerlink" title="pipreqs的主要功能"></a>pipreqs的主要功能</h2><p><code>pipreqs</code>具有以下几个显著的功能和特点：</p>
<ul>
<li><strong>自动分析</strong>：它能够扫描项目的源代码，自动识别<code>import</code>语句中引用的第三方库。</li>
<li><strong>版本控制</strong>：<code>pipreqs</code>能够识别并记录这些库的版本信息，确保生成的依赖文件既全面又精确。</li>
<li><strong>忽略机制</strong>：你可以通过配置文件或命令行参数指定需要忽略的文件或目录，以避免不必要的库被包含进来。</li>
<li><strong>更新现有文件</strong>：如果你的项目已经有了一个<code>requirements.txt</code>文件，<code>pipreqs</code>可以帮助你更新这个文件，确保它反映了项目当前的依赖状态。</li>
</ul>
<h2 id="如何使用pipreqs"><a href="#如何使用pipreqs" class="headerlink" title="如何使用pipreqs"></a>如何使用pipreqs</h2><p>使用<code>pipreqs</code>非常简单。首先，你需要安装它，这可以通过pip命令轻松完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pipreqs</span><br></pre></td></tr></table></figure>

<p>然后，在你的项目根目录下运行以下命令来生成<code>requirements.txt</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipreqs ./</span><br></pre></td></tr></table></figure>

<p>然而，由于<code>pipreqs</code>默认没有考虑路径编码和外网连接速度问题，我们通常推荐使用以下命令来避免潜在的问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipreqs ./ --encoding=utf8 --force --use-local</span><br></pre></td></tr></table></figure>

<p>这里的参数解释如下：</p>
<ul>
<li><code>./</code> 表示在当前目录下寻找Python项目的依赖。</li>
<li><code>--encoding=utf8</code> 用于防止编码错误。</li>
<li><code>--force</code> 用于强制覆盖现有的<code>requirements.txt</code>文件（如果目录中还没有该文件，则可以省略此参数）。</li>
<li><code>--use-local</code> 指定使用本地库，避免因外网连接问题导致的速度慢或卡死现象。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>pipreqs</code>是一个简单而实用的工具，它可以帮助Python开发者自动化地生成和管理<code>requirements.txt</code>文件，从而解决项目依赖问题。使用时，注意一些技巧和参数，可以避免因网络问题导致的卡死现象。通过<code>pipreqs</code>，你可以更专注于代码开发，而不必过分担心依赖管理的繁琐事务。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的定时任务</title>
    <url>/2022/08/10/%E5%B7%A5%E5%85%B7-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>在编写某些脚本的时候往往需要使用到定时执行任务，定时执行任务可以通过下发多进程或者使用某些调度算法实现，在python中为开发者提供了一个库可以快速实现定时任务并且不让主进程受到干扰。这个库就叫做：<code>APScheduler</code>。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>dvanced Python Scheduler (APScheduler) 是一个Python库，可实现延迟调度要执行Python代码的功能，可以只执行一次，也可以定期执行。可以随时添加新任务或删除旧任务。如果将job任务存储在数据库中，这些任务还将在重新启动调度程序后保持它们的状态并继续运行。当重新启动调度程序时，它将运行离线时应该运行的所有job任务，这个功能可以让程序弥补由于外部情况损失的任务。这个库有四个组件：</p>
<ul>
<li><strong><code>triggers</code>触发器</strong> : 包含调度逻辑，每一个job有它自己的触发器，用于决定job下一次运行时间。除了初始配置外，触发器完全是无状态的。</li>
<li><strong><code>job stores</code>作业存储</strong> : 存储被调度的job，默认的job存储是简单地把job存储在内存中，其他的job存储是保存在数据库中。Job的数据在保存到持久化存储时被序列化，并在加载时进行反序列化。job存储(默认存储除外)不将job数据保存在内存中，而是充当后台保存、加载、更新和搜索job的中间人。job存储永远不能在调度程序之间共享。</li>
<li><strong><code>executors</code>执行器</strong> : 负责处理job的运行，通过将job中指定的可调用对象 提交给一个线程或进程池来运行。当job完成时，执行器将会通知调度器，然后调度程序发出相应event。</li>
<li><strong><code>schedulers</code>调度器</strong> : 一个应用程序中通常只有一个调度器在运行，应用程序开发人员通常不会直接处理job存储、执行器和触发器，相反，调度器程序提供了处理这些事件的接口。<br>配置job存储和执行器都是在调度器中完成，例如添加、修改和移除job。</li>
</ul>
<h3 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h3><p>APScheduler能够很轻易的实现定时任务的三个步骤：</p>
<ul>
<li>新建scheduler调度器  </li>
<li>向调度器添加一个job调度任务  </li>
<li>运行job调度任务  </li>
</ul>
<p>即创建任务，添加任务，启动任务</p>
<p>案例一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用blocking阻塞调度程序来调度每隔3秒执行一次的作业</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tick</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Tick! The time is: %s&#x27;</span> % datetime.now())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    scheduler = BlockingScheduler()</span><br><span class="line">    scheduler.add_job(tick, <span class="string">&#x27;interval&#x27;</span>, seconds=<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Press Ctrl+&#123;0&#125; to exit&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Break&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        scheduler.start()</span><br><span class="line">    <span class="keyword">except</span> (KeyboardInterrupt, SystemExit):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>但是这个案例是会阻塞程序运行的，本质上与for循环实现的功能差不多一般情况下大多数人不会在有这样需求的情况下考虑它，多数时候我们希望我们是任务在后台被调度，不会阻塞程序的正常执行,如下</p>
<p>案例二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tick</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Tick! The time is: %s&#x27;</span> % datetime.now())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    scheduler = BackgroundScheduler()</span><br><span class="line">    scheduler.add_job(tick, <span class="string">&#x27;interval&#x27;</span>, seconds=<span class="number">3</span>)</span><br><span class="line">    scheduler.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Press Ctrl+&#123;0&#125; to exit&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Break&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># This is here to simulate application activity (which keeps the main thread alive).</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">except</span> (KeyboardInterrupt, SystemExit):</span><br><span class="line">        <span class="comment"># Not strictly necessary if daemonic mode is enabled but should be done if possible</span></span><br><span class="line">        scheduler.shutdown()</span><br></pre></td></tr></table></figure>

<p>这个调度器实现了同样的功能，也是每三秒执行一次，但是调度程序不会阻塞主进程的正常进行，更多调度方法如下：</p>
<ul>
<li><strong>BlockingScheduler</strong> : 调度器在当前进程的主线程中运行，也就是会阻塞当前线程。</li>
<li><strong>BackgroundScheduler</strong> : 调度器在后台线程中运行，不会阻塞当前线程。（在没有使用下面5个框架时使用）</li>
<li><strong>AsyncIOScheduler</strong> : 结合 asyncio 模块（一个异步框架）一起使用。</li>
<li><strong>GeventScheduler</strong> : 程序中使用 gevent（高性能的Python并发框架）作为IO模型，和 GeventExecutor 配合使用。</li>
<li><strong>TornadoScheduler</strong> : 程序中使用 Tornado（一个web框架）的IO模型。</li>
<li><strong>TwistedScheduler</strong> : 配合 TwistedExecutor使用。</li>
<li><strong>QtScheduler</strong> : 配合 Qt 应用使用。</li>
</ul>
<p>除了定时任务，当我们程序只需要在某一个特定时间执行一件事情，不需要重复执行的时候，调度器很明显就不够使用了，这时候就需要定时器也叫触发器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 2019-03-29 14:00:00 时刻运行一次 job_func 方法</span></span><br><span class="line">scheduler.add_job(job_func, <span class="string">&#x27;date&#x27;</span>, run_date=datetime(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>), args=[<span class="string">&#x27;text&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>触发器同时也支持其他的时间格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sched.add_job(my_job, <span class="string">&#x27;date&#x27;</span>, run_date=date(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">29</span>), args=[<span class="string">&#x27;text&#x27;</span>])</span><br><span class="line">sched.add_job(my_job, <span class="string">&#x27;date&#x27;</span>, run_date=<span class="string">&#x27;2019-03-29 14:30:05&#x27;</span>, args=[<span class="string">&#x27;text&#x27;</span>])</span><br><span class="line">sched.add_job(my_job, args=[<span class="string">&#x27;text&#x27;</span>]) <span class="comment">#立即运行</span></span><br></pre></td></tr></table></figure>

<p>触发器除了能够定时触发还能够在某一个固定的时间段内执行指定数量的任务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 2019-03-29 14:00:01 ~ 2019-03-29 14:00:10 之间, 每隔两分钟执行一次job_func方法。</span></span><br><span class="line">scheduler.add_job(job_func, <span class="string">&#x27;interval&#x27;</span>, minutes=<span class="number">2</span>, start_date=<span class="string">&#x27;2019-03-29 14:00:01&#x27;</span> , end_date=<span class="string">&#x27;2019-03-29 14:00:10&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以及周期性触发：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在2019-03-30 00:00:00之前，每周一到周五的5:30(am)触发</span></span><br><span class="line">sched.add_job(job_function, <span class="string">&#x27;cron&#x27;</span>, day_of_week=<span class="string">&#x27;mon-fri&#x27;</span>, hour=<span class="number">5</span>, minute=<span class="number">30</span>, end_date=<span class="string">&#x27;2019-03-30&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>supervisor</title>
    <url>/2022/07/17/%E5%B7%A5%E5%85%B7-supervisor/</url>
    <content><![CDATA[<h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p>supervisor是一个Python开发的通用的进程管理程序，可以管理和监控Linux上面的进程，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启，但它不能管理原本就是daemon的进程。并且supervisor本身自己也是一个python库，因此可以使用pip进行直接安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>supervisor管理进程依赖的相应的配置文件，配置文件可以通过命令生成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /app/install_files/supervisor.conf</span><br></pre></td></tr></table></figure>

<p>配置文件当中有许多可以配置的选项，这里不一一列举，只给出部分配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:project_name]</span><br><span class="line">directory = 工作目录</span><br><span class="line"><span class="built_in">command</span> = 脚本的启动命令</span><br><span class="line">autostart = <span class="literal">true</span></span><br><span class="line">autorestart = <span class="literal">true</span></span><br><span class="line">user = loanward</span><br><span class="line">stdout_logfile = /data/log/pro_stdout.log</span><br></pre></td></tr></table></figure>

<ul>
<li><code>project_name</code>: 必须是唯一的，否则将会出现错乱  </li>
<li><code>directory</code>: 填写你启动脚本时的工作目录，如果你使用脚本的绝对目录，那么directory可以不设置  </li>
<li><code>command</code>:是执行脚本的命令，不需要使用nohup让其变为后代进程，supervisor会自动将其变为后台进程  </li>
<li><code>autostart</code>: 配置为True， supervisor 启动时，任务跟随启动  </li>
<li><code>autorestart</code>: 配置为True， 进程不存在时会自动重启， 默认重启3次，想修改重启次数，可以配置startretries， 设置最多重启的次数  </li>
<li><code>user</code>: 设置启动任务时所用的用户，supervisor 有必要使用root账号启动，这样才有权限配置其他启动账号  </li>
<li><code>stdout_logfile</code>: 配置输出日志  </li>
</ul>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure>
<p>这里路径为你当前文件所处的路径</p>
<p>其他命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisorctl status                         <span class="comment"># 查看进程状态</span></span><br><span class="line">supervisorctl stop project_name              <span class="comment"># 终止某个进程</span></span><br><span class="line">supervisorctl start project_name             <span class="comment"># 启动某个进程</span></span><br><span class="line">supervisorctl restart project_name           <span class="comment"># 重启某个进程</span></span><br><span class="line">supervisorctl reread                         <span class="comment"># 更新配置，根据最新的配置启动程序，会启动已经运行的程序</span></span><br><span class="line">supervisorctl update                         <span class="comment"># 更新配置，重启配置有变化的进程，不会重启那些配置没有变化</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你的程序需要对程序的进程进行管理的时候，尤其是部署服务的时候，这个工具非常适合python。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>中文ocr</title>
    <url>/2022/07/17/%E5%B7%A5%E5%85%B7-%E4%B8%AD%E6%96%87ocr/</url>
    <content><![CDATA[<h2 id="cnocr"><a href="#cnocr" class="headerlink" title="cnocr"></a>cnocr</h2><p>cnocr是用来做中文OCR的Python 3包。cnocr自带了训练好的识别模型，所以安装后即可直接使用。目前使用的识别模型是crnn，识别准确度约为 98.7%。</p>
<p><strong>安装：</strong><code>pip install cnocr</code></p>
<p>代码引用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cnocr <span class="keyword">import</span> CnOcr </span><br><span class="line">ocr = CnOcr() </span><br><span class="line">res = ocr.ocr_for_single_line(<span class="string">&#x27;test.png&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Predicted Chars:&quot;</span>, res)</span><br></pre></td></tr></table></figure>

<p>首次使用cnocr时，系统会自动从Dropbox下载zip格式的模型压缩文件，并存于 <del>/.cnocr目录。 下载后的zip文件代码会自动对其解压，然后把解压后的模型相关文件放于</del>/.cnocr/models目录。 如果系统不能自动从Dropbox成功下载zip文件，则需要手动下载此zip文件并把它放于 ~/.cnocr目录。 另一个下载地址是百度云盘(提取码为pg26)。 放置好zip文件后，后面的事代码就会自动执行了。</p>
<p>但是这样的识别并不准确，当图片中的文字太复杂的时候就需要另一个库的支持用于识别文字。</p>
<h2 id="cnstd"><a href="#cnstd" class="headerlink" title="cnstd"></a>cnstd</h2><p><strong>安装：</strong><code>pip install cnstd</code>  </p>
<p>该库可以与cnocr无缝衔接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cnstd <span class="keyword">import</span> CnStd</span><br><span class="line"><span class="keyword">from</span> cnocr <span class="keyword">import</span> CnOcr</span><br><span class="line"></span><br><span class="line">std = CnStd()</span><br><span class="line">cn_ocr = CnOcr()</span><br><span class="line"></span><br><span class="line">box_infos = std.detect(<span class="string">&#x27;examples/taobao.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> box_info <span class="keyword">in</span> box_infos[<span class="string">&#x27;detected_texts&#x27;</span>]:</span><br><span class="line">    cropped_img = box_info[<span class="string">&#x27;cropped_img&#x27;</span>]</span><br><span class="line">    ocr_res = cn_ocr.ocr_for_single_line(cropped_img)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ocr result: %s&#x27;</span> % <span class="built_in">str</span>(ocr_res))</span><br></pre></td></tr></table></figure>

<p>官方链接： <img src="https://github.com/breezedeus/cnstd" alt="cnstd"> <img src="https://github.com/breezedeus/cnocr" alt="cnocr"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>代码混淆</title>
    <url>/2022/11/16/%E5%B7%A5%E5%85%B7-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<p>很多时候开发者在给出自己的源代码的时候会考虑自己的代码太过容易被抄袭或者被阅读从而导致漏洞，对于前端来说，简单的代码与逻辑会给爬虫工程师逆向js加盐逻辑提供太简单的门槛，所以代码混淆操作逐渐变多，但是我个人作为一个普通开发，几乎用不到这样的技术。但是我觉得很有意思，因此记录了一些代码混淆的网站：</p>
<p>JavaScript 混淆 ：</p>
<ul>
<li><a href="http://jshaman.com/#free">http://jshaman.com/#free</a></li>
<li><a href="https://www.bugku.com/tools/jsfuck/">https://www.bugku.com/tools/jsfuck/</a></li>
</ul>
<p>PHP 混淆：</p>
<ul>
<li><a href="https://www.phpjiami.com/phpjiami.html">https://www.phpjiami.com/phpjiami.html</a></li>
</ul>
<p>Java 混淆：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/272646403">https://zhuanlan.zhihu.com/p/272646403</a></li>
</ul>
<p>python 混淆：</p>
<ul>
<li><a href="https://pyob.oxyry.com/">https://pyob.oxyry.com/</a></li>
</ul>
<blockquote>
<p>另附上一个加密网站，有很多好玩的加密： <a href="http://hi.pcmoe.net/">http://hi.pcmoe.net/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>关于office解密的一个库</title>
    <url>/2022/07/17/%E5%B7%A5%E5%85%B7-%E5%85%B3%E4%BA%8Eoffice%E8%A7%A3%E5%AF%86%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%93/</url>
    <content><![CDATA[<p>在工作中偶然的机会需要我使用python实现word的解密，已知密码需要解密或者进行爆破行为，但是苦苦没有找到合适的方法，但是偶然间fa</p>
<h2 id="msoffcrypto-tool"><a href="#msoffcrypto-tool" class="headerlink" title="msoffcrypto-tool"></a><code>msoffcrypto-tool</code></h2><p>msoffcrypto-tool（以前称为ms-offcrypto-tool）是Python工具和库，用于使用密码，中间密钥或生成其托管密钥的私钥解密加密的MS Office文件。</p>
<p><strong>安装：</strong> <code>pip install msoffcrypto-tool</code></p>
<p><strong>使用方式：</strong> <code>msoffcrypto-tool encrypted.docx decrypted.docx -p 你的密码</code></p>
<p><strong>测试是否有加密：</strong> <code>msoffcrypto-tool document.doc --test -v</code></p>
<h3 id="代码用法"><a href="#代码用法" class="headerlink" title="代码用法"></a>代码用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> msoffcrypto</span><br><span class="line"></span><br><span class="line">encrypted = <span class="built_in">open</span>(<span class="string">&quot;encrypted.docx&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">file = msoffcrypto.OfficeFile(encrypted)</span><br><span class="line"></span><br><span class="line">file.load_key(password=<span class="string">&quot;Passw0rd&quot;</span>)  <span class="comment"># Use password</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;decrypted.docx&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    file.decrypt(f)</span><br><span class="line"></span><br><span class="line">encrypted.close()</span><br></pre></td></tr></table></figure>

<p>结合pandas</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> msoffcrypto</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">decrypted = io.BytesIO()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;encrypted.xlsx&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    file = msoffcrypto.OfficeFile(f)</span><br><span class="line">    file.load_key(password=<span class="string">&quot;Passw0rd&quot;</span>)  <span class="comment"># Use password</span></span><br><span class="line">    file.decrypt(decrypted)</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(decrypted)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Verify password before decryption (default: False)</span></span><br><span class="line"><span class="comment"># The ECMA-376 Agile/Standard crypto system allows one to know whether the supplied password is correct before actually decrypting the file</span></span><br><span class="line"><span class="comment"># Currently, the verify_password option is only meaningful for ECMA-376 Agile/Standard Encryption</span></span><br><span class="line">file.load_key(password=<span class="string">&quot;Passw0rd&quot;</span>, verify_password=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use private key</span></span><br><span class="line">file.load_key(private_key=<span class="built_in">open</span>(<span class="string">&quot;priv.pem&quot;</span>, <span class="string">&quot;rb&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use intermediate key (secretKey)</span></span><br><span class="line">file.load_key(secret_key=binascii.unhexlify(<span class="string">&quot;AE8C36E68B4BB9EA46E5544A5FDB6693875B2FDE1507CBC65C8BCF99E25C2562&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check the HMAC of the data payload before decryption (default: False)</span></span><br><span class="line"><span class="comment"># Currently, the verify_integrity option is only meaningful for ECMA-376 Agile Encryption</span></span><br><span class="line">file.decrypt(<span class="built_in">open</span>(<span class="string">&quot;decrypted.docx&quot;</span>, <span class="string">&quot;wb&quot;</span>), verify_integrity=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>后台终端的使用</title>
    <url>/2024/12/01/%E5%B7%A5%E5%85%B7-%E5%90%8E%E5%8F%B0%E7%BB%88%E7%AB%AFscreen/</url>
    <content><![CDATA[<h2 id="Screen命令使用指南"><a href="#Screen命令使用指南" class="headerlink" title="Screen命令使用指南"></a>Screen命令使用指南</h2><p><code>screen</code> 是一个非常强大的命令行工具，它允许用户在远程服务器上开启多个终端会话，并在它们之间自由切换。它特别适合于需要长时间运行的命令和断线后恢复的场景。</p>
<h2 id="安装-Screen"><a href="#安装-Screen" class="headerlink" title="安装 Screen"></a>安装 Screen</h2><p>在大多数 Linux 发行版中，<code>screen</code> 可以通过包管理器安装。以下是在不同系统中安装 <code>screen</code> 的命令：</p>
<ul>
<li><strong>Ubuntu/Debian</strong>:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install screen</span><br></pre></td></tr></table></figure></li>
<li><strong>CentOS/RHEL</strong>:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install screen</span><br></pre></td></tr></table></figure></li>
<li><strong>Fedora</strong>:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install screen</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建新的-Screen-会话"><a href="#创建新的-Screen-会话" class="headerlink" title="创建新的 Screen 会话"></a>创建新的 Screen 会话</h3><p>要创建一个新的 <code>screen</code> 会话，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S session_name</span><br></pre></td></tr></table></figure>

<p>这里 <code>session_name</code> 是你为会话指定的名称，你可以用它来标识和管理不同的会话。</p>
<h3 id="列出当前的-Screen-会话"><a href="#列出当前的-Screen-会话" class="headerlink" title="列出当前的 Screen 会话"></a>列出当前的 Screen 会话</h3><p>要查看当前所有的 <code>screen</code> 会话，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>这将列出所有活动的会话以及它们的状态。</p>
<h3 id="重新连接到-Screen-会话"><a href="#重新连接到-Screen-会话" class="headerlink" title="重新连接到 Screen 会话"></a>重新连接到 Screen 会话</h3><p>如果你之前创建了一个 <code>screen</code> 会话并且断开了连接，可以使用以下命令重新连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure>

<p>如果会话是活动的，<code>-r</code> 选项将你附加到会话上。</p>
<h3 id="退出-Screen-会话"><a href="#退出-Screen-会话" class="headerlink" title="退出 Screen 会话"></a>退出 Screen 会话</h3><p>要退出当前的 <code>screen</code> 会话，可以按 <code>Ctrl-A</code> 然后按 <code>D</code>。这将使你从会话中分离，但会话仍然在后台运行。</p>
<p>如果你想要完全结束一个会话，可以在会话内部运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>或者使用 <code>screen -X -S session_name quit</code> 从外部结束会话。</p>
<h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h3><p><code>screen</code> 支持在同一会话中垂直或水平分割窗口。按 <code>Ctrl-A</code> 然后按 <code>|</code> 可以垂直分割窗口，按 <code>Ctrl-A</code> 然后按 <code>S</code> 可以水平分割窗口。使用 <code>Ctrl-A</code> 然后按方向键可以在不同的窗口之间切换。</p>
<h3 id="会话共享"><a href="#会话共享" class="headerlink" title="会话共享"></a>会话共享</h3><p><code>screen</code> 允许多个用户共享同一个会话。要共享一个会话，可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -x session_name</span><br></pre></td></tr></table></figure>

<p>这将允许你和会话的所有者一起工作。</p>
<h2 id="实用案例"><a href="#实用案例" class="headerlink" title="实用案例"></a>实用案例</h2><h3 id="1-远程工作"><a href="#1-远程工作" class="headerlink" title="1. 远程工作"></a>1. 远程工作</h3><p>当你需要在远程服务器上运行一个长时间任务时，可以使用 <code>screen</code> 启动任务，然后安全地断开连接。任务将在服务器上继续运行，你可以随时重新连接回去检查进度。</p>
<h3 id="2-多任务处理"><a href="#2-多任务处理" class="headerlink" title="2. 多任务处理"></a>2. 多任务处理</h3><p>如果你需要同时在多个终端窗口工作，<code>screen</code> 的分屏功能可以让你在一个终端窗口中管理多个任务。</p>
<h3 id="3-协作编程"><a href="#3-协作编程" class="headerlink" title="3. 协作编程"></a>3. 协作编程</h3><p><code>screen</code> 的会话共享功能允许多个开发者同时查看和编辑同一个项目，非常适合协作编程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>screen</code> 是一个功能强大的工具，它提供了一种灵活的方式来管理和恢复远程会话。无论你是系统管理员、开发者还是普通用户，掌握 <code>screen</code> 的使用都能提高你的工作效率。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>文件md5校验</title>
    <url>/2023/03/21/%E5%B7%A5%E5%85%B7-%E6%96%87%E4%BB%B6md5%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>从网络上下载大文件时，官网一般都会提供一个MD5、SHA1或SHA256值,这是用来校验文件完整性的。因为从网络上下载大文件具有不确定性，可能会受很多因素影响，比如网络抖动导致文件下载不完成，文件被恶意篡改等，这些问题都会导致最终下载的文件无法正常使用。</p>
<h2 id="针对小文件（＜500MB）"><a href="#针对小文件（＜500MB）" class="headerlink" title="针对小文件（＜500MB）"></a>针对小文件（＜500MB）</h2><p>直接以二进读模式（rb）加载进来，然后计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">fpath: <span class="built_in">str</span>, algorithm: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fpath, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> hashlib.new(algorithm, f.read()).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> algorithm <span class="keyword">in</span> (<span class="string">&#x27;md5&#x27;</span>, <span class="string">&#x27;sha1&#x27;</span>, <span class="string">&#x27;sha256&#x27;</span>):</span><br><span class="line">        hexdigest = encrypt(<span class="string">&#x27;test.file&#x27;</span>, algorithm)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;algorithm&#125;</span>: <span class="subst">&#123;hexdigest&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="针对大文件（500MB-1GB）"><a href="#针对大文件（500MB-1GB）" class="headerlink" title="针对大文件（500MB~1GB）"></a>针对大文件（500MB~1GB）</h2><p>为了更友好地视觉体验，可以增加一个进度条。（进度条用 rich 实现，安装：pip install rich）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rich.progress</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">fpath: <span class="built_in">str</span>, algorithm: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">with</span> rich.progress.<span class="built_in">open</span>(fpath, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> hashlib.new(algorithm, f.read()).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> algorithm <span class="keyword">in</span> (<span class="string">&#x27;md5&#x27;</span>, <span class="string">&#x27;sha1&#x27;</span>, <span class="string">&#x27;sha256&#x27;</span>):</span><br><span class="line">        hexdigest = encrypt(<span class="string">&#x27;test.file&#x27;</span>, algorithm)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;algorithm&#125;</span>: <span class="subst">&#123;hexdigest&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="针对超大文件（＞1GB）"><a href="#针对超大文件（＞1GB）" class="headerlink" title="针对超大文件（＞1GB）"></a>针对超大文件（＞1GB）</h2><p>为了避免内存溢出，按块读取并迭代计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rich.progress</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">fpath: <span class="built_in">str</span>, algorithm: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">with</span> rich.progress.<span class="built_in">open</span>(fpath, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">hash</span> = hashlib.new(algorithm)</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: f.read(<span class="number">2</span>**<span class="number">20</span>), <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">            <span class="built_in">hash</span>.update(chunk)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> algorithm <span class="keyword">in</span> (<span class="string">&#x27;md5&#x27;</span>, <span class="string">&#x27;sha1&#x27;</span>, <span class="string">&#x27;sha256&#x27;</span>):</span><br><span class="line">        hexdigest = encrypt(<span class="string">&#x27;ubuntu-22.04-desktop-amd64.iso&#x27;</span>, algorithm)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;algorithm&#125;</span>: <span class="subst">&#123;hexdigest&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Reading... ---------------------------------------- 3.7/3.7 GB 0:00:00</span><br><span class="line">md5: 7621da10af45a031ea9a0d1d7fea9643</span><br><span class="line">Reading... ---------------------------------------- 3.7/3.7 GB 0:00:00</span><br><span class="line">sha1: 8a73a36f38397974d5517b861a68577514ef694e</span><br><span class="line">Reading... ---------------------------------------- 3.7/3.7 GB 0:00:00</span><br><span class="line">sha256: b85286d9855f549ed9895763519f6a295a7698fb9c5c5345811b3eefadfb6f07</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>取证</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>文章关键字提取</title>
    <url>/2022/06/27/%E5%B7%A5%E5%85%B7-%E6%96%87%E7%AB%A0%E5%85%B3%E9%94%AE%E5%AD%97%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h2 id="关键字提取"><a href="#关键字提取" class="headerlink" title="关键字提取"></a>关键字提取</h2><p>关键字提取作为文本分析的重要一环，现在已经拥有很多工具可以使用，一般工具被分为两类，第一类是基于算法的关键字提取，也就是将文本进行分词操作后对文本当中词语出现的频率做出统计，同时对一些助词或者语气词进行过滤操作得到较为准确的关键词。第二类就是基于机器学习的关键词提取，需要对文章进行相应的向量计算，具体的算法需要依据实际情况考量。本文只展示第一种：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载模块</span></span><br><span class="line"><span class="keyword">from</span> textrank4ch.TextRank4Keyword <span class="keyword">import</span> TextRank4Keywords</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 准备预料, 输入时一个字符长串, 可含特殊字符</span></span><br><span class="line">corpus =  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">据了解，为全面强化边境禁毒“清源断流”，严查严打跨境涉毒违法犯罪，国家移民管理机构广大移民管理警察在血与火、生与死的考验中，不惧牺牲，勇于担当，以“边境多查毒、内地少受害”为使命，昼夜坚守边境缉毒一线，充分发挥党政军警民合力强边固防机制作用，综合采取人防、物防、技防措施，严密边境前沿查堵、强化专案攻坚、紧抓边境辖区社会面管控、深化口岸边境执法协作，全力遏制境外毒品渗透内流和制毒物品走私出境，坚决筑起口岸边境禁毒的坚固防线。其间，广大移民管理警察还深入边境辖区村寨、学校，大力宣传法律法规及毒品危害，广泛发动群众参与到禁毒人民战争中来，有力构建群防群治的禁毒网络，营造了边境辖区对涉毒违法犯罪“人人喊打”的良好局面。</span></span><br><span class="line"><span class="string">国家移民管理局有关负责人表示，下一步，移民管理机构将继续深入研判毒品犯罪藏毒方式、涉毒群体、贩运方式、绕关避卡等规律特点，动态调整布设执勤点位织密边境查缉堵截网络；以大案复盘扩线为突破口，摸排盘踞本地、辐射周边的涉毒群体，深挖贩毒团伙网络，采取专班运作、专案经营、挂牌督办、多警种协同作战、口岸边境执法协作等方式推进大案专案侦办；结合“法治宣传固边防”活动，加大边境辖区禁毒宣传力度，持续开展“禁毒流动课堂”“禁毒宣传下基层”“全民禁毒宣传月”等集中宣传活动，努力提高群众自觉参与禁毒斗争的意识，进一步阻断境外毒品渗透内流通道，最大限度减少毒品渗透危害。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对输入进行分析、得到全量的关键词相关信息, 如权重(PR)、词性</span></span><br><span class="line">t4kw = TextRank4Keywords()</span><br><span class="line">t4kw.analyze(text=corpus)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 再基于上述analyze的结果进行按需提取需要的关键字</span></span><br><span class="line"><span class="built_in">print</span>(t4kw.get_key_words(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>离线安装MongoDB教程</title>
    <url>/2025/02/15/%E5%B7%A5%E5%85%B7-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85MongoDB%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="离线安装MongoDB教程"><a href="#离线安装MongoDB教程" class="headerlink" title="离线安装MongoDB教程"></a>离线安装MongoDB教程</h2><p>在CentOS 7环境下离线安装MongoDB，您可以按照以下步骤进行操作。本教程涵盖了从安装包下载到服务启动的全过程。</p>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><ul>
<li><strong>操作系统</strong>：Linux CentOS 7</li>
<li><strong>安装包</strong>：<code>mongodb-linux-x86_64-rhel70-4.0.27.tgz</code></li>
</ul>
<h2 id="2-安装包下载"><a href="#2-安装包下载" class="headerlink" title="2. 安装包下载"></a>2. 安装包下载</h2><p>从MongoDB官网下载安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.0.27.tgz</span><br></pre></td></tr></table></figure>

<h2 id="3-软件安装和启动"><a href="#3-软件安装和启动" class="headerlink" title="3. 软件安装和启动"></a>3. 软件安装和启动</h2><h3 id="3-1-解压安装包"><a href="#3-1-解压安装包" class="headerlink" title="3.1 解压安装包"></a>3.1 解压安装包</h3><p>将下载好的安装包上传到Linux服务器某个目录下，并使用以下命令解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-rhel70-4.0.27.tgz</span><br></pre></td></tr></table></figure>

<h3 id="3-2-移动目录"><a href="#3-2-移动目录" class="headerlink" title="3.2 移动目录"></a>3.2 移动目录</h3><p>将解压后的目录移动到<code>/usr/local</code>目录下，并改名为<code>mongodb</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> mongodb-linux-x86_64-rhel70-4.0.27 /usr/local/mongodb</span><br></pre></td></tr></table></figure>

<h3 id="3-3-创建数据和日志目录"><a href="#3-3-创建数据和日志目录" class="headerlink" title="3.3 创建数据和日志目录"></a>3.3 创建数据和日志目录</h3><p>进入<code>mongodb</code>目录，创建<code>data</code>目录及其子目录<code>db</code>和<code>log</code>，并设置权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/mongodb/</span><br><span class="line"><span class="built_in">mkdir</span> -p data/db data/log</span><br><span class="line">sudo <span class="built_in">chmod</span> 666 data/db data/log/</span><br></pre></td></tr></table></figure>

<h3 id="3-4-创建配置文件"><a href="#3-4-创建配置文件" class="headerlink" title="3.4 创建配置文件"></a>3.4 创建配置文件</h3><p>在<code>mongodb</code>目录下新建配置文件<code>mongodb.conf</code>，并输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbpath=/usr/local/mongodb/data/db</span><br><span class="line">logpath=/usr/local/mongodb/data/log/mongodb.log</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=27017</span><br><span class="line">auth=<span class="literal">true</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">bind_ip=0.0.0.0</span><br></pre></td></tr></table></figure>

<h3 id="3-5-配置环境变量"><a href="#3-5-配置环境变量" class="headerlink" title="3.5 配置环境变量"></a>3.5 配置环境变量</h3><p>编辑<code>/etc/profile</code>文件，添加MongoDB到环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MONGODB_HOME=/usr/local/mongodb</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$MONGODB_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p>然后，执行<code>source /etc/profile</code>使配置生效。</p>
<h3 id="3-6-启动MongoDB服务"><a href="#3-6-启动MongoDB服务" class="headerlink" title="3.6 启动MongoDB服务"></a>3.6 启动MongoDB服务</h3><p>使用以下命令启动MongoDB服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/mongodb.conf</span><br></pre></td></tr></table></figure>

<h3 id="3-7-验证安装"><a href="#3-7-验证安装" class="headerlink" title="3.7 验证安装"></a>3.7 验证安装</h3><p>使用<code>mongo</code>命令连接MongoDB：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<h2 id="4-其他配置"><a href="#4-其他配置" class="headerlink" title="4. 其他配置"></a>4. 其他配置</h2><h3 id="4-1-开放端口"><a href="#4-1-开放端口" class="headerlink" title="4.1 开放端口"></a>4.1 开放端口</h3><p>开放MongoDB的27017端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=27017/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="4-2-检查服务状态"><a href="#4-2-检查服务状态" class="headerlink" title="4.2 检查服务状态"></a>4.2 检查服务状态</h3><p>检查MongoDB进程状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep mongo</span><br></pre></td></tr></table></figure>

<p>检查端口是否启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -lanp | grep 27017</span><br></pre></td></tr></table></figure>

<p>如果<code>netstat</code>命令未找到，先进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y net-tools</span><br></pre></td></tr></table></figure>

<h3 id="4-3-停止服务"><a href="#4-3-停止服务" class="headerlink" title="4.3 停止服务"></a>4.3 停止服务</h3><p>通过进程ID杀死MongoDB服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure>

<p>或者使用<code>mongod</code>命令关闭服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod -f /usr/local/mongodb/mongodb.conf --shutdown</span><br></pre></td></tr></table></figure>

<h3 id="4-4-开机自启动"><a href="#4-4-开机自启动" class="headerlink" title="4.4 开机自启动"></a>4.4 开机自启动</h3><p>创建开机启动配置文件<code>/lib/systemd/system/mongodb.service</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=mongodb</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/mongodb.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/mongodb.conf --shutdown</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mongodb.service</span><br><span class="line">systemctl <span class="built_in">enable</span> mongodb.service</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>按照以上步骤，您可以在CentOS 7环境下成功离线安装并启动MongoDB服务。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>连接池</title>
    <url>/2022/05/08/%E5%B7%A5%E5%85%B7-%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="什么是连接池？"><a href="#什么是连接池？" class="headerlink" title="什么是连接池？"></a>什么是连接池？</h2><p>在网上常常给出这样的解释：数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。</p>
<p>更通俗一点就是，连接池维护着项目于数据库之间的联系，保证项目不会过于频繁的去连接数据库导致数据库压力过大。</p>
<h2 id="为什么要使用连接池？"><a href="#为什么要使用连接池？" class="headerlink" title="为什么要使用连接池？"></a>为什么要使用连接池？</h2><p>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。如果连接池存在，操作只需要把任务丢给连接池，至于对数据库操作的进程等一系列问题，全权交给连接池来进行操作，由连接池自己控制与数据库的访问与操作。在没有连接池的情况下，连接数据库通常需要以下步骤：  </p>
<ul>
<li>TCP建立连接的三次握手  </li>
<li>MySQL认证的三次握手  </li>
<li>真正的SQL执行  </li>
<li>MySQL的关闭  </li>
<li>TCP的四次握手关闭  </li>
</ul>
<p>这样操作在代码上实现起来是很简单的，但是连接过程太耗时，连接过多容易出现内存泄漏，对于数据库访问大的项目来说这是十分致命的。</p>
<h2 id="连接池的实现"><a href="#连接池的实现" class="headerlink" title="连接池的实现"></a>连接池的实现</h2><h3 id="基于别人的工具"><a href="#基于别人的工具" class="headerlink" title="基于别人的工具"></a>基于别人的工具</h3><p>实际上连接池的问题由来已久，因此早有人考虑到连接池的问题并为此写好了工具，在python语言中，提供一个库：<code>sqlalchemy </code>,这个库可以维护一个连接，让操作者不必担心在项目执行过程中断掉与数据库的联系。</p>
<p>使用案例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">engine = create_engine(<span class="string">&quot;mysql://user:password@hostname/dbname?charset=utf8&quot;</span>,</span><br><span class="line">                       echo=<span class="literal">True</span>,</span><br><span class="line">                       pool_size=<span class="number">8</span>,</span><br><span class="line">                       pool_recycle=<span class="number">60</span>*<span class="number">30</span></span><br><span class="line">                       )</span><br></pre></td></tr></table></figure>

<h3 id="自己写一个"><a href="#自己写一个" class="headerlink" title="自己写一个"></a>自己写一个</h3><p>如果自己写一个也是可以的，自己写连接池需要注意以下几点：</p>
<ul>
<li>最小连接数：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.</li>
<li>最大连接数：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作</li>
<li>最大空闲时间</li>
<li>获取连接超时时间</li>
<li>超时重试连接次数</li>
</ul>
<p>在网上也有不少人写出来了一些自己的连接池</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> tools.setting <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">DB_CONFIG = config.mysql_info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLManager</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 初始化实例方法</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.conn = <span class="literal">None</span></span><br><span class="line">		self.cursor = <span class="literal">None</span></span><br><span class="line">		self.connect()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 连接数据库</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">try</span>: <span class="comment"># 防止长连接导致挂掉</span></span><br><span class="line">			self.conn.ping()</span><br><span class="line">		<span class="keyword">except</span>:</span><br><span class="line">			self.conn = pymysql.connect(</span><br><span class="line">				host=DB_CONFIG[<span class="string">&quot;HOST&quot;</span>],</span><br><span class="line">				port=<span class="built_in">int</span>(DB_CONFIG[<span class="string">&quot;PORT&quot;</span>]),</span><br><span class="line">				user=DB_CONFIG[<span class="string">&quot;USER&quot;</span>],</span><br><span class="line">				passwd=DB_CONFIG[<span class="string">&quot;PASSWORD&quot;</span>],</span><br><span class="line">				db=DB_CONFIG[<span class="string">&quot;DBNAME&quot;</span>],</span><br><span class="line">				charset=DB_CONFIG[<span class="string">&quot;CHARSET&quot;</span>]</span><br><span class="line">			)</span><br><span class="line">			self.cursor = self.conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 查询多条数据</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_list</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">		self.connect()</span><br><span class="line">		self.cursor.execute(sql.encode(<span class="string">&#x27;utf8&#x27;</span>), args)</span><br><span class="line">		result = self.cursor.fetchall()</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 查询单条数据</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_one</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">		self.connect()</span><br><span class="line">		self.cursor.execute(sql.encode(<span class="string">&#x27;utf8&#x27;</span>), args)</span><br><span class="line">		result = self.cursor.fetchone()</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 执行单条SQL语句</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">moddify</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">		self.connect()</span><br><span class="line">		self.cursor.execute(sql, args)</span><br><span class="line">		self.conn.commit()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 我如果要批量执行多个创建操作，虽然只建立了一次数据库连接但是还是会多次提交，可不可以改成一次连接，</span></span><br><span class="line">	<span class="comment"># 一次提交呢？</span></span><br><span class="line">	<span class="comment"># 可以，只需要用上pymysql的executemany()</span></span><br><span class="line">	<span class="comment"># 方法就可以了。</span></span><br><span class="line">	<span class="comment"># 执行多条SQL语句</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">multi_modify</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">		self.connect()</span><br><span class="line">		self.cursor.executemany(sql.encode(<span class="string">&#x27;utf8&#x27;</span>), args)</span><br><span class="line">		self.conn.commit()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 创建单条记录的语句</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">		self.connect()</span><br><span class="line">		self.cursor.execute(sql.encode(<span class="string">&#x27;utf8&#x27;</span>), args)</span><br><span class="line">		self.conn.commit()</span><br><span class="line">		last_id = self.cursor.lastrowid</span><br><span class="line">		<span class="keyword">return</span> last_id</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 关闭数据库cursor和连接</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">		self.connect()</span><br><span class="line">		self.cursor.close()</span><br><span class="line">		self.conn.close()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 最后，我们每次操作完数据库之后都要手动关闭，可不可以写成自动关闭的呢？</span></span><br><span class="line">	<span class="comment"># 联想到我们之前学过的文件操作，使用with语句可以实现缩进结束自动关闭文件句柄的例子。</span></span><br><span class="line">	<span class="comment"># 我们来把我们的数据库连接类SQLManager类再优化下，使其支持with语句操作。</span></span><br><span class="line">	<span class="comment"># 进入with语句自动执行</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 退出with语句块自动执行</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">		self.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db = SQLManager()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># info = db.get_list(&#x27;select user_name from user_table where user_name=&quot;张三&quot;&#x27;)</span></span><br><span class="line">	<span class="comment"># time_info=datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)</span></span><br><span class="line">	<span class="comment"># sql_str = &quot;INSERT INTO user_table (create_time,update_time,user_name,password) VALUES (now(),now(),&#x27;&#123;&#125;&#x27;,&#123;&#125;)&quot;</span></span><br><span class="line">	<span class="comment"># db.create(sql_str)</span></span><br><span class="line">    <span class="comment"># print(info)</span></span><br><span class="line">	<span class="comment"># db.close()</span></span><br><span class="line">	sql_str = <span class="string">&quot;SELECT * FROM articles ORDER BY create_time DESC LIMIT &#123;&#125;,2;&quot;</span>.<span class="built_in">format</span>(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line">	result = db.get_list(sql_str)</span><br><span class="line">	<span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title>自动生成SQL语句Vanna学习</title>
    <url>/2024/05/13/%E5%BC%80%E6%BA%90-Vanna/</url>
    <content><![CDATA[<h2 id="为何要生成SQL语句"><a href="#为何要生成SQL语句" class="headerlink" title="为何要生成SQL语句"></a>为何要生成SQL语句</h2><p>在实际业务开发过程中，面对越来越多的用户在使用一些工具的时候，他们认为界面上展示出来的数据太过于单一了，无论是数据维度还是数据过滤方式，都被限制在了几个功能按钮上。数据聚合跟嵌套查询的想法是大多数人都有的，但是奈何操作者可能并不是编程行业的人，并且就算是也根本不了解当前自己使用的产品有什么数据表可以提供怎样的查询方式，这就限制了一个产品在数据展示维度上的欠缺。因此需要一款程序用于优化这个痛点。根据自然语言文本生成SQL语句的想法应运而生。</p>
<h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><h3 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h3><p>生成SQL语句的时候需要大模型理解当前产品的各种特性与表设计，知识库无疑是最好的解决方案，将当前产品的文档灌入到知识库当中，根据用户的问题查询对应的知识库，再将知识库的结果作为参考，结合问题一起让大模型返回结果。但是这里有很多问题，知识库作为参考只能提高模型对当前产品的理解能力，虽然生成sql语句在产品的大致逻辑方向上是正确的，但是却不能够明显提升SQL语句的生成能力，这导致SQL语句出现了大量的隐藏错误，使用体验非常糟糕。</p>
<h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><p>提示词在<a href="https://open.bigmodel.cn/dev/howuse/prompt">GLM提示词</a>当中有做简单讲解，这里就不再赘述了，提示词可以引导大模型按照特定的身份，朝着特定的方向生成高质量的回答，但是提示词本身是有限的，只能够引导并不能够教会模型怎么做或者告诉模型自己正在基于怎样的产品在做什么，并且提示词复杂之后，提示词的逻辑会严重影响到生成的质量，所以提示词的提示能力是有限的。</p>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>模型训练可以对模型进行微调，基于我们自己的数据集进行模型训练，将模型在某一个方向上的回答能力进行显著的拉升。但是这里有更多的问题，没有足够的数据集模型对文本的理解能力就会不够，但是很少有人能够手持那么大量的优质数据集，如果只是微调，即使保证了模型微调数据集的质量，模型微调的结果也很难把控，模型可能会调得不错，也可能变成一个傻子，更有可能变成偏科生，某一方面理解能力强，其他方面就是纯纯智障，模型的训练结果在一般公司里太不可控了。</p>
<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>最后是混合方案，就是结合之前的所有方案，知识库+提示词+模型训练。从知识库当中查询相关知识，将相关知识结合提示词灌入简单训练过的模型当中，在共同作用下，经过实际测试，有非常好的使用体验。</p>
<h2 id="Vanna框架"><a href="#Vanna框架" class="headerlink" title="Vanna框架"></a>Vanna框架</h2><p>Vanna是一个基于知识库与大模型生成SQL语句的python库，也是采用混合方案，将文档、sql语句、dll表作为知识库，配合提示词模板构建历史对话，引导大模型生成SQL语句。由于SQL语句的生成有知识库、提示词、对话历史的引导，这能让大模型生成的SQL变得更准确，并且SQL的生成并不会对数据库有太多挑剔，无论是sqlite、ch数据库、mysql数据库还是mongodb数据库，生成的效果都非常好。框架本身支持对模型对话记录的收集，正确生成的结果将再次被加入到知识库当中，因此一旦启用，随着使用次数的增多，生成SQL会越来越准确。<br>演示代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> vanna.remote <span class="keyword">import</span> VannaDefault</span><br><span class="line"><span class="keyword">from</span> vanna.openai.openai_chat <span class="keyword">import</span> OpenAI_Chat</span><br><span class="line"><span class="keyword">from</span> vanna.chromadb.chromadb_vector <span class="keyword">import</span> ChromaDB_VectorStore</span><br><span class="line"><span class="keyword">from</span> vanna.flask <span class="keyword">import</span> VannaFlaskApp</span><br><span class="line"><span class="keyword">from</span> clickhouse_driver <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">client = OpenAI(</span><br><span class="line">    api_key=<span class="string">&quot;EMPTY&quot;</span>,</span><br><span class="line">    base_url=<span class="string">&quot;http://127.0.0.1:8000/v1/&quot;</span>,</span><br><span class="line">    default_headers = &#123;<span class="string">&quot;x-foo&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVanna</span>(ChromaDB_VectorStore,OpenAI_Chat):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,client=<span class="literal">None</span>,config=<span class="literal">None</span></span>):</span><br><span class="line">        ChromaDB_VectorStore.__init__(self,config=config)</span><br><span class="line">        OpenAI_Chat.__init__(self,client=client,config=config)</span><br><span class="line">vn = MyVanna(client=client,config=&#123;<span class="string">&quot;model&quot;</span>: <span class="string">&quot;chatglm3-6b&quot;</span>&#125;)   <span class="comment">#chatglm2-6b</span></span><br><span class="line">vn.max_tokens = <span class="number">800</span></span><br><span class="line">vn.temperature = <span class="number">0.5</span></span><br><span class="line"> </span><br><span class="line">client= Client(database=<span class="string">&#x27;default&#x27;</span>, <span class="comment"># 数据库的名称为 第一个参数</span></span><br><span class="line">                user=<span class="string">&#x27;default&#x27;</span>,   <span class="comment"># 数据库 用户名</span></span><br><span class="line">                   password=<span class="string">&#x27;admin&#x27;</span>,  <span class="comment"># 数据库 密码</span></span><br><span class="line">                   host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_sql</span>(<span class="params">sql: <span class="built_in">str</span></span>) -&gt; pd.DataFrame:</span><br><span class="line">    result  = client.execute(sql)</span><br><span class="line">    df = pd.DataFrame(result) <span class="comment"># type: ignore</span></span><br><span class="line">    df.to_csv(<span class="string">&#x27;temp.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;temp.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数设置到vn.run_sql中</span></span><br><span class="line">vn.run_sql = run_sql <span class="comment"># type: ignore</span></span><br><span class="line">vn.run_sql_is_set = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">vn.train(ddl=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE netlink_5.DnsLog</span></span><br><span class="line"><span class="string">(</span></span><br><span class="line"><span class="string">    `uniqueId` UInt64 COMMENT &#x27;&#x27;,</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">COMMENT &#x27;日志表&#x27;</span></span><br><span class="line"><span class="string">ENGINE = MergeTree</span></span><br><span class="line"><span class="string">PARTITION BY toStartOfDay(toDateTime(time))</span></span><br><span class="line"><span class="string">ORDER BY time</span></span><br><span class="line"><span class="string">SETTINGS index_granularity = 8192</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># res = vn.ask(&#x27;查找链路2.dns日志表,计算过去一个月内每个工作日每个服务端IP的请求次数标准差，找出标准差最大的服务端IP。&#x27;,print_results=False)</span></span><br><span class="line">VannaFlaskApp(vn,allow_llm_to_see_data=<span class="literal">True</span>).run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">9999</span>)</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Vanna的知识库是基于ChromaDB进行开发的，源码支持对dll、doc、sql的训练，将知识库源码进行剥离之后得到一个简单的知识库管理类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>,<span class="type">Union</span>,<span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chromadb</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> chromadb.config <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> chromadb.utils <span class="keyword">import</span> embedding_functions</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> chromadb.api.types <span class="keyword">import</span> IDs,OneOrMany,Document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">default_ef = embedding_functions.DefaultEmbeddingFunction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deterministic_uuid</span>(<span class="params">content: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">bytes</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据输入内容的 SHA-256 哈希生成确定性的 UUID。</span></span><br><span class="line"><span class="string">    :param content: `deterministic_uuid` 函数中的 `content` 参数可以是字符串或字节数据类型。</span></span><br><span class="line"><span class="string">    :type content: Union[str, bytes]</span></span><br><span class="line"><span class="string">    :return: 以字符串形式返回 UUID（通用唯一标识符）。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(content, <span class="built_in">str</span>):</span><br><span class="line">        content_bytes = content.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(content, <span class="built_in">bytes</span>):</span><br><span class="line">        content_bytes = content</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Content type <span class="subst">&#123;<span class="built_in">type</span>(content)&#125;</span> not supported !&quot;</span>)</span><br><span class="line">    hash_object = hashlib.sha256(content_bytes)</span><br><span class="line">    hash_hex = hash_object.hexdigest()</span><br><span class="line">    namespace = uuid.UUID(<span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>)</span><br><span class="line">    content_uuid = <span class="built_in">str</span>(uuid.uuid5(namespace, hash_hex))</span><br><span class="line">    <span class="keyword">return</span> content_uuid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理带有嵌入的文档集合以及根据给定问题查询相关文档的方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChromaDB_VectorStore</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> config <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            config = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        path = config.get(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;CHROMADB&quot;</span>) <span class="comment"># 向量数据库保存地址</span></span><br><span class="line">        self.embedding_function = config.get(<span class="string">&quot;embedding_function&quot;</span>, default_ef) <span class="comment"># 向量化方法</span></span><br><span class="line">        curr_client = config.get(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;persistent&quot;</span>) <span class="comment"># 客户端类型，允许直接传入一个客户端</span></span><br><span class="line">        collection_metadata = config.get(<span class="string">&quot;collection_metadata&quot;</span>, <span class="literal">None</span>) <span class="comment"># metadata</span></span><br><span class="line">        self.n_results = config.get(<span class="string">&quot;n_result&quot;</span>, <span class="number">10</span>) <span class="comment"># 最大查询返回数量</span></span><br><span class="line">        self.collection_name = config.get(<span class="string">&quot;collection&quot;</span>,<span class="string">&quot;documentation&quot;</span>) <span class="comment"># 当前数据库的名称</span></span><br><span class="line">        <span class="keyword">if</span> curr_client == <span class="string">&quot;persistent&quot;</span>:</span><br><span class="line">            self.chroma_client = chromadb.PersistentClient(</span><br><span class="line">                path=path, settings=Settings(anonymized_telemetry=<span class="literal">False</span>)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> curr_client == <span class="string">&quot;in-memory&quot;</span>:</span><br><span class="line">            self.chroma_client = chromadb.EphemeralClient(</span><br><span class="line">                settings=Settings(anonymized_telemetry=<span class="literal">False</span>)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(curr_client, chromadb.api.client.Client): <span class="comment"># type: ignore</span></span><br><span class="line">            self.chroma_client = curr_client<span class="comment"># 允许直接提供客户端</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;在配置中设置了不支持的客户端: <span class="subst">&#123;curr_client&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.collection = self.chroma_client.get_or_create_collection(</span><br><span class="line">            name=self.collection_name,</span><br><span class="line">            embedding_function=self.embedding_function,</span><br><span class="line">            metadata=collection_metadata,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_embedding</span>(<span class="params">self, data: <span class="built_in">str</span>, **kwargs</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        接受字符串输入，使用指定函数生成嵌入，并将嵌入作为浮点数列表返回。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param data: `generate_embedding` 函数中的 `data` 参数是一个字符串，表示要生成嵌入的输入数据。</span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :return: 如果 `embedding` 列表的长度为 1，则该函数将返回列表的第一个元素。否则，它将返回整个 `embedding` 列表。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        embedding = self.embedding_function([data])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(embedding) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> embedding[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> embedding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_documentation</span>(<span class="params">self, documentation: <span class="built_in">str</span>, **kwargs</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将文档及其相应的嵌入添加到集合中并返回生成的 ID。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param documentation: `add_documentation` 方法接受一个 `documentation` 参数，该参数是包含要添加的文档的字符串。此方法还接受其他关键字参数</span></span><br><span class="line"><span class="string">        (**kwargs) 以提高灵活性。</span></span><br><span class="line"><span class="string">        :type documentation: str</span></span><br><span class="line"><span class="string">        :return: 返回添加到集合中的文档的 `id`。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">id</span> = deterministic_uuid(documentation)</span><br><span class="line">        self.collection.add(</span><br><span class="line">            documents=documentation,</span><br><span class="line">            embeddings=self.generate_embedding(documentation),</span><br><span class="line">            ids=<span class="built_in">id</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_training_data</span>(<span class="params">self, **kwargs</span>) -&gt; pd.DataFrame:</span><br><span class="line">        collection_data = self.collection.get()</span><br><span class="line">        df = pd.DataFrame()</span><br><span class="line">        <span class="keyword">if</span> collection_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            documents = [doc <span class="keyword">for</span> doc <span class="keyword">in</span> collection_data[<span class="string">&quot;documents&quot;</span>]]</span><br><span class="line">            ids = collection_data[<span class="string">&quot;ids&quot;</span>]</span><br><span class="line">            df_doc = pd.DataFrame(&#123;<span class="string">&quot;id&quot;</span>: ids,</span><br><span class="line">                                   <span class="string">&quot;question&quot;</span>: [<span class="literal">None</span> <span class="keyword">for</span> doc <span class="keyword">in</span> documents],</span><br><span class="line">                                   <span class="string">&quot;content&quot;</span>: [doc <span class="keyword">for</span> doc <span class="keyword">in</span> documents]&#125;</span><br><span class="line">                                  )</span><br><span class="line">            df_doc[<span class="string">&quot;training_data_type&quot;</span>] = self.collection_name</span><br><span class="line">            df = pd.concat([df, df_doc])</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_training_data</span>(<span class="params">self, <span class="built_in">id</span>: IDs, **kwargs</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据提供的 ID 从集合中删除训练数据。</span></span><br><span class="line"><span class="string">        :param id: `remove_training_data` 方法中的 `id` 参数为 `IDs` 类型。它用于指定需要从集合中移除的训练数据的标识符。</span></span><br><span class="line"><span class="string">        :type id: IDs</span></span><br><span class="line"><span class="string">        :return: 返回一个布尔值。如果成功删除了指定 ID 的训练数据，则返回 `True`；如果删除过程中出现错误，则返回 `False`。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.collection.delete(ids=<span class="built_in">id</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_collection</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        尝试删除一个集合并在必要时重新创建它，如果成功则返回 True，否则返回 False。</span></span><br><span class="line"><span class="string">        :return: `remove_collection` 方法返回一个布尔值 - 如果集合被成功删除并重新创建，则返回 `True`；如果在此过程中发生异常，则返回 `False`。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.chroma_client.delete_collection(name=self.collection_name)</span><br><span class="line">            self.collection = self.chroma_client.get_or_create_collection(</span><br><span class="line">                    name=self.collection_name, embedding_function=self.embedding_function</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_extract_documents</span>(<span class="params">query_results,collection_name</span>) -&gt; <span class="built_in">list</span>: <span class="comment"># type: ignore</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        该函数从查询结果中提取文档，处理文档嵌套在列表中的情况。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param query_results:</span></span><br><span class="line"><span class="string">        您提供的代码片段似乎是一个名为“_extract_documents”的函数，它以“query_results”作为参数，并应该返回从查询结果中提取的文档列表。但是，代码片段中有几个问题需要解决：</span></span><br><span class="line"><span class="string">        :return: 变量“document”，但 return 语句似乎有拼写错误。应该是“return documents”，而不是“return document”。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> query_results <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;documents&quot;</span> <span class="keyword">in</span> query_results:</span><br><span class="line">            documents = query_results[<span class="string">&quot;documents&quot;</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(documents) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">isinstance</span>(documents[<span class="number">0</span>], <span class="built_in">list</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    documents = [json.loads(doc) <span class="keyword">for</span> doc <span class="keyword">in</span> documents[<span class="number">0</span>]]</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">return</span> documents[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> documents</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_related</span>(<span class="params">self, question: <span class="type">Optional</span>[OneOrMany[Document]], **kwargs</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用给定的问题查询集合并返回相关文档的列表。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param question: `get_related` 方法中的 `question` 参数属于 `Optional[OneOrMany[Document]]` 类型。这意味着它可以接受单个</span></span><br><span class="line"><span class="string">        `Document` 对象或 `Document` 对象集合，也可以为 `None`。</span></span><br><span class="line"><span class="string">        :type question: Optional[OneOrMany[Document]]</span></span><br><span class="line"><span class="string">        :return: 返回文件清单。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = self.collection.query(query_texts=question,n_results=self.n_results)</span><br><span class="line">        <span class="keyword">return</span> ChromaDB_VectorStore._extract_documents(res,self.collection_name)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    config = &#123;<span class="string">&quot;path&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="string">&quot;embedding_function&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="string">&quot;client&quot;</span>:<span class="built_in">object</span>,</span><br><span class="line">              <span class="string">&quot;collection_metadata&quot;</span>:<span class="literal">None</span>,</span><br><span class="line">              <span class="string">&quot;n_result&quot;</span>:<span class="number">10</span>,</span><br><span class="line">              <span class="string">&quot;collection&quot;</span>:<span class="string">&quot;doc&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title>时区与时间</title>
    <url>/2024/04/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%97%B6%E5%8C%BA%E4%B8%8E%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="GMT：格林威治时间"><a href="#GMT：格林威治时间" class="headerlink" title="GMT：格林威治时间"></a>GMT：格林威治时间</h2><p>格林威治（也称：格林尼治）(Greenwich Mean Time，简称G.M.T.) 时间，也叫世界时（Universal Time），也叫世界标准时间。是指位于英国伦敦郊区的【皇家格林尼治天文台】的标准时间，是本初子午线上的地方时，是0时区的区时。</p>
<p>众所周知，中国统一用的北京时间是位于东八区（+8）与标准时间相差8小时。什么含义？举个例子：若GMT（英国伦敦的格林威治）现在是上午11点，那中国北京时间现在就是 11 + 8 = 19点（下午7点）。将这个公式再抽象一下，可表示为：本地时间=GMT＋时区差北京位于东八区，则时区差N=+8，美国纽约位于西五区，则时区差N=-5。这么算来，若北京时间是晚上23点的话，美国纽约时间就是当天上午10点（23 - 8 - 5 = 10）</p>
<blockquote>
<p>凭什么格林威治作为标准时间？</p>
</blockquote>
<p>时区（Time zone）是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）,为了克服时间上的混乱，1884年在华盛顿召开了一次国际经度会议（又称国际子午线会议）， 会议上制定了全球性的标准时。它规定英国格林威治天文台旧址为全球时间的中心点（零时区），并由它负责维护和计算格林威治天文台观测所门口墙上有一个标志24小时的时钟，显示当下的时间.</p>
<p>从1924年开始，格林威治天文台每小时就会向全世界播报时间（截止到1979年）对全球而言，这里所设定的时间是世界时间参考点，全球都以格林威治的时间作为标准来设定时间，这就是我们耳熟能详的「格林威治标准时间 GMT」的由来其实选择英国格林威治最主要原因是：当时大部分的船只都已经以格林威治子午线做为参考标准，毕竟曾经的英国可是日不落帝国，大航海时代末便开始称霸世界，拳头里面出政权。格林威治天文台在计时领域的权威是非常大的，譬如离我们最近的一次“时间风波”：在即将跨世纪的时候，世界各国对21世纪到底应该从2000年开始还是从2001年开始争论不休，最终还是格林威治天文台出面平息了争论，开新闻发布会宣布21世纪始于2001年。除了选定中心点作为时间时之外，它还规定将全球划分为24个时区（东、西各12个时区）：<br>地球绕自转轴自西向东的转动（太阳东起西落），所以东时区的人会比西时区的人早一些看到太阳，从而时间上会早一点。</p>
<p>因此，以通过格林威治的子午线作为划分地球东西两半球的经度零度，按照地球自转方向，每隔经度15°划分一个时区的方法，全球共分为24个时区：东1区至东12区，西1区至西12区，其中东西12区跨度都是7.5°也叫半时区。<br>每差一个时区，区时相差一个小时，相差多少个时区，就相差多少个小时，这是理论时区。<br>现实情况中为了避开国界线，有的时区的形状并不规则，而且比较大的国家以国家内部行政分界线为时区界线，被称为法定时区。</p>
<blockquote>
<p>中国有哪几个时区？</p>
</blockquote>
<p>中国大陆共横跨5个时区，但是选用东八区时间作为全国标准时间。</p>
<p>中国用统一时间在沟通上确实方便得多，减少了很多不必要的麻烦。但是也带来一些“小问题”，比如新疆的朋友（位于东5/6区）实际比东八区的北京时间晚了 2-3个小时，我们正常7点天黑准备吃完饭的时候，新疆那边还太阳当空照呢</p>
<h2 id="UTC：世界协调时间"><a href="#UTC：世界协调时间" class="headerlink" title="UTC：世界协调时间"></a>UTC：世界协调时间</h2><p>有一些表，上面标识了GMT，则代表此表具有两地时间功能，也就是同时可以显示原居地和另一个国度的时间。但也有些两地时间表上看不到GMT字样，出现的反而是UTC这3个英文字母。这是怎么回事呢？事实上，UTC指的是Coordinated Universal Time－ 世界协调时间（又称世界标准时间、世界统一时间），它是以原子时作为计量单位的时间，计算结果极其严谨和精密。它比GMT时间更来得精准，误差值必须保持在0.9秒以内，倘若大于0.9秒就会通过位于巴黎的国际地球自转事务中央局发布的闰秒来“解决”。不过对于现行表款来说，GMT与UTC的功能与精确度是没有差别的。</p>
<h3 id="原子时"><a href="#原子时" class="headerlink" title="原子时"></a>原子时</h3><p>物质的原子内部发射的电磁振荡频率为基准的时间计量系统。美国的物理实验市在2014年造出了人类历史上最精确的原子钟，50亿年误差1s，可谓相当靠谱了。中国的铯原子钟也能确保2000万年误差不超过1s。</p>
<h3 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h3><p>1979年12月初内瓦举行的世界无线电行政大会通过决议，确定用“世界协调时间（UTC时间）”取代“格林威治时间（GMT时间）”，作为无线电通信领域内的国际标准时间。</p>
<blockquote>
<p>UTC和GMT都称作世界标准时间，为毛有了GMT还搞出个UTC</p>
</blockquote>
<h3 id="GMT"><a href="#GMT" class="headerlink" title="GMT"></a>GMT</h3><p>老的时间计量标准，根据地球的自转和公转来计算时间的，自转一圈是一天，公转一圈是一年。但是呢，地球公转的轨道是椭圆形的，并且后来人们发现地球的自转时间也并不是恒定的，这么一来就会造成有一天时间长一些，有一天时间短一些的情况，误差较大给人感觉时间不那么“精准”了，因此迫切需要一个更加精准的方案来计时，UTC诞生了。</p>
<h3 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h3><p>1967年人类制作出原子钟，从而“发明”了UTC时间正式投入使用。它是真正意义上的标准时间，以原子钟所定义的秒长为基础，UTC时间认为一个太阳日（一天）总是恒定的86400秒（24小时）。<br>UTC是协调时间，含义为：一切以我为基准，全部想我看齐。所以称它为世界标准时间是没毛病的，而把GMT称作格林威治当地时间更为合适（也叫旧的标准时间）。<br>由于在大多数情况下，UTC时间能与GMT时间互换。对此很多同学就丈二和尚摸不着头脑了，他俩这不就一样的吗？</p>
<p>其实非也。这里用通俗易懂的一句话来告知它俩的联系：</p>
<ul>
<li>UTC是标准时间参照，像GMT（格林威治时间）、ET（美国东部时间）、PST（太平洋时间）、CST（北京时间）等等都是具体的时区时间。</li>
<li>GMT能和UTC直接转换，仅仅是因为碰巧GMT是0时区时间，数值上刚好和UTC是相等的（不需要精确到秒的情况下，二者可以视为相等），看起来一样，但是概念含义上请务必区分开来哈。</li>
</ul>
<h3 id="UTC与偏移量"><a href="#UTC与偏移量" class="headerlink" title="UTC与偏移量"></a>UTC与偏移量</h3><p>在日常生活中，我们所使用的时间肯定是本地时间。在只有GMT的时候，本地时间是通过时区计算出来的，而现在UTC才是标准参考，因此采用UTC和偏移量（Offset）的方式来表示本地时间</p>
<p>这个偏移量可表示为：UTC -或UTC +，后面接小时数,分钟数。如：UTC +9:30表示澳大利亚中央标准时间，UTC +8表示中国标准时间。偏移量常见的表示形式有：±[hh]:[mm]、±[hh][mm]、±[hh]这三种方式均可。</p>
<blockquote>
<p>举个例子：现在UTC时间是10:30z（z表示偏移量=0），那么北京时间现在若是1630 +0800（下午4点半），对应的纽约时间就是0530 -0500（早上5点半）。</p>
</blockquote>
<blockquote>
<p>注意：在UTC的世界里并无时区的概念，而是偏移量（时间点跟上偏移量才是一个正规的UTC时间），它和时区并无直接关系</p>
</blockquote>
<p>可以看到偏移量可以精确到分钟级别控制，非常精细化。全球只有24个时区（只能精确到小时），但偏移量有“无数个”。当然喽为了方便沟通，时间日期联盟组织把世界主要国家/城市的偏移量汇总起来且都给取了个Time zone name名称用于沟通，共好几百个。 在可以这里看</p>
<h2 id="CST时间"><a href="#CST时间" class="headerlink" title="CST时间"></a>CST时间</h2><p>CST这个缩写比较尴尬的是它可以同时代表四个不同的时间：</p>
<ul>
<li>Central Standard Time (USA) UT-6:00</li>
<li>Central Standard Time (Australia) UT+9:30</li>
<li>China Standard Time UT+8:00</li>
<li>Cuba Standard Time UT-4:00</li>
</ul>
<p>可见，CST可以同时表示美国，澳大利亚，中国，古巴四个国家的标准时间。CST到底啥意思就看如何翻译喽，所以需要根据上下文语境自行抉择</p>
<h2 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h2><p>在时间日期上它全称是ISO 8601，是一种日期/时间表示方法的规范。规定了一种明确的、国际上都能理解的日历和时钟格式。</p>
<p>这一ISO标准有助于消除各种日-日惯例、文化和时区对全球业务产生的影响。它提供了一种显示日期和时间的方式，这种方式是明确定义的，对人和机器都是可以理解的。当日期用数字表示时，它们可以以不同的方式进行解释。例如，01/05/12可以表示2012年1月5日或2012年5月1日。在个人层面上，这种不确定性可能非常令人沮丧，在商业环境中，它可能非常昂贵。在日期不明确的情况下，组织会议和交付、书写合同和购买机票都是非常困难的。</p>
<p>ISO 8601通过制定一种国际公认的日期表示方式来解决这种不确定性：YYYY-MM-DD。例如 September 27, 2012就会被表示为2012-09-27。</p>
<p>很多开发语言内置了一些常用的ISO标准日期/时间格式，如Java中的： - ISO.DATE：yyyy-MM-dd, e.g. “2000-10-31” - ISO.TIME：HH:mm:ss.SSSXXX, e.g. “01:30:00.000-05:00” - ISO.DATE_TIME：yyyy-MM-dd’T’HH:mm:ss.SSSXXX, e.g. “2000-10-31T01:30:00.000-05:00”.</p>
<h2 id="DST：夏令时-夏日节约时间"><a href="#DST：夏令时-夏日节约时间" class="headerlink" title="DST：夏令时/夏日节约时间"></a>DST：夏令时/夏日节约时间</h2><p>DST（Daylight Saving Time），夏令时又称夏季时间(Summer Time)</p>
<p>是指在夏天太阳升起的比较早时，将时钟拨快一小时，以提早日光的使用。它是为节约能源而人为规定地方时间的制度（鼓励人们早睡早起，不要浪费电，夏天日照时间长尽量多用自然资源）<br>每年的夏令时时间段还不一样（一般在3月的第2个周日开始），比如美国2020年夏令时时间是：2020年3月8日 - 2020年11月1日。具体做法是：在3.8号这天将时钟往前拨拨1个小时，11.1号这天还原回来。<br>中国在1986 - 1992年短暂搞过一段时间，但太麻烦就“废弃”了</p>
<h3 id="大事记-1"><a href="#大事记-1" class="headerlink" title="大事记"></a>大事记</h3><p>目前全世界有近110个国家每年要实行夏令时。 自2011年3月27日开始俄罗斯永久使用夏令时，把时间拨快一小时，不再调回。</p>
<h3 id="冬令时"><a href="#冬令时" class="headerlink" title="冬令时"></a>冬令时</h3><p>冬令时就是从夏令时调回来的时间，也就是时光倒退，2点变成1点的那个瞬间，这个1点就是冬令时的开始啦。其实冬令时才是英国“真正”的时间。夏令时的时间要往前调1个小时（+1），那么冬令时一到，时间是需要往后调1个小时（-1），这样一加一减，互相抵消，英国就又回到了零时区。</p>
<p>11月2号凌晨1:59的时候。下一分钟变成了凌晨1:00</p>
<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>现实生活的世界里，时间是不断向前的，如果向前追溯时间的起点，可能是宇宙出生时，又或是是宇宙出现之前，但肯定是我们目前无法找到的，我们不知道现在距离时间原点的精确距离。所以我们要表示时间， 就需要人为定义一个原点。它就是：格林威治时间(GMT)1970年1月1日的午夜0点0分0秒。</p>
<p>时间戳一般指的UNIX时间，或类UNIX系统（比如Linux、MacOS等）使用的时间表示方式。定义为：从UTC时间的1970-1-1 0:0:0起到现在的总秒数（秒是毫秒、微妙、纳秒的总称）。它不考虑闰秒，又名 Unix epoch、Unix time、POSIX time。</p>
<blockquote>
<p>为什么要有时间戳</p>
</blockquote>
<p>在某一个具体的时刻，时间戳只有一个，例如1567819100。在该时刻，用户在中国、朝鲜、巴基斯坦、美国读取的值都是一样的，因为时间戳是相对于UTC时间的。也就是说对于一家跨国公司来说，某个订单发生的时间，记录成时间戳的形式，然后在转换为不同的时刻</p>
<h2 id="网络时间协议"><a href="#网络时间协议" class="headerlink" title="网络时间协议"></a>网络时间协议</h2><p>上面说到，时间戳是不考虑闰秒的。但是不可忽略的一个case：由于闰秒的存在，那么当闰秒发生时，就极有可能出现同一个时间戳表示两个时刻的情况（类似时钟回拨），而且闰秒还没规律所以无法程序式的避免，怎么破？<br>这个时候就需要一种专门的对时协议来保证了，它就是：网络时间协议。</p>
<h3 id="网络时间协议-1"><a href="#网络时间协议-1" class="headerlink" title="网络时间协议"></a>网络时间协议</h3><p>网络时间协议 Network Time Protocol（NTP）是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。</p>
<p>NTP的目的是在无序的Internet环境中提供精确和健壮的时间服务，各大操作系统（windows/Linux）对NTP都有实现。</p>
<p>时间点、时间段、时长,可以把时间想象成一个向前和向后都无限延申的实数轴，那么：</p>
<ul>
<li>时间点是数轴上的一个点</li>
<li>时间段就是两个时间点之间确定的一个区间</li>
<li>时长（时间长度）就是一个有正负号的标量，它是两个时间点之差，不属于数轴</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>管理员权限执行代码</title>
    <url>/2022/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在代码部署的过程当中往往需要使用管理员权限执行代码，这里涉及多种情况：</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux上使用管理员权限执行代码是最简单的，只需要使用root登录就可以直接使用管理员权限执行代码，代码具有调用系统资源的权限。</p>
<h3 id="windows-编辑器上"><a href="#windows-编辑器上" class="headerlink" title="windows 编辑器上"></a>windows 编辑器上</h3><p>编辑器获得管理员权限其实情况很少，但是并不是没有。获得管理员权限的编辑器有三个好处：</p>
<ul>
<li>直接打开管理员才能够打开的文件夹查看内容</li>
<li>打开管理员权限的文件</li>
<li>执行的代码都是管理员权限</li>
<li>快捷键拥有最高权限，不会与其他没有管理员权限的软件产生快捷键冲突</li>
<li>可能有更多功能提供(看编辑器情况)</li>
</ul>
<p>个人现在最常遇到的问题是，我执行的代码需要管理员权限才能够正常执行，需要调用一些系统文件，但是编辑器不是，这就导致代码没有权限，不能够调试。但是打开也很简单：</p>
<ul>
<li>右键编辑器-&gt;属性-&gt;兼容性-&gt;以管理员身份运行此程序</li>
<li>右键编辑器-&gt;管理员权限运行</li>
</ul>
<h3 id="windows-文件"><a href="#windows-文件" class="headerlink" title="windows 文件"></a>windows 文件</h3><p>文件的执行有两种，第一种是以管理员权限启动cmd执行，第二种就是在代码当中获取管理员权限，保证程序从逻辑上一定是拥有管理员权限的。</p>
<p>代码如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes, sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_admin</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ctypes.windll.shell32.IsUserAnAdmin()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> is_admin():</span><br><span class="line">    <span class="comment"># 这里写入需要管理员权限执行的操作</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.version_info[<span class="number">0</span>] == <span class="number">3</span>:</span><br><span class="line">    	ctypes.windll.shell32.ShellExecuteW(<span class="literal">None</span>, <span class="string">&quot;runas&quot;</span>, sys.executable, __file__, <span class="literal">None</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>管理员权限</tag>
      </tags>
  </entry>
  <entry>
    <title>设置虚拟环境为32位或64位</title>
    <url>/2023/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%B8%BA32%E4%BD%8D%E6%88%9664%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="检查或更改conda设置"><a href="#检查或更改conda设置" class="headerlink" title="检查或更改conda设置"></a>检查或更改conda设置</h2><p>通过anaconda prompt，输入 conda info ，显示conda信息并检查平台</p>
<h2 id="检查Python环境"><a href="#检查Python环境" class="headerlink" title="检查Python环境"></a>检查Python环境</h2><p>prompt中输入python，检查当前环境中的Python是64位还是32位,” MSC v.1916 32位”为32位，” MSC v.1916 64位”为64位。</p>
<h2 id="切换到64位平台及环境"><a href="#切换到64位平台及环境" class="headerlink" title="切换到64位平台及环境"></a>切换到64位平台及环境</h2><ul>
<li>第一步：set CONDA_FORCE_32BIT=0 </li>
<li>第二步：set CONDA_SUBDIR=win-64</li>
<li>第三步：conda info 查看结果</li>
</ul>
<h2 id="创建虚拟环境来安装64位的python"><a href="#创建虚拟环境来安装64位的python" class="headerlink" title="创建虚拟环境来安装64位的python"></a>创建虚拟环境来安装64位的python</h2><p>prompt中输入conda create -n python39_64 python=3.9</p>
<h2 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h2><p>conda activate python39_64</p>
<blockquote>
<p>可能遇到的问题<br>如果发现虚拟环境安装的python不是64位的。则需要先执行命令conda deactivate退出虚拟环境，conda remove -n python39_64 –all 删除刚创建的虚拟环境，再试着重新操作（1）（2）步骤下载64位python。</p>
</blockquote>
<p>至此，已经完成python32位和64位并存。</p>
<h2 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h2><p>执行命令conda deactivate</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发下设置Linux打开文件数</title>
    <url>/2023/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E8%AE%BE%E7%BD%AELinux%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%95%B0/</url>
    <content><![CDATA[<p>在linux中，一切皆文件，所以连接数本身也会表现为文件打开数。默认情况下，linux单进程打开文件数的限制是1024 ， 非常低，在密集io型服务里很容易超过。</p>
<p>代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/sysctl.conf ,末尾添加</span></span><br><span class="line">fs.file-max = 655350000sss</span><br><span class="line">fs.nr_open = 655350000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令生效</span></span><br><span class="line">sysctl -p</span><br><span class="line"><span class="comment"># 查看 max-file：</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/fs/file-max</span><br><span class="line"><span class="comment"># 查看当前系统总打开文件数</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/fs/file-nr</span><br><span class="line"><span class="comment"># 输出: 9344 0 592026，</span></span><br><span class="line"><span class="comment"># 分别为：1.已经分配的文件句柄数，2.已经分配但没有使用的文件句柄数，3.最大文件句柄数。</span></span><br><span class="line"><span class="comment"># 修改系统对单个进程打开的文件数限制</span></span><br><span class="line"><span class="built_in">ulimit</span> -n 655350000</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nofile 655350000&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nofile 655350000&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="comment"># 顺便附上查看各个进程打开的文件数的命令。显示格式是文件数 + 进程id</span></span><br><span class="line">lsof -n |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|<span class="built_in">sort</span>|<span class="built_in">uniq</span> -c|<span class="built_in">sort</span> -nr|more</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有安装nginx做转发，则还需要设置nginx </span></span><br><span class="line"><span class="comment">#打开nginx本身的文件数限制</span></span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line"><span class="comment"># 找到相应位置覆盖修改这个配置</span></span><br><span class="line">worker_rlimit_nofile 655350000;</span><br><span class="line">events  &#123;</span><br><span class="line">  worker_connections 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi /etc/sysctl.conf 末尾添加tcp连接数相关配置</span><br><span class="line">net.core.somaxconn = 20480</span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 4096 4096 16777216</span><br><span class="line">net.ipv4.tcp_wmem = 4096 4096 16777216</span><br><span class="line">net.ipv4.tcp_mem = 786432 2097152 3145728</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.core.netdev_max_backlog = 20000</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_max_orphans = 131072</span><br><span class="line">net.ipv4.tcp_syncookies = 0</span><br><span class="line">之后执行 sysctl -p 生效</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>任性的进化复盘以及感悟</title>
    <url>/2022/11/27/%E6%9C%89%E6%84%9F-%E4%BB%BB%E6%80%A7%E7%9A%84%E8%BF%9B%E5%8C%96%E5%A4%8D%E7%9B%98%E4%BB%A5%E5%8F%8A%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>《任性的进化》是我在鲱鱼罐头app上玩的一个游戏，我觉得很有意思，想要分享出来。</p>
<h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>在一战期间，和平被战争取代。但是在1914年西方战线的圣诞节前夜发生了怪事，尽管在严格的军令下，甚至是在残酷的战争下，彼此互相杀害了对方的同胞这样的深仇大恨之下，英国人与德国人却违抗军令离开了战壕在圣诞节前夜与敌军聚在一起，一起玩游戏、唱歌、互赠礼物。这是一件非常神奇的事情，甚至这样的状态在部分地区持续了几天。  </p>
<p>所以这不免让人思考，人与人之间建立信任真的这么难吗？为什么现代社会没有战争感觉建立信任会更难呢？</p>
<blockquote>
<p>为什么要好的朋友会变成死对头，即使是在和平年代！<br>为什么互相杀戮的敌人会变成朋友，即使是在战争年代？</p>
</blockquote>
<p>而这一切的答案就在博弈论！</p>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>首先使用一个类似于囚徒困境的游戏来描述信任这一概念：</p>
<p>游戏是这样的，现在有一台机器，只能两个人操作，两个人彼此不知情。机器可以投入一枚硬币，然后给出两个选项分别是合作与欺骗。如果合作那么双方都能得到两个硬币，如果一方合作一方欺骗那么欺骗则会得到三个，合作则会失去投入的硬币。如果都选择了欺骗那么彼此都不损失。</p>
<p>现在游戏开始，我们把社会上的人分为五类人：</p>
<ul>
<li>$\color{blue}{复读机}$： 第一轮会合作，后续的选择会重复上一次对方的选择</li>
<li>$\color{black}{老油条}$： 永远不合作，只是欺骗</li>
<li>$\color{pink}{老好人}$： 永远合作，不欺骗</li>
<li>$\color{gray}{黑帮大哥}$： 一开始跟你合作，如果敢欺骗那么后续就别想合作了</li>
<li>$\color{brown}{侦探家}$： 会一开始合作，然后尝试欺骗，如果你不选择欺骗回来，那么就会变成千年$\color{black}{老油条}$，如果欺骗回来，后续就会乖乖合作成为$\color{blue}{复读机}$</li>
</ul>
<p>如果这五个人站在一起并且不知情的进行对局，那么最后是谁胜出呢？</p>
<blockquote>
<p>答案是： <strong>$\color{blue}{复读机}$</strong></p>
</blockquote>
<p>是的，$\color{blue}{复读机}$也有很多其他称呼，比如黄金准则、互惠互利、以牙还牙… 这也是为什么短暂的和平会在战争爆发的关键时期出现的原因。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>如果改变规则每一次这样的游戏之后，人数增多，然后反复玩这个游戏，每玩一轮之后将得分最高的玩家复制五个，然后将得分最低的玩家删除五个。你问为什么？  </p>
<p>因为 <strong>弱肉强食</strong></p>
<p>游戏开始的时候有十五个$\color{pink}{老好人}$，有五个$\color{blue}{复读机}$，有五个$\color{black}{老油条}$，游戏开始！！！！最后谁会赢呢？</p>
<blockquote>
<p>答案还是 <strong>$\color{blue}{复读机}$</strong></p>
</blockquote>
<p>但是$\color{pink}{老好人}$会优先完全出局，他们会被社会淘汰，最后$\color{black}{老油条}$也会被淘汰，只剩下$\color{blue}{复读机}$！这样的结果作者说想到了一句名言：</p>
<blockquote>
<p>我么们并不因罪恶受罚，而是罪恶本身会惩罚我们。  ——阿尔伯特.哈伯德</p>
</blockquote>
<p>但是我却想用中国的一些话来总结：</p>
<blockquote>
<p>- “以德报怨，何如？”<br>- “以德报怨，何以报德？以直报怨，以德报德。”</p>
</blockquote>
<p>看来夫子还是走在了前面！</p>
<hr>
<p>其实最后加入其他成员，全部设定为五个也是差不多的，但是少数黑帮老大会留下来，因为黑帮老大会与$\color{blue}{复读机}$达成协议，咋们互不侵犯！</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>但是这能够说明什么呢？是因为$\color{blue}{复读机}$占有人数优势吗？我们都知道这个社会上充满了$\color{black}{老油条}$，有时候身边可能全部都是$\color{black}{老油条}$，这个$\color{blue}{复读机}$可能也不一定能够胜出了。所以抛开人物设定返规则本身…  </p>
<p>这个游戏本就是模拟真实的世界，欺骗者会获利，合作会双赢的规则之下。所以假设世界上全部都是$\color{pink}{老好人}$，只有一个$\color{blue}{复读机}$还有一个$\color{black}{老油条}$。那么结局会怎样呢？</p>
<blockquote>
<p>小粉红一开始会处于劣势，最后被淘汰，$\color{black}{老油条}$会发展壮大，但是越往后$\color{blue}{复读机}$又会逐渐取得优势。</p>
</blockquote>
<p>所以人与人之间越来越少的重复互动所带来的影响就是不信任的加剧扩散。这有一点像中国的人情社会，你来我往建立信任关系最后$\color{blue}{复读机}$胜出，如果缺少这样的互动，结果可能不是很乐观！</p>
<hr>
<p>但是如果改变规则，我们将合作变为无收益，然后会发生什么呢？答案是$\color{black}{老油条}$的会处于劣势地位，这样的结果可以参考两个概念:</p>
<ul>
<li>零和游戏： 游戏的双方都悲观的相信己方的得到东西必然来自于对方的失去，反之亦然。</li>
<li>非零和游戏： 游戏的双方都努力的想要创造双赢的局面，如果没有非零和游戏，那么人与人之间的信任则不可能传播。</li>
</ul>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>但是可能真实情况不是像游戏那样，因为很多时候我们都想双赢但是假设一方出意外了导致一方无端受到损失了，那么这就是产生了欺骗。作为$\color{blue}{复读机}$可能就会将这样的不信任无限的传递下去，不信任开始变多了，因为意外总是会无限增多的。  </p>
<p>现在挑战变成了三种人：</p>
<ul>
<li>$\color{blue}{复读机}$： 第一轮会合作，后续的选择会重复上一次对方的选择</li>
<li>$\color{yellow}{一根筋}$： 先合作，然后会做出跟上一轮自己做出选择一样的选择，如果欺骗了我，我就会做出与上一轮相反的选择。反之亦然。</li>
<li>$\color{red}{胡乱来}$： 乱来，谁也不知道他要做什么选择</li>
<li>$\color{cyan}{复读鸭}$： 先合作，只有被欺骗两次才会反击</li>
</ul>
<p>现在游戏十五个$\color{black}{老油条}$，三个$\color{cyan}{复读鸭}$，三个$\color{yellow}{一根筋}$，三个$\color{red}{胡乱来}$，三个$\color{blue}{复读机}$，游戏开始….</p>
<blockquote>
<p>结果是$\color{cyan}{复读鸭}$赢了，但是最后还是会有一部分$\color{blue}{复读机}$幸存，所以看来一个更加宽容的处事方式可能更加可能赢得胜利。</p>
</blockquote>
<p>但是现在只是说会犯错，假设犯错概率变高了还会这样吗？<br>结果是悲观的，太多的失误会导致不信任的逐渐蔓延开来。最后只有$\color{black}{老油条}$能够苟活，因为他们真的很自私。</p>
<blockquote>
<p>最后模拟实验的结果是：</p>
<ul>
<li>犯错0% $\color{blue}{复读机}$胜利</li>
<li>犯错1-9%$\color{cyan}{复读鸭}$胜利</li>
<li>犯错10-49% $\color{black}{老油条}$胜利</li>
<li>犯错》=50% 没人胜利</li>
</ul>
</blockquote>
<p>一个小小的误解可能会得到宽容，但是太多的误解会导致不信任的扩散，若如果误解太多那么会灭绝。</p>
<h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>博弈论想我们揭示了三个重要的思想：</p>
<h3 id="重复动作"><a href="#重复动作" class="headerlink" title="重复动作"></a>重复动作</h3><p>信任是保持人机关系长久的基石，但是信任能够建立的前提是你要知道你们未来也会有重样的步骤</p>
<h3 id="双赢并非不可能"><a href="#双赢并非不可能" class="headerlink" title="双赢并非不可能"></a>双赢并非不可能</h3><p>你必须进行非零和游戏，而在这样的游戏博弈当中，并要求两个玩家都变得更好，达到双赢，但至少必须要有达成双赢的可能性存在。</p>
<h3 id="低概率的误解"><a href="#低概率的误解" class="headerlink" title="低概率的误解"></a>低概率的误解</h3><p>如果误解的概率太多就会导致信任的瓦解，如果有一点点宽容则会让信任再次蔓延开来。</p>
<blockquote>
<p>当然这只是总结，现实当中实际有更多的情况，比如文化、宗教、年龄、性别、工作、语言等等</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望所有明白这个道理的人都努力的去构建信任，给别人更多的宽容，让信任逐渐蔓延开来吧。</p>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>有时候宽容一点确实可以让信任更加长久，对于我个人来说我也是一直贯彻这一理念，如果你对我不好你可以坦白跟我说你的难处，可以跟我敞开心扉说明你需要的帮助，那我也会帮助你，即使这可能让我的生活变得难一些。但是如果你一开始就没有坦诚相待，选择了欺骗或者不加以正面回答，那么对不起了，我们已经失去了作为朋友的机会，如果还有下次，那么我们就会失去联系。  </p>
<p>与此同时我也想说，这个世界上: <strong>君子易交，小人难防</strong></p>
<p>各位擦亮眼睛吧！</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>孩子是谁的？</title>
    <url>/2022/11/29/%E6%9C%89%E6%84%9F-%E5%AD%A9%E5%AD%90%E6%98%AF%E8%B0%81%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<p>在经典的一则故事中，一个小孩子因为被人遗失所以从小在富家长大，而后富家主人死去孩子还尚不醒事，更不记得生母是谁。知县为了找到谁是孩子的母亲于是发布公告，许久之后两位年龄相仿的女人前来寻子。一位衣着华丽，一位衣衫破败。两人都是声称自己是孩子生母，知县害怕孩子以及富人家产落入歹人之手，于是让两位孩子母亲证明。可是空口无凭谁都无法证明自己才是生母！<br>知县思考良久决定让两位母亲直接争抢孩子，谁抢过了孩子就是谁的。强孩子开始后生母怕孩子在抢夺过程受到伤害主动放手放弃抢夺，由此知县判断出衣衫破烂的女子是孩子生母，并将假冒的恶人压入大牢。故事就此结束！<br>故事告诉了我们很多道理，母爱、人不可貌相、恶人终会受罚等等。。。但是故事真的结束了吗？？？</p>
<hr>
<p>假设在另一个平行世界当中，恶人也学着生母一样放手了，那该怎么办呢？且现在已经没有足够多的证据证明孩子的生母信息了，我们该怎么才能揪出恶人呢？</p>
<h2 id="博弈的思考"><a href="#博弈的思考" class="headerlink" title="博弈的思考"></a>博弈的思考</h2><p>很多对抗性质的东西都能够使用博弈论来进行求解，要知道，博弈需要的是拉开彼此之间的差距从而达到目的。比如最开始的的方法是考虑到利益最大化，因此贪婪的人不愿意放手，他们想要更多的利益，所以最后才会暴露自己的身份。所以反之，我们可以反向的降低收益，贪婪的人肯定会为了防止自己利益受损失从而主动退出。</p>
<p>所以现在可以反其道而行之，我们给两位母亲每人一张纸，让她们写出谁是生母，如果两个人写的人不是一个人，那么两个人都要被杀头，反之则是撒谎的人入狱关押。看上去很残忍但是这个方法却无限透露着智慧与巧妙。</p>
<h3 id="生母"><a href="#生母" class="headerlink" title="生母"></a>生母</h3><p>如果生母真的是生母，那么她会笃定的写上自己的名字。因为她知道，如果写了对方的名字，但是对方不一定自己写自己的名字，因为对方是假的，没有必要为了钱拼上命。而自己本身就是真的，写上去无非是一命换一命带走一个贪财无底线的骗子，或者自己活命骗子入狱，所以对于生母来说，死与不死都是赚的。  </p>
<h3 id="假母"><a href="#假母" class="headerlink" title="假母"></a>假母</h3><p>骗子一定会写上对方的名字，因为骗子知道自己是假的，对方很有可能是真的。真的那边肯定会笃定的写上她自己的名字，而自己这边没有必要为了钱而丢掉性命。如果骗子认为对方也是骗子，那就更难受了，因为对方很有可能写上了自己的名字，如果自己写对方的名字那么两个人都会死。所以骗子只能赌，赌对方是亲生母亲，只有这样才能活命。如果写对方的母亲，对方是亲生母亲自己是百分百活命，如果是假的自己有百分之五十概率活命。无论怎样，损失最小是写对方名字。</p>
<hr>
<table>
<thead>
<tr>
<th>生母</th>
<th>骗子</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>生母姓名</td>
<td>骗子姓名</td>
<td>两人都死，生母带走一个坏人，骗子失去所有</td>
</tr>
<tr>
<td>生母姓名</td>
<td>生母姓名</td>
<td>母子相认，骗子入狱</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>骗子</th>
<th>骗子</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>对方骗子姓名</td>
<td>对方骗子姓名</td>
<td>两个骗子死有余辜</td>
</tr>
</tbody></table>
<p>通过将收益无限降低后，两人的差距也被无限拉开了，这样孩子的母亲也找到了，坏人绳之以法，皆大欢喜，美好的结局啊！</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>回忆是本乱码的书</title>
    <url>/2024/12/01/%E6%9C%89%E6%84%9F-%E5%9B%9E%E5%BF%86%E6%98%AF%E6%9C%AC%E4%B9%B1%E7%A0%81%E7%9A%84%E4%B9%A6/</url>
    <content><![CDATA[<p>回忆是本乱码的书，你会时不时拼凑出一句完整的话，然后后知后觉</p>
<p>等你懂了，但也晚了</p>
<p>虽然晚了，但总算懂了，祝大家珍惜身边每一个人，每一段关系</p>
<p>我们无法判断此刻的价值，直到成为回忆</p>
<p>但我们可以让此刻的价值加倍</p>
<p>这样在回忆中见到当时那个错过同频的人，我们也可以笑着说：哦！～我懂你意思了</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>小心螃蟹</title>
    <url>/2022/10/07/%E6%9C%89%E6%84%9F-%E5%B0%8F%E5%BF%83%E8%9E%83%E8%9F%B9/</url>
    <content><![CDATA[<p>很多人都有一个常识：当我们往一个不高的容器中放进一只螃蟹时，它总会努力想尽办法逃出来。但如果放进去的是很多只螃蟹时，结果通常就是你拉我，我拽他，叠罗汉，最终谁也出不来。而在螃蟹群体中出现的这个特殊现象，竟然在人类群体中也同样适用。</p>
<p>这种现象我们称之为 Crab Mentality 螃蟹心理，那么螃蟹心理到底是怎么回事呢？把螃蟹放在桶里的时候，他们不会帮助对方逃脱。实际上，螃蟹群会阻止任何想单独逃脱的螃蟹。当一只螃蟹爬到桶的顶部时，其他的螃蟹会把他拽回来。这好像在说：“如果我要死了，那你也要一起死。”尽管螃蟹是否真的会这么做还有待探讨。但这种思维方式被称为“螃蟹心理”。它同时也可以应用到我们在生活中的表现。</p>
<p>比如，有一天，在一群不太关心学习的人中，有一个人决定要拿个好成绩。这个小组的其他成员不仅不会支持她，反而会嘲笑她，或者试图分散她在学习上的注意力。他们并不希望她成功，宁愿让她陷在跟他们一样的处境中。就好像在说，“如果我不能得到这个，那你也不能。” </p>
<p>这些人的心理就叫做“螃蟹心理”。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>知识的诅咒</title>
    <url>/2022/11/11/%E6%9C%89%E6%84%9F-%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AF%85%E5%92%92/</url>
    <content><![CDATA[<p>知识的诅咒（Curse of Knowledge）在维基百科中是这样定义的：知识的诅咒，是一种认知偏差，指人在与他人交流的时候，下意识地假设对方拥有理解所需要的背景知识。</p>
<p>换句话说就是人们在沟通的时候，往往会因为自己被所掌握的知识“诅咒”了，潜意识里认为对方也是明白自己话里的背景知识，而没有主动讲出来，最终导致出现误解。</p>
<hr>
<p>这个概念最初是在1989年发表在政治经济学杂志上的一篇文章提出，文中通过大量的试验数据说明了知识的诅咒对经济活动的影响，但实际上在生活的方方面面都有它的身影。</p>
<p>大部分人在青少年时期或多或少被家长训斥甚至“武力”教训过，当时对此都非常厌恶，但是当自己当上父母后，又会不知不觉甚至有时候无法抗拒的变成当初自己非常厌恶的人，很大的原因就是自己被知识诅咒了。</p>
<p>家长潜意识里是认为孩子和自己拥有一样的知识，所以难免会觉得孩子“笨”，特别是在辅导家庭作业的时候，但是孩子真的非常无辜。</p>
<hr>
<p>教育行业一直以来都在和知识的诅咒抗争，教师们教学经验的积累很大程度上都在一步步打破自己的知识诅咒，让自己能更好的把知识传递给学生。教育理论和教学方法的研究则是更系统化的与知识的诅咒的战斗。</p>
<p>以前我个人很早就知道知识的诅咒这个概念，但是不知不觉中我个人已经陷入知识的诅咒很久了，对待别人的时候总是客观的认为别人应当理解这些知识，甚至对于别人不理解这些知识有时候反而会觉得非常难以理解。主观的带入自己的思维，使用自己的思维给别人讲诉我所理解的抽象知识。想要破除知识的诅咒的最简单办法，应该是把自己当作外行人一样使用最为通俗的语言表达自己的想法，循循渐进的深入核心。而不是一开始就围绕着核心进行讨论，或许对于旗鼓相当的人来说，围绕核心讨论这样效率很高，但是对于有差距的人来说这或许是最糟糕的办法吧。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫hook</title>
    <url>/2022/11/30/%E7%88%AC%E8%99%AB-%E6%B5%8F%E8%A7%88%E5%99%A8hook/</url>
    <content><![CDATA[<p>hook本质上就是重写函数，因为js反爬也是通过重写函数来进行加密或者反爬的。记录两个小脚本用于hook，虽然我早已经不从事爬虫工作,唉~！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = Function</span><br><span class="line">Function = function(a)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a!==<span class="string">&#x27;debugger&#x27;</span>)&#123;<span class="keyword">return</span> f(a)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.constructor_ = Function.prototype.constructor;</span><br><span class="line">Function.prototype.constructor = function(x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x!==<span class="string">&#x27;debugger&#x27;</span>)&#123;<span class="keyword">return</span> Function.prototype.constructor_(x)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eval_ = <span class="built_in">eval</span>;</span><br><span class="line"><span class="built_in">eval</span> = function(a)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&#x27;debugger&#x27;</span>)</span><br><span class="line">    &#123;<span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="keyword">return</span> eval_(a)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout = function(a,b)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log_ = console.log</span><br><span class="line"></span><br><span class="line">Function.prototype.constructor_ = Function.prototype.constructor;</span><br><span class="line">Function.prototype.constructor = function(x)&#123;</span><br><span class="line">    debugger;</span><br><span class="line">    <span class="keyword">return</span> Function.prototype.constructor_(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">    Object.defineProperty(document, <span class="string">&#x27;cookie&#x27;</span>, &#123;</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            debugger;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">set</span>: function(value) &#123;</span><br><span class="line">            debugger;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/2022/10/16/%E7%AE%97%E6%B3%95-%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>常见的机器学习分类有，支持向量机、决策树、KNN、朴素贝叶斯，以前在学习机器学习的时候就简单学过，现在需要用在图像分类上了。一时间蒙了，忘记怎么图像转以前的数据了，现在在GitHub上找到一个不错的例子，特此记录一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;KaiTi&#x27;</span>]</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.serif&#x27;</span>] = [<span class="string">&#x27;KaiTi&#x27;</span>]</span><br><span class="line"><span class="comment"># mpl.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 解决保存图像是负号&#x27;-&#x27;显示为方块的问题,或者转换负号为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 第一步 切分训练集和测试集</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">X = []  <span class="comment"># 定义图像名称</span></span><br><span class="line">Y = []  <span class="comment"># 定义图像分类类标</span></span><br><span class="line">Z = []  <span class="comment"># 定义图像像素</span></span><br><span class="line"><span class="comment"># 记得更改此处4或者10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 遍历文件夹，读取图片</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">&quot;photo2/%s&quot;</span> % i):</span><br><span class="line">        <span class="comment"># 获取图像名称</span></span><br><span class="line">        X.append(<span class="string">&quot;photo2//&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;//&quot;</span> + <span class="built_in">str</span>(f))</span><br><span class="line">        <span class="comment"># 获取图像类标即为文件夹名称</span></span><br><span class="line">        Y.append(i)</span><br><span class="line"><span class="comment"># print(X)</span></span><br><span class="line"><span class="comment"># print(Y)</span></span><br><span class="line"><span class="comment"># os.walk 可以遍历多层路径，使用root, dirs, files</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># for root, dirs, files in os.walk(&quot;photo&quot;):</span></span><br><span class="line"><span class="comment">#         # Y.append(type_name)</span></span><br><span class="line"><span class="comment">#     for file in files:</span></span><br><span class="line"><span class="comment">#         X.append(os.path.join(root, file))</span></span><br><span class="line"><span class="comment"># print(X)</span></span><br><span class="line"><span class="comment"># print(Y)</span></span><br><span class="line"></span><br><span class="line">X = np.array(X)</span><br><span class="line">Y = np.array(Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机率为100% 选取其中的20%作为测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y,</span><br><span class="line">                                                    test_size=<span class="number">0.2</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(X_train), <span class="built_in">len</span>(X_test), <span class="built_in">len</span>(y_train), <span class="built_in">len</span>(y_test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 第二步 图像读取及转换为像素直方图</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集</span></span><br><span class="line">XX_train = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X_train:</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    <span class="comment"># print i</span></span><br><span class="line">    image = cv2.imdecode(np.fromfile(i, dtype=np.uint8), cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图像像素大小一致</span></span><br><span class="line">    img = cv2.resize(image, (<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">                     interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图像直方图并存储至X数组</span></span><br><span class="line">    hist = cv2.calcHist([img], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>,</span><br><span class="line">                        [<span class="number">256</span>, <span class="number">256</span>], [<span class="number">0.0</span>, <span class="number">255.0</span>, <span class="number">0.0</span>, <span class="number">255.0</span>])</span><br><span class="line"></span><br><span class="line">    XX_train.append(((hist / <span class="number">255</span>).flatten()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">XX_test = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X_test:</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    <span class="comment"># print i</span></span><br><span class="line">    <span class="comment"># 不使用imread，而是用imdecode以识别中文路径</span></span><br><span class="line">    image = cv2.imdecode(np.fromfile(i, dtype=np.uint8), cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图像像素大小一致</span></span><br><span class="line">    img = cv2.resize(image, (<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">                     interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图像直方图并存储至X数组</span></span><br><span class="line">    hist = cv2.calcHist([img], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>,</span><br><span class="line">                        [<span class="number">256</span>, <span class="number">256</span>], [<span class="number">0.0</span>, <span class="number">255.0</span>, <span class="number">0.0</span>, <span class="number">255.0</span>])</span><br><span class="line"></span><br><span class="line">    XX_test.append(((hist / <span class="number">255</span>).flatten()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 第三步 基于支持向量机的图像分类处理</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 0.5</span></span><br><span class="line"><span class="comment"># 常见核函数‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’</span></span><br><span class="line">clf = SVC().fit(XX_train, y_train)</span><br><span class="line">clf = SVC(kernel=<span class="string">&quot;linear&quot;</span>).fit(XX_train, y_train)</span><br><span class="line">predictions_labels = clf.predict(XX_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 第三步 基于决策树的图像分类处理</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 0.36</span></span><br><span class="line"><span class="comment"># from sklearn.tree import DecisionTreeClassifier</span></span><br><span class="line"><span class="comment"># clf = DecisionTreeClassifier().fit(XX_train, y_train)</span></span><br><span class="line"><span class="comment"># predictions_labels = clf.predict(XX_test)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 第三步 基于KNN的图像分类处理</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 0.11</span></span><br><span class="line"><span class="comment"># from sklearn.neighbors import KNeighborsClassifier</span></span><br><span class="line"><span class="comment"># clf = KNeighborsClassifier(n_neighbors=11).fit(XX_train, y_train)</span></span><br><span class="line"><span class="comment"># predictions_labels = clf.predict(XX_test)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 第三步 基于朴素贝叶斯的图像分类处理</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 0.01</span></span><br><span class="line"><span class="comment"># from sklearn.naive_bayes import BernoulliNB</span></span><br><span class="line"><span class="comment"># clf = BernoulliNB().fit(XX_train, y_train)</span></span><br><span class="line"><span class="comment"># predictions_labels = clf.predict(XX_test)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&#x27;预测结果:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(predictions_labels)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&#x27;算法评价:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, predictions_labels))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>验证码滑块识别</title>
    <url>/2022/12/11/%E7%88%AC%E8%99%AB-%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BB%91%E5%9D%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>滑块验证码是验证码当中的常见类型，虽然现在有很多种验证码，但是滑块验证依然应用广泛。滑块验证需要根据实际情况进行调整，最好是通过机器学习的方法解决，不然效果可能会因为验证码改变数据从而大大折扣。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.contentmanager <span class="keyword">import</span> raw_data_manager</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">format_list = [<span class="number">0</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># this.canvasCtx.drawImage(this.img,</span></span><br><span class="line"><span class="comment"># 30 * i,  开始剪切的 x 坐标位置。</span></span><br><span class="line"><span class="comment"># 0, 开始剪切的 y 坐标位置。</span></span><br><span class="line"><span class="comment"># 30, 被剪切图像的宽度。</span></span><br><span class="line"><span class="comment"># 400, 被剪切图像的高度。</span></span><br><span class="line"><span class="comment"># 30 * keylist[i] / 1.5, 	在画布上放置图像的 x 坐标位置</span></span><br><span class="line"><span class="comment"># 0,  在画布上放置图像的 y 坐标位置。</span></span><br><span class="line"><span class="comment"># offset / 1.5, 要使用的图像的宽度。（伸展或缩小图像）</span></span><br><span class="line"><span class="comment"># 200)  要使用的图像的高度。（伸展或缩小图像）</span></span><br><span class="line"><span class="comment"># from shopee.slide2 import SlideCrack2</span></span><br><span class="line"><span class="comment"># from shopee.slide_gap import SlideCrack</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_slide_img</span>(<span class="params">raw_img: <span class="built_in">bytes</span>, format_list: <span class="built_in">list</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    fp = io.BytesIO(raw_img)</span><br><span class="line">    img = Image.<span class="built_in">open</span>(fp)</span><br><span class="line">    image_dict = &#123;&#125;</span><br><span class="line">    offset = <span class="number">30</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(format_list)):</span><br><span class="line">        box = (i * offset, <span class="number">0</span>, offset + (i * offset), <span class="number">400</span>)  <span class="comment"># 左(起始),上(不变),右(宽),下(不变)</span></span><br><span class="line">        image_dict[format_list[i]] = img.crop(box)</span><br><span class="line">    image_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(image_dict):</span><br><span class="line">        image_list.append(image_dict[i])</span><br><span class="line">    image_num = <span class="built_in">len</span>(image_list)</span><br><span class="line">    image_size = image_list[<span class="number">0</span>].size</span><br><span class="line">    height = image_size[<span class="number">1</span>]</span><br><span class="line">    width = image_size[<span class="number">0</span>]</span><br><span class="line">    new_img = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (image_num * width, height), <span class="number">255</span>)</span><br><span class="line">    x = y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> image_list:</span><br><span class="line">        new_img.paste(img, (x, y))</span><br><span class="line">        x += width</span><br><span class="line">    box = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line">    new_img = new_img.crop(box)</span><br><span class="line">    <span class="comment"># 保存图片</span></span><br><span class="line">    processClickImgIoFlow = io.BytesIO()</span><br><span class="line"></span><br><span class="line">    new_img.save(processClickImgIoFlow, <span class="built_in">format</span>=<span class="string">&quot;JPEG&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(processClickImgIoFlow.getvalue())</span><br><span class="line">    <span class="keyword">return</span> processClickImgIoFlow.getvalue()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># slider 滑块</span></span><br><span class="line"><span class="comment"># gap 北京</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">discern_gap</span>(<span class="params">gapImage: <span class="built_in">bytes</span>, sliderImage: <span class="built_in">bytes</span>, show=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">edge_detection</span>(<span class="params">rawimg</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">tracebar</span>(<span class="params">x</span>):</span><br><span class="line">            threshold1 = cv.getTrackbarPos(<span class="string">&#x27;threshold1&#x27;</span>, <span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line">            threshold2 = cv.getTrackbarPos(<span class="string">&#x27;threshold2&#x27;</span>, <span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line">            edged_img = cv.Canny(img_Gaussian, threshold1, threshold2)</span><br><span class="line">            cv.imshow(<span class="string">&quot;edged_img&quot;</span>, edged_img)</span><br><span class="line"></span><br><span class="line">        image = np.asarray(<span class="built_in">bytearray</span>(rawimg), dtype=<span class="string">&quot;uint8&quot;</span>)</span><br><span class="line">        img = cv.imdecode(image, cv.IMREAD_COLOR)</span><br><span class="line">        grep_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># 高斯滤波 高斯滤波是通过对输入数组的每个点与输入的高斯滤波模板执行卷积计算然后将这些结果一块组成了滤波后的输出数组，</span></span><br><span class="line">        <span class="comment"># 通俗的讲就是高斯滤波是对整幅图像进行加权平均的过程，每一个像素点的值都由其本身和邻域内的其他像素值经过加权平均后得到。</span></span><br><span class="line">        <span class="comment"># 高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。</span></span><br><span class="line">        img_Gaussian = cv.GaussianBlur(grep_img, (<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 用于对图像的边缘检测</span></span><br><span class="line">        edged_img = cv.Canny(img_Gaussian, <span class="number">27</span>, <span class="number">27</span>)</span><br><span class="line">        <span class="keyword">if</span> show:</span><br><span class="line">            cv.namedWindow(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">            cv.imshow(<span class="string">&#x27;raw_img&#x27;</span>, img)</span><br><span class="line">            cv.imshow(<span class="string">&#x27;grep_img&#x27;</span>, grep_img)</span><br><span class="line">            cv.imshow(<span class="string">&#x27;img_Gaussian&#x27;</span>, img_Gaussian)</span><br><span class="line">            cv.createTrackbar(<span class="string">&quot;threshold1&quot;</span>, <span class="string">&quot;Test&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, tracebar)</span><br><span class="line">            cv.createTrackbar(<span class="string">&quot;threshold2&quot;</span>, <span class="string">&quot;Test&quot;</span>, <span class="number">0</span>, <span class="number">255</span>, tracebar)</span><br><span class="line">            cv.imshow(<span class="string">&#x27;edged_img&#x27;</span>, edged_img)</span><br><span class="line">            cv.waitKey()</span><br><span class="line">            cv.destroyAllWindows()</span><br><span class="line">        <span class="keyword">return</span> edged_img</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">similarity_calculation</span>(<span class="params">background, slider</span>):</span><br><span class="line">        result = cv.matchTemplate(background, slider, cv.TM_CCOEFF_NORMED)</span><br><span class="line">        <span class="comment"># 获取一个/组int类型的索引值在一个多维数组中的位置。</span></span><br><span class="line">        <span class="comment"># x, y = np.unravel_index(result.argmax(), result.shape)</span></span><br><span class="line">        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)</span><br><span class="line">        <span class="keyword">return</span> max_loc</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算滑动距离方法&quot;&quot;&quot;</span></span><br><span class="line">    gap = edge_detection(gapImage)</span><br><span class="line">    slider = edge_detection(sliderImage)</span><br><span class="line">    x, y = similarity_calculation(gap, slider)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;需要滑动距离&#x27;</span>, x, y)</span><br><span class="line">    <span class="comment"># todo 返回的距离</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">discern_gap2</span>(<span class="params">gap_path, slider_path, save=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pic2grep</span>(<span class="params">pic_path, <span class="built_in">type</span></span>) -&gt; np.ndarray:</span><br><span class="line">        pic_path_rgb = cv.imread(pic_path)</span><br><span class="line">        pic_path_gray = cv.cvtColor(pic_path_rgb, cv.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="keyword">if</span> save:</span><br><span class="line">            cv.imwrite(<span class="string">f&quot;./<span class="subst">&#123;<span class="built_in">type</span>&#125;</span>.jpg&quot;</span>, pic_path_gray)</span><br><span class="line">        <span class="keyword">return</span> pic_path_gray</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canny_edge</span>(<span class="params">image_array: np.ndarray, show=<span class="literal">False</span></span>) -&gt; np.ndarray:</span><br><span class="line">        can = cv.Canny(image_array, threshold1=<span class="number">200</span>, threshold2=<span class="number">300</span>)</span><br><span class="line">        <span class="keyword">if</span> show:</span><br><span class="line">            cv.imshow(<span class="string">&#x27;candy&#x27;</span>, can)</span><br><span class="line">            cv.waitKey()</span><br><span class="line">            cv.destroyAllWindows()</span><br><span class="line">        <span class="keyword">return</span> can</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear_white</span>(<span class="params">img: <span class="built_in">str</span>, show=<span class="literal">False</span></span>) -&gt; np.ndarray:</span><br><span class="line">        img = cv.imread(img)</span><br><span class="line">        rows, cols, channel = img.shape</span><br><span class="line">        min_x = <span class="number">255</span></span><br><span class="line">        min_y = <span class="number">255</span></span><br><span class="line">        max_x = <span class="number">0</span></span><br><span class="line">        max_y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                t = <span class="built_in">set</span>(img[x, y])</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> x &lt;= min_x:</span><br><span class="line">                        min_x = x</span><br><span class="line">                    <span class="keyword">elif</span> x &gt;= max_x:</span><br><span class="line">                        max_x = x</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> y &lt;= min_y:</span><br><span class="line">                        min_y = y</span><br><span class="line">                    <span class="keyword">elif</span> y &gt;= max_y:</span><br><span class="line">                        max_y = y</span><br><span class="line">        img1 = img[min_x:max_x, min_y:max_y]</span><br><span class="line">        <span class="keyword">if</span> show:</span><br><span class="line">            cv.imshow(<span class="string">&#x27;img1&#x27;</span>, img1)</span><br><span class="line">            cv.waitKey()</span><br><span class="line">            cv.destroyAllWindows()</span><br><span class="line">        <span class="keyword">return</span> img1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convolve2d</span>(<span class="params">bg_array: np.ndarray, fillter: np.ndarray</span>) -&gt; np.ndarray:</span><br><span class="line">        bg_h, bg_w = bg_array.shape[:<span class="number">2</span>]</span><br><span class="line">        fillter = fillter[::-<span class="number">1</span>,::-<span class="number">1</span>]</span><br><span class="line">        fillter_h, fillter_w = fillter.shape[:<span class="number">2</span>]</span><br><span class="line">        c_full = signal.convolve2d(bg_array, fillter, mode=<span class="string">&quot;full&quot;</span>)</span><br><span class="line">        kr, kc = fillter_h // <span class="number">2</span>, fillter_w // <span class="number">2</span></span><br><span class="line">        c_same = c_full[</span><br><span class="line">            fillter_h - kr - <span class="number">1</span>: bg_h + fillter_h - kr - <span class="number">1</span>,</span><br><span class="line">            fillter_w - kc - <span class="number">1</span>: bg_w + fillter_w - kc - <span class="number">1</span>,</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> c_same</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_max_point</span>(<span class="params">arrays: np.ndarray, search_on_horizontal_center=<span class="literal">False</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">        max_point = <span class="number">0</span></span><br><span class="line">        max_point_pos = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        array_rows, array_cols = arrays.shape</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> search_on_horizontal_center:</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(array_cols):</span><br><span class="line">                <span class="keyword">if</span> arrays[array_rows // <span class="number">2</span>, col] &gt; max_point:</span><br><span class="line">                    max_point = arrays[array_rows // <span class="number">2</span>, col]</span><br><span class="line">                    max_point_pos = col, array_rows // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(array_rows):</span><br><span class="line">                <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(array_cols):</span><br><span class="line">                    <span class="keyword">if</span> arrays[row, col] &gt; max_point:</span><br><span class="line">                        max_point = arrays[row, col]</span><br><span class="line">                        max_point_pos = col, row</span><br><span class="line">        <span class="keyword">return</span> max_point_pos</span><br><span class="line"></span><br><span class="line">    gap_grep = pic2grep(gap_path, <span class="string">&quot;gap&quot;</span>)</span><br><span class="line">    gap_can = canny_edge(gap_grep, <span class="literal">False</span>)</span><br><span class="line">    clear_slider = cv.imread(slider_path) <span class="comment"># clear_white(slider_path, False)</span></span><br><span class="line">    slider_can = canny_edge(clear_slider, <span class="literal">False</span>)</span><br><span class="line">    convolve2d_result = convolve2d(gap_can, slider_can)</span><br><span class="line">    result = find_max_point(convolve2d_result, <span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;img/1.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        gapImage = f.read()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;img/2.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        sliderImage = f.read()</span><br><span class="line">    <span class="comment"># raw_img = cv.imread(&#x27;img/640.png&#x27;)    </span></span><br><span class="line">    <span class="comment"># discern_gap(raw_img,format_list)</span></span><br><span class="line">    discern_gap(gapImage,sliderImage)</span><br><span class="line">    <span class="comment"># discern_gap2(&#x27;img/1.png&#x27;,&#x27;img/2.png&#x27;)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>滑块验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>生命游戏</title>
    <url>/2023/05/30/%E6%9C%89%E6%84%9F-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>有一句话叫做：”大道至简”.意味真正的道理用很简单的方式就能表达。越是复杂的理论其核心就越简单，这样的说法在算法当中尤其如此，因为很多人评价计算机就是0与1的变化，也只有加法，其余所有东西都是通过组合变化出来的。而生命游戏亦是如此！</p>
<h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>生命游戏（Game of Life）是由英国数学家约翰·康威于1970年发明的一种细胞自动机。康威在1968年开始研究细胞自动机，他的目标是设计一个简单的模型来模拟生命的演化。</p>
<p>康威最初并没有打算将这个模型命名为”生命游戏”，他只是希望通过这个模型来研究生物学中的一些基本概念，比如细胞的繁殖和死亡。</p>
<p>生命游戏的诞生可以追溯到康威在1969年参加了一个关于细胞自动机的会议。会议上，康威向与会者展示了他设计的这个模型，并用一个计算机程序演示了它的运行过程。会议上的人们对这个模型非常感兴趣，纷纷提出了各种问题和建议。</p>
<p>在接下来的几年里，康威不断改进和完善这个模型，引入了更多的规则和变化。最终，他将这个模型命名为”生命游戏”，并于1970年在科学杂志《科学美国人》（Scientific American）上发表了一篇文章，详细介绍了这个模型的规则和特点。</p>
<p>生命游戏的诞生历史可以说是一个巧合和逐步发展的过程。康威最初并没有设想到这个模型会引起如此广泛的关注和研究，但它的简单和奇特的规则使得它成为了一个独特的数学模型，被广泛应用于计算机科学、生物学和其他领域的研究中。</p>
<hr>
<h3 id="生命游戏的规则"><a href="#生命游戏的规则" class="headerlink" title="生命游戏的规则"></a>生命游戏的规则</h3><p>生命游戏是基于细胞自动机的模型，它由一系列的细胞组成，每个细胞可以处于生存或死亡的状态。生命游戏的规则如下：</p>
<ol>
<li><p>每个细胞的状态只能是生存（活细胞）或死亡（死细胞）两种状态之一。</p>
</li>
<li><p>每个细胞都有八个邻居细胞，它们是其周围的八个相邻位置的细胞。</p>
</li>
<li><p>根据当前的状态和周围细胞的状态，细胞的下一个状态由以下规则确定：</p>
<ul>
<li>如果一个细胞周围有少于两个活细胞，它将在下一代死亡，模拟死亡细胞因孤立而死亡的情况。</li>
<li>如果一个细胞周围有两个或三个活细胞，它将在下一代保持生存。</li>
<li>如果一个细胞周围有超过三个活细胞，它将在下一代死亡，模拟生活细胞因过度拥挤而死亡的情况。</li>
<li>如果一个死细胞周围有正好三个活细胞，它将在下一代复活，模拟死细胞因周围有足够的活细胞而复活的情况。</li>
</ul>
</li>
<li><p>所有细胞同时按照上述规则进行更新，即每一代的细胞状态都是根据上一代的状态计算得出的。</p>
</li>
</ol>
<p>通过这些简单的规则，生命游戏展示了细胞在不同的状态和环境下的演化过程。尽管规则非常简单，但生命游戏可以产生出非常复杂和有趣的模式，包括静态的结构、振荡的周期和移动的斑点等。这使得生命游戏成为了一个受到广泛研究和探索的数学模型。</p>
<h3 id="生命游戏能做什么"><a href="#生命游戏能做什么" class="headerlink" title="生命游戏能做什么"></a>生命游戏能做什么</h3><p>生命游戏可以生成各种各样的模式和结构，包括静态的结构、振荡的周期和移动的斑点等。以下是一些生命游戏可能产生的有趣的现象和图案：</p>
<ol>
<li><p>静态结构：生命游戏可以生成一些稳定的结构，这些结构在每一代中都保持不变。例如，可以形成简单的方块、长条、稳定的交替模式等。</p>
</li>
<li><p>振荡周期：生命游戏可以产生周期性的振荡模式，这些模式在一系列的代际中重复出现。例如，可以形成来回振荡的斑点、周期性的闪烁等。</p>
</li>
<li><p>移动斑点：生命游戏中的模式可以通过相互作用而移动，形成移动的斑点或者简单的行走器。这些斑点可以在游戏区域中自由移动，产生有趣的效果。</p>
</li>
<li><p>复杂的演化：生命游戏的规则简单，但是在一些情况下，它可以产生非常复杂和有机的演化过程。通过适当的初始条件和模式的布局，可以观察到一些复杂的演化现象，如模式的扩散、碰撞和相互作用等。</p>
</li>
</ol>
<p>生命游戏不仅仅是一种娱乐性的模型，它还可以应用于计算机科学、生物学和其他领域的研究中。生命游戏的规则和现象可以帮助人们理解和研究复杂系统的演化和行为，以及模拟和研究生物生存和繁殖的过程。此外，生命游戏也被用于图像处理、数据压缩和密码学等领域的应用中。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li><p>复杂性和简单性的关系：尽管生命游戏的规则非常简单，但是它可以产生出非常复杂和有机的演化过程。这启发我们思考复杂系统是如何由简单规则和简单元素组成的，以及简单规则如何产生出复杂的行为和结构。</p>
</li>
<li><p>自组织和自适应性：生命游戏中的细胞自动地根据周围的状态来更新自己的状态，从而产生出各种模式和结构。这引发我们思考自组织和自适应性在自然界中的普遍存在和重要性，以及如何将这些原理应用于设计和优化复杂系统。</p>
</li>
<li><p>生命和进化的模拟：生命游戏可以模拟生物的生存和繁殖过程，使我们能够观察到不同种类的演化现象。这鼓励我们思考生命的起源、进化和适应能力，以及如何将这些原理应用于生物学和进化算法等领域的研究中。</p>
</li>
<li><p>系统动力学和演化理论：生命游戏的演化过程可以帮助我们理解系统动力学和演化理论中的一些基本原理，如正反馈、负反馈、平衡态、非线性行为等。这有助于我们深入理解和研究复杂系统的行为和演化机制。</p>
</li>
<li><p>数学建模和计算机模拟：生命游戏是一种基于数学建模和计算机模拟的方法，它可以帮助我们理解和解决实际问题。这激发我们思考如何使用数学和计算机模拟来研究和解决其他复杂系统和现象。</p>
</li>
</ul>
<h2 id="体验网站"><a href="#体验网站" class="headerlink" title="体验网站"></a>体验网站</h2><p><a href="https://copy.sh/life/">https://copy.sh/life/</a></p>
<p><a href="https://playgameoflife.com/">https://playgameoflife.com/</a></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之简单线性回归</title>
    <url>/2022/11/15/%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h2 id="方程"><a href="#方程" class="headerlink" title="方程"></a>方程</h2><p><code>y = b₀ + b₁*X₁</code></p>
<p>简单线性回归其实就是一个一元一次方程，在图像上呈现一个线性关系。</p>
<p><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E5%9B%BE%E5%83%8F.png" alt="图像"> </p>
<p>如何拟合这样一条线？</p>
<p>拟合的原理其实很简单，就是找到一条线，使得所有的点离这条线的距离之和是所有可能中最小的情况。当这条线满足这个要求的时候，这条线就是我们方程拟合的目标结果。<br>我们将用这样的结果去预测与之类似的数据，查看预测效果。</p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><table>
<thead>
<tr>
<th>YearsExperience</th>
<th>Salary</th>
</tr>
</thead>
<tbody><tr>
<td>1.1</td>
<td>39343.00</td>
</tr>
<tr>
<td>1.3</td>
<td>46205.00</td>
</tr>
<tr>
<td>1.5</td>
<td>37731.00</td>
</tr>
<tr>
<td>2.0</td>
<td>43525.00</td>
</tr>
<tr>
<td>2.2</td>
<td>39891.00</td>
</tr>
<tr>
<td>2.9</td>
<td>56642.00</td>
</tr>
<tr>
<td>3.0</td>
<td>60150.00</td>
</tr>
<tr>
<td>3.2</td>
<td>54445.00</td>
</tr>
<tr>
<td>3.2</td>
<td>64445.00</td>
</tr>
<tr>
<td>3.7</td>
<td>57189.00</td>
</tr>
<tr>
<td>3.9</td>
<td>63218.00</td>
</tr>
<tr>
<td>4.0</td>
<td>55794.00</td>
</tr>
<tr>
<td>4.0</td>
<td>56957.00</td>
</tr>
<tr>
<td>4.1</td>
<td>57081.00</td>
</tr>
<tr>
<td>4.5</td>
<td>61111.00</td>
</tr>
<tr>
<td>4.9</td>
<td>67938.00</td>
</tr>
<tr>
<td>5.1</td>
<td>66029.00</td>
</tr>
<tr>
<td>5.3</td>
<td>83088.00</td>
</tr>
<tr>
<td>5.9</td>
<td>81363.00</td>
</tr>
<tr>
<td>6.0</td>
<td>93940.00</td>
</tr>
<tr>
<td>6.8</td>
<td>91738.00</td>
</tr>
<tr>
<td>7.1</td>
<td>98273.00</td>
</tr>
<tr>
<td>7.9</td>
<td>101302.00</td>
</tr>
<tr>
<td>8.2</td>
<td>113812.00</td>
</tr>
<tr>
<td>8.7</td>
<td>109431.00</td>
</tr>
<tr>
<td>9.0</td>
<td>105582.00</td>
</tr>
<tr>
<td>9.5</td>
<td>116969.00</td>
</tr>
<tr>
<td>9.6</td>
<td>112635.00</td>
</tr>
<tr>
<td>10.3</td>
<td>122391.00</td>
</tr>
<tr>
<td>10.5</td>
<td>121872.00</td>
</tr>
</tbody></table>
<p>数据读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"></span><br><span class="line">dataset = pd.read_csv(<span class="string">&quot;Salary_Data.csv&quot;</span>)</span><br><span class="line">X = dataset.iloc[:,:<span class="number">1</span>].values</span><br><span class="line">Y = dataset.iloc[:,-<span class="number">1</span>].values</span><br></pre></td></tr></table></figure>

<p>划分测试集与训练集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size = <span class="number">0.2</span>,random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="关于特征缩放"><a href="#关于特征缩放" class="headerlink" title="关于特征缩放"></a>关于特征缩放</h2><p>在简单线性回归的函数中已经包含了特缩放的操作，我们不再需要再对其做出特征缩放了</p>
<h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">regressor = LinearRegression()</span><br><span class="line">regressor.fit(X_train,Y_train)</span><br></pre></td></tr></table></figure>

<p>测试预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_pred = regressor.predict(X_test)</span><br></pre></td></tr></table></figure>

<h2 id="图像展示"><a href="#图像展示" class="headerlink" title="图像展示"></a>图像展示</h2><p>预测结果展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(X_train,Y_train,color = <span class="string">&quot;red&quot;</span>)</span><br><span class="line">plt.plot(X_train,regressor.predict(X_train),color = <span class="string">&quot;blue&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Salary VS Experience (training set)&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Years of Experience&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Salary&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C.png" alt="预测结果"></p>
<p>测试结果展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(X_test,Y_test,color = <span class="string">&quot;red&quot;</span>)</span><br><span class="line">plt.plot(X_train,regressor.predict(X_train),color = <span class="string">&quot;blue&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Salary VS Experience (training set)&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Years of Experience&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Salary&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="测试结果"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>简单线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>送东阳马生序</title>
    <url>/2022/11/26/%E6%9C%89%E6%84%9F-%E9%80%81%E4%B8%9C%E9%98%B3%E9%A9%AC%E7%94%9F%E5%BA%8F/</url>
    <content><![CDATA[<p>余幼时即嗜学。家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。录毕，走送之，不敢稍逾约。以是人多以书假余，余因得遍观群书。既加冠，益慕圣贤之道 ，又患无硕师、名人与游，尝趋百里外，从乡之先达执经叩问。先达德隆望尊，门人弟子填其室，未尝稍降辞色。余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。</p>
<p>当余之从师也，负箧曳屣行深山巨谷中，穷冬烈风，大雪深数尺，足肤皲裂而不知。至舍，四支僵劲不能动，媵人持汤沃灌，以衾拥覆，久而乃和。寓逆旅，主人日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则缊袍敝衣处其间，略无慕艳意。以中有足乐者，不知口体之奉不若人也。盖余之勤且艰若此。今虽耄老，未有所成，犹幸预君子之列，而承天子之宠光，缀公卿之后，日侍坐备顾问，四海亦谬称其氏名，况才之过于余者乎？</p>
<p>今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！</p>
<p>东阳马生君则，在太学已二年，流辈甚称其贤。余朝京师，生以乡人子谒余，撰长书以为贽，辞甚畅达，与之论辨，言和而色夷。自谓少时用心于学甚劳，是可谓善学者矣！其将归见其亲也，余故道为学之难以告之。谓余勉乡人以学者，余之志也；诋我夸际遇之盛而骄乡人者，岂知予者哉？</p>
<hr>
<p>以前在学校的时候受因为这是语文课文，没能主动的去理解文章表达的含义，不能够理解求学之路为何会艰辛，也不能够理解为什么要这样贬低自己求学。随着自己离开学校，逐渐步入社会，慢慢的去感悟学习的过程之后再回过来这篇文章，不仅感慨，求学之路莫若于此！同时也能够理解为啥作者会写出： <strong>以中有足乐者，不知口体之奉不若人也</strong> 。确实，学有所得的快乐有时候真的难以用具象化的东西代替或描述！</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>霍夫线变换</title>
    <url>/2022/08/23/%E7%AE%97%E6%B3%95-%E9%9C%8D%E5%A4%AB%E7%BA%BF%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>霍夫线变化适用于在检测某一张图像中线段的位置，在实际使用过程当中可用于对图像线段特征进行查找过滤。个人能够想到的实际用途可能是用于作业检测，检测在横线上填写的答案。霍夫变换是图像分析，机器视觉，数字图像处理中常用的处理方法。这种方法能从图像中分离出一些特定的形状的图形。经典的霍夫变换研究的是如何在图像中分离出直线，随着研究的深入，霍夫变换可以分离出图像中的圆，椭圆，甚至是任意形状。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>首先需要明白一个基础知识，就是在笛卡尔坐标系当中，一条线段的表示方法是：<code>y = kx + q</code>，其中<code>q</code>是常量。但是在霍夫空间中，一条线段是以<strong>一个点</strong>来表示的。反之，霍夫空间中的线代表笛卡尔坐标系当中的点。即：</p>
<ul>
<li>霍夫空间点 == 笛卡尔坐标系线</li>
<li>笛卡尔坐标系点 == 霍夫空间线</li>
</ul>
<p>这很重要！！！当我们需要找到图像中的一条线段的时候，需要确定被处理后的图像的多个点是否交于同一线。如果多个点在笛卡尔坐标系当中是同一线，反之在霍夫空间当中多条线会交于同一点上。由此实现点与线的对应关系。</p>
<p>在霍夫空间当中，只需要统计相交于同一点的线最多的点，就能找到图像中越接近线的部分。接下来看看具体转化过程。</p>
<h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p>首先确认笛卡尔坐标系当中想要确定一条线需要确定两个值,即方程式<code>y = kx + q</code>当中的<code>k</code>与<code>q</code>,确认了这两个值之后就能确认一条线的位置。于是乎，在霍夫空间中就以<code>(k,q)</code>的点来表示一条线段，由此实现了笛卡尔坐标系到霍夫空间的转化。</p>
<p>反之如果知道笛卡尔坐标系当中的一个点，如<code>(4,5)</code>，怎么推导霍夫空间的函数呢？此时只需要带入方程式：<code>y = kx + q</code>,即可得出<code>q = 5-4x</code>。</p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>在特殊的情况下，如果出现由<code>(1,2)、(1,2)、(1,3)、(1,4)</code>这四个点组成的直线，直线垂直于坐标轴x轴。原来的方程<code>y = kx + q</code>已经不能够适用在这样的情况之下了，该怎么办呢？</p>
<p>这时候就需要祭出我们的极坐标系了！在极坐标系当中，一条线的方程式是<code>ρ = xcosθ + ysinθ</code>。其中<code>ρ</code>代表线上一点到原点的距离，<code>θ</code>代表线上一点于原点的连线和x轴的夹角，因此同理可以得出极坐标系于霍夫空间的对应关系，以极坐标系上的点为例。以<code>(1,0)</code>为例，带入方程：<code>ρ = xcosθ + ysinθ</code>可得<code>ρ = cosθ</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>笛卡尔坐标系通过与霍夫空间进行转化，能够将两者的点与线进行映射从而找到图像中的线，因此只要使用适当的线的函数通过映射关系理论上可以找出任意的线甚至多边形。而在opnecv当中，已经通过python代码写好工具提供给我们使用了，代码案例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">&#x27;sudoku.png&#x27;</span>))</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize = <span class="number">3</span>)</span><br><span class="line">lines = cv.HoughLines(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho,theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a*rho</span><br><span class="line">    y0 = b*rho</span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span>*(-b))</span><br><span class="line">    y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span>*(a))</span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span>*(-b))</span><br><span class="line">    y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span>*(a))</span><br><span class="line">    cv.line(img,(x1,y1),(x2,y2),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">cv.imwrite(<span class="string">&#x27;houghlines3.jpg&#x27;</span>,img)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么会是443端口</title>
    <url>/2024/12/01/%E7%BD%91%E7%BB%9C-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%98%AF443%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用Nginx进行HTTPS服务配置时，我遇到一个问题：只有443端口可以访问HTTPS服务。我很好奇为什么会是443端口。</p>
<h2 id="443端口的历史原因"><a href="#443端口的历史原因" class="headerlink" title="443端口的历史原因"></a>443端口的历史原因</h2><p>443端口是HTTP Secure（HTTPS）服务的默认端口，这个数字并非随意选择。在互联网的早期，端口号被分配给特定的服务，而443端口被指定为SSL（Secure Sockets Layer）服务的端口，这是HTTPS的前身。随着时间的推移，SSL被TLS（Transport Layer Security）取代，但443端口作为安全通信端口的传统得以保留。</p>
<h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>SSL/TLS协议是用于在互联网上提供安全通信的加密协议。它通过加密数据、验证身份和确保数据完整性来保护通信的安全。在HTTPS中，SSL/TLS协议用于加密客户端和服务器之间的数据传输，确保数据在传输过程中不被窃听或篡改。SSL是Secure Sockets Layer的缩写，TLS是Transport Layer Security的缩写，SSL中文含义是“安全套接字层”。TLS是the Transport Layer Security的缩写，中文含义是“传输层安全协议”。SSL被TLS取代的原因是TLS在SSL的基础上进行了改进和增强，提供了更好的安全性和性能。</p>
<h2 id="443端口的技术原因"><a href="#443端口的技术原因" class="headerlink" title="443端口的技术原因"></a>443端口的技术原因</h2><p>在技术层面，443端口的广泛使用有几个原因：</p>
<ol>
<li><strong>默认配置</strong>：大多数服务器和客户端软件默认使用443端口进行HTTPS通信，这使得配置和使用变得简单快捷。</li>
<li><strong>安全性</strong>：443端口与SSL/TLS协议紧密关联，这些协议提供了数据加密、完整性校验和身份验证，增强了通信的安全性。</li>
<li><strong>兼容性</strong>：由于443端口的广泛使用，几乎所有的网络设备和中间件都支持通过该端口的HTTPS流量，确保了广泛的兼容性。</li>
</ol>
<h2 id="Nginx配置与端口转发"><a href="#Nginx配置与端口转发" class="headerlink" title="Nginx配置与端口转发"></a>Nginx配置与端口转发</h2><p>在使用Nginx进行端口转发时，我们可能会遇到只有443端口可以访问的问题。这通常是由于以下几个原因：</p>
<ol>
<li><strong>配置错误</strong>：Nginx配置文件中可能存在错误，导致非443端口的HTTPS服务无法正确转发。例如，SSL证书可能只配置在443端口，而其他端口没有正确配置。</li>
<li><strong>防火墙限制</strong>：服务器或网络的防火墙可能只允许443端口的流量通过，而阻止了其他端口的HTTPS流量。</li>
<li><strong>浏览器行为</strong>：大多数浏览器默认只接受443端口的HTTPS连接，对于非标准端口的HTTPS连接可能会发出警告或拒绝连接。</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>要解决只有443端口可以访问HTTPS服务的问题，可以采取以下措施：</p>
<ol>
<li><strong>检查Nginx配置</strong>：确保Nginx配置文件中所有需要的端口都正确配置了SSL证书和监听指令。</li>
<li><strong>调整防火墙规则</strong>：检查并调整服务器和网络的防火墙规则，允许除443端口外的其他端口的HTTPS流量。</li>
<li><strong>浏览器设置</strong>：对于开发和测试目的，可以在浏览器中设置以接受非标准端口的HTTPS连接。</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>443端口作为HTTPS服务的默认端口，有着深厚的历史和技术背景。在使用Nginx进行HTTPS服务配置时，确保正确配置Nginx和防火墙规则，以允许非443端口的HTTPS流量，可以避免只有443端口可以访问的问题。通过这些措施，可以确保HTTPS服务的灵活性和安全性。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>127.0.0.1与localhost的区别</title>
    <url>/2022/05/31/%E7%BD%91%E7%BB%9C-127-0-0-1%E4%B8%8Elocalhost%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h2><ul>
<li>地址而非域名</li>
<li>127.0.0.1在Windows等系统的正确解释是：本机地址（本机服务器或回送地址）  </li>
<li>127.0.0.1是一个环回地址，根本不是一个网络地址  </li>
<li>127.0.0.1是通过网卡传输的，依赖网卡，并受到网络防火墙和网卡相关的限制</li>
<li>检测本机的回路是否正常，如果得到一个成功的ping返回，则可以认定你的IP栈是被初始化过的，TCP/IP协议安装正确。如果失败，那么你的IP栈失败，TCP/IP协议必须重新安装</li>
<li>不联网、网卡传输，受防火墙和网卡的限制、本机访问    </li>
</ul>
<h2 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h2><ul>
<li>域名而非地址</li>
<li>localhost也叫local ，正确的解释是：本地服务器</li>
<li>localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 ipv6 后，它同时还指向ipv6 的地址 [::1] </li>
<li>在计算机网络中，localhost是回路网络接口的一个标准主机名，相对应的ip地址是127.0.0.1</li>
<li>localhost是一个保留域名，同时也是一个特殊的DNS主机名，代表分配给引用这个名称的计算机的ip地址，即所在计算机本身</li>
<li>localhost是不经过网卡传输的，它不受网络防火墙和网卡相关的限制</li>
<li>windows系统，在host文件中，localhost指向的ip是127.0.0.1,可通过编辑host文件改变指向</li>
<li>不联网、不使用网卡，不受防火墙和网卡的限制、本机访问</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>loclhost是作为域名被解析的，因此两者虽然有类似的效果但是并不相同，一般设置程序时本地服务用localhost是最好的，localhost不会解析成IP，也不会占用网卡、网络资源。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>何为ssh?</title>
    <url>/2022/09/03/%E7%BD%91%E7%BB%9C-%E4%BD%95%E4%B8%BAssh/</url>
    <content><![CDATA[<p>在初学Linux的时候或者第一次使用git的时候一定会出现一种协议叫做ssh,并且不可避免的需要配置ssh协议，但是使用了很久都没有去关注ssh到底是什么？</p>
<h2 id="ssh协议（Secure-Shell）"><a href="#ssh协议（Secure-Shell）" class="headerlink" title="ssh协议（Secure Shell）"></a>ssh协议（Secure Shell）</h2><p>ssh中文名为安全外壳,是一种网络安全<strong>协议</strong>，通过加密和认证机制实现安全的访问和文件传输等业务。SSH协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的登录和其他安全网络服务。作为Telnet和其他不安全远程shell协议的安全替代方案。</p>
<p>SSH服务由服务端软件OpenSSH和连接客户端组成（SSH、SecureCRT,xshell等），默认端口是22。SSH是一个守护进程，负责实时监听客户端请求，并进行处理。</p>
<p>ssh是一种应用层协议，它的传输层协议是tcp。</p>
<h2 id="ssh连接流程"><a href="#ssh连接流程" class="headerlink" title="ssh连接流程"></a>ssh连接流程</h2><p>ssh协议建立连接的过程为：</p>
<ul>
<li>tcp三次握手  </li>
<li>ssh协议版本协商  </li>
<li>服务器端把公钥发给客户端  </li>
<li>加密算法协商  </li>
<li>客户端使用公钥对服务器端的密码加密并发送给服务器端  </li>
<li>服务器端收到后用自己的私钥解密后得到用户名密码和本地密码对比，验证成功允许登录，否则需要客户端再次输入密码验证</li>
</ul>
<p>这里出现了两次协商，第一次见到协商的时候可能不理解怎么协商，会以为是什么专业名词，但是其实协商的意思。</p>
<h3 id="版本协商"><a href="#版本协商" class="headerlink" title="版本协商"></a>版本协商</h3><p>SSH目前包括 SSH1和SSH2两个版本， 双方通过版本协商确定使用的版本。建立连接后，服务端向客户端发送报文<code>（版本标志字符串：SSH－&lt;主协议版本号&gt;.&lt;次协议版本号&gt;－&lt;软件版本号&gt;&gt;）</code>客户端收到报文后，解析数据包，如果服务端的协议版本号比自己的低，且客户端能支持服务端的低版本，就采用服务器端的低版本协议号，否则采用客户端自己的协议版本号。</p>
<p>客户端回应服务器一个报文，包含客户端决定使用的协议版本号。服务端会比较客户端发来的版本号，决定是否能同客户端进行正常工作。</p>
<p>协商成功，就会进入密钥和算法协商阶段，否则服务端断开TCP连接。</p>
<h3 id="算法协商"><a href="#算法协商" class="headerlink" title="算法协商"></a>算法协商</h3><p>SSH支持多种加密算法， 在服务端和客户端分别发送算法协商报文给对方后，报文中包含自己支持的公钥算法列表、加密算法列表、MAC（Message Authentication Code，消息验证码）算法列表、压缩算法列表等协商信息。</p>
<p>服务端和客户端根据对方和自己支持的算法列表确定最终使用的算法。</p>
<h2 id="SSH的认证方式"><a href="#SSH的认证方式" class="headerlink" title="SSH的认证方式"></a>SSH的认证方式</h2><p>password认证</p>
<p>客户端向服务端发出 password认证请求，然后将用户名和密码加密后发送给服务器；服务器将该信息解密后得到用户名和密码的明文，与自己设备上保存的用户名和密码进行比较，并返回认证成功或失败的消息。</p>
<hr>
<p>publickey 认证  </p>
<p>采用数字签名的方法来认证客户端。目前，设备上可以利用RSA和 DSA两种公共密钥算法实现数字签名。</p>
<p>客户端发送包含用户名、公共密钥和公共密钥算法的 publickey 认证请求给服务端。服务器、端对公钥进行合法性检查，如果不合法，则直接发送失败消息；否则，服务器利用数字签名对客户端进行认证，并返回认证成功或失败的消息。</p>
<hr>
<p>password-publickey 认证(SSH2.0)  </p>
<p>指定该用户的认证方式为 password 和 publickey认证必须同时满足。</p>
<blockquote>
<p>说明：客户端版本为 SSH1的用户只要通过其中一种认证即可登录；客户端版本为 SSH2的用户必须两种认证都通过才能登录。</p>
</blockquote>
<hr>
<p>any认证(SSH2.0)  </p>
<p>指定该用户的认证方式可以是 password、 publickey中任意一种。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>经典七层网络模型</title>
    <url>/2022/08/21/%E7%BD%91%E7%BB%9C-%E7%BB%8F%E5%85%B8%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>以前： 为什么我用不到面试还要问？<br>现在： 为什么我会用到这东西啊？</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>七层网络模型是每一个程序员在基础学习的时候都需要面对的一个知识点，与其相关的还有五层模型与四层模型，其实都是一个东西在不同场景使用和描述的不同，本质上差不多。</p>
<p>七层模型全称是OSI七层模型，其中OSI叫做国际标准化组织，这个组织专门为全球制定一些标准。</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>依照顺序从上往下分别是：</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p>建立七层模型的主要目的是为解决各种网络互联时遇到的兼容性问题。其最大的优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议则是如何实现本层的服务。如此各层之间就具有很强的独立性，互联网络中各实体采用什么样的协议是没有限制的，只要向上提供服务并且不改变相临层的接口就可以了。网络七层的划分也是为了使用网络的不同功能模块分担起不同的职责，也就带来如下好处：</p>
<ul>
<li>减轻问题的复杂程度，一旦发生网络故障，可迅速定位故障所处层次</li>
<li>在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作。各层之间相对独立，一种高层次协议可放在多种低层次协议上运行。</li>
<li>能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需要更改整个系统</li>
</ul>
<p>七层模型每一层都有属于自己层的特殊协议，担任着该层的数据传输功能，数据在物理介质当中传输的时候，协议解析是从下往上解析，然后再从上往下封装。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>是最靠近应用程序的OSI层。由用户使用相应的接口实现自己的服务。</p>
<p>协议有：HTTP FTP SMTP等</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息被另一个系统的应用层读取。格式有: JPEG、ASCII、加密格式等。</p>
<p>在表示层，数据按照网络能理解的方案进行格式化。管理数据的加密与解密。</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的会话。负责在网络的两节点之间建立、维持和终止通信。</p>
<p>会话层的功能包括：建立通信链接，保持会话过程通信连接的畅通，同步两个节点之间的对话，决定通信是否被终端以及通信中断时从何处重新发送。</p>
<p>有人会把会话层称为网络通信得到“交通警察”。当通过拨号向你的ISP（因特网服务提供商）请求连接到因特网时，ISP服务器上的会话层向你与你的PC客户机上的会话层进行协商连接。若你的电话线偶然脱落时，会话层将会检测到连接中断并重新发起连接。会话层通过决定节点通信的优先级和通信时间的长短来设置通信期限。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>定义传输数据的协议端口号，以及流控和差错校验。</p>
<p>协议有：TCP UDP等，数据包一旦离开网卡即进入网络传输层。定义了一些传输数据的协议和端口号，如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，用于传输可靠性要求不高，数据量小的数据）。主要是讲从下层接收的数据进行分段和传输，到达目的地后再进行重组。常常把这一层数据叫做段。</p>
<p>OSI模型中最终要的一层。传输协议同时进行浏览控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1500字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一个序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程称作排序。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>进行逻辑地址寻址，实现不同网络之间的路径选择等。协议有：ICMP IGMP IP ARP RARP等。</p>
<p>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户量大大增加，网络层正式管理这种连接的层。</p>
<p>OSI模型的第三层，其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。</p>
<p>网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络节点B的最佳路径。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，”路由“是基于编址方案、使用模式以及可达性来指导数据的发送。</p>
<p>网络层用于本地LAN网段之上的计算机系统建立通信，它之所以可以这样做，是因为它有自已的路由地址结构，这种结构与第二层机器地址是分开的、独立的。这种协议称为路由或可路由协议。路由协议包括IP、Novell公司的IPX以及AppleTalk协议。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p>
<p>主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及检错和控制信息。其中的地址确定了帧将发往何处，而纠错和控制信息则确保帧无差错到达。如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。</p>
<p>数据链路层在物理层提供比特流服务的基础上，建立相邻节点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行各电路上的动作系列。作用主要是物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>建立、维护、断开物理连接。</p>
<p>主要定义物理设备标准，如网线的接口类型，光纤的接口类型，各种传输介质的传输速率等。主要作用是传输比特流（就是有1、0转化为电力强弱来进行传输，到达目的地后在转化为1、0）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深入理解网模型有利于在逆向方向深入理解。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>流式返回</title>
    <url>/2024/12/01/%E7%BD%91%E7%BB%9C-%E6%B5%81%E5%BC%8F%E8%BF%94%E5%9B%9E/</url>
    <content><![CDATA[<h2 id="什么是web流式返回"><a href="#什么是web流式返回" class="headerlink" title="什么是web流式返回"></a>什么是web流式返回</h2><p>流式返回，顾名思义，就是将返回的数据流式返回给客户端，而不是等待所有数据都准备好再返回给客户端。这样做的优点是，客户端可以在数据传输的过程中就开始处理数据，而不需要等待所有数据都传输完成。</p>
<h2 id="如何实现web流式返回"><a href="#如何实现web流式返回" class="headerlink" title="如何实现web流式返回"></a>如何实现web流式返回</h2><p>实现web流式返回的方式有很多种，下面介绍几种常见的方式：</p>
<h3 id="使用HTTP-2协议"><a href="#使用HTTP-2协议" class="headerlink" title="使用HTTP/2协议"></a>使用HTTP/2协议</h3><p>HTTP/2协议支持多路复用，可以同时传输多个请求和响应，从而实现流式返回。使用HTTP/2协议可以实现更高效的流式返回。</p>
<h3 id="使用WebSocket协议"><a href="#使用WebSocket协议" class="headerlink" title="使用WebSocket协议"></a>使用WebSocket协议</h3><p>WebSocket协议可以实现全双工通信，可以实时地将数据从服务器推送到客户端。使用WebSocket协议可以实现实时的流式返回。以python websocket为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">websocket, path</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:</span><br><span class="line">        <span class="keyword">await</span> websocket.send(message)</span><br><span class="line"></span><br><span class="line">start_server = websockets.serve(echo, <span class="string">&quot;localhost&quot;</span>, <span class="number">8765</span>)</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(start_server)</span><br><span class="line">asyncio.get_event_loop().run_forever()</span><br></pre></td></tr></table></figure>

<h3 id="使用Server-Sent-Events（SSE）"><a href="#使用Server-Sent-Events（SSE）" class="headerlink" title="使用Server-Sent Events（SSE）"></a>使用Server-Sent Events（SSE）</h3><p>SSE是一种基于HTTP的协议，可以实现服务器向客户端推送数据。使用SSE可以实现流式返回。用python举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sse_starlette.sse <span class="keyword">import</span> EventSourceResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stream_data</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;i&#125;</span>\n\n&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;event: end\ndata: end\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/stream&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stream</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> EventSourceResponse(stream_data())</span><br></pre></td></tr></table></figure>

<h3 id="使用流式框架"><a href="#使用流式框架" class="headerlink" title="使用流式框架"></a>使用流式框架</h3><p>一些流式框架，如Spring WebFlux，可以实现流式返回。这些框架提供了流式返回的支持，可以方便地实现流式返回。在fastapi当中也提供流式返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> StreamingResponse</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/stream&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stream</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">event_stream</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;i&#125;</span>\n\n&quot;</span></span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(event_stream())</span><br></pre></td></tr></table></figure>

<h2 id="web流式返回的应用场景"><a href="#web流式返回的应用场景" class="headerlink" title="web流式返回的应用场景"></a>web流式返回的应用场景</h2><p>web流式返回的应用场景非常广泛，以下是一些常见的应用场景：</p>
<ol>
<li>实时数据推送：如股票行情、新闻推送等，需要实时地将数据推送给客户端。</li>
<li>文件下载：如视频、音频、大文件下载等，需要将文件流式返回给客户端。</li>
<li>游戏开发：如多人在线游戏，需要实时地将游戏数据推送给客户端。</li>
<li>实时聊天：如在线聊天、实时消息推送等，需要实时地将消息推送给客户端。常见的如大模型对话等。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>web流式返回是一种高效的数据传输方式，可以实现实时、高效的数据传输。在实际应用中，可以根据具体的需求选择合适的方式来实现web流式返回。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>详解post与get</title>
    <url>/2022/04/23/%E7%BD%91%E7%BB%9C-%E8%AF%A6%E8%A7%A3post%E4%B8%8Eget/</url>
    <content><![CDATA[<h2 id="POST和GET"><a href="#POST和GET" class="headerlink" title="POST和GET"></a>POST和GET</h2><p>网络请求有OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT这常见的几种方式，其中最常见也就是post与get方法，在开发过程当中常常会遇到一个问题，这个接口到底是使用post请求好一点还是使用get请求好一点？两者到底有什么区别？这篇文章就将给出对应的解释。</p>
<h2 id="对post与get区别的错误理解"><a href="#对post与get区别的错误理解" class="headerlink" title="对post与get区别的错误理解"></a>对post与get区别的错误理解</h2><h3 id="get安全性非常低，post安全性较高"><a href="#get安全性非常低，post安全性较高" class="headerlink" title="get安全性非常低，post安全性较高"></a>get安全性非常低，post安全性较高</h3><p>一般来说，在对新手上手的时候会跟他说这样的话，并说get是能够明文看见的，但是post不行…这个说法是有一定道理的，对于完全不知道情况的普通用户来说，安全一点确实有道理，因为从浏览器的地址上确实看不到post请求的参数，url链接也变短了，但是不代表数据被完全隐藏，实际上通过简单的开发者工具抓包就能够看到明文数据。因此某些极小的点上可以说安全，但是实际上可能并不安全。 </p>
<h3 id="get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。"><a href="#get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。" class="headerlink" title="get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。"></a>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。</h3><p>这个说法其实是指当我们使用get请求的时候，参数会直接被显示在url当中如：<code>https://www.duitang.com/blog/?id=1121578266</code>。这里的参数id尚且为int，如果为中文需要url编码，以至于链接会非常的长，这个长度是有限制的，这个限制却不是get方法的限制，之所以限制是浏览器跟服务器的限制，两者为了防止链接太长导致解析压力过大影响用户体验，所以才加以限制。相对的post确实不用在意大小，因为参数传输方式不同导致解析压力并不大。</p>
<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><h3 id="get获取数据，post提交数据。"><a href="#get获取数据，post提交数据。" class="headerlink" title="get获取数据，post提交数据。"></a>get获取数据，post提交数据。</h3><p>这是从语义上进行的理解，即get与post的中文翻译，其实HTTP的八种方法都能够携带参数，服务器拿到参数之后想做什么完全由服务器决定而非由请求方法决定，但是在设计之初就给出建议让get承担获取数据，让post承担提交数据的功能。</p>
<p>注：HTTP请求，最初设定了八种方法。这八种方法本质上没有任何区别。只是让请求，更加有语义而已。</p>
<ul>
<li><strong>OPTIONS</strong> 返回服务器所支持的请求方法</li>
<li><strong>GET</strong> 向服务器获取指定资源</li>
<li><strong>HEAD</strong> 与GET一致，只不过响应体不返回，只返回响应头</li>
<li><strong>POST</strong> 向服务器提交数据，数据放在请求体里</li>
<li><strong>PUT</strong> 与POST相似，只是具有幂等特性，一般用于更新</li>
<li><strong>DELETE</strong> 删除服务器指定资源</li>
<li><strong>TRACE</strong> 回显服务器端收到的请求，测试的时候会用到这个</li>
<li><strong>CONNECT</strong> 预留，暂无使用</li>
</ul>
<h3 id="数据传输编码不同"><a href="#数据传输编码不同" class="headerlink" title="数据传输编码不同"></a>数据传输编码不同</h3><p>Get限制Form表单的数据集的值必须为ASCII字符，因此当出现不属于ASCII编码的字符在get请求当中的时候，必须对链接进行编码，常见的如果链接当中出现空格，链接上会把空格编码成%20，不信可以粘贴以下链接到浏览器，看看链接发生的变化： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.baidu.com/s?wd=hello world</span><br><span class="line"><span class="comment"># 以下是浏览器编码后的结果</span></span><br><span class="line">https://www.baidu.com/s?wd=hello%20world</span><br></pre></td></tr></table></figure>

<p>Post相比get支持整个ISO10646字符集,能够有更多的数据格式的兼容，因此使用起来会更加的方便，但是测试起来可能不是很方便。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>Get执行效率却比Post方法好。</li>
<li>Get是form提交的默认方法。</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。 </li>
<li>历史记录不能够保存post的参数，却能够保存get的请求参数。</li>
<li>POST用于修改服务器上的数据，有副作用，非幂等。</li>
</ul>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>代码采用fastpai进行演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">BaseModel</span>):  <span class="comment"># 继承了BaseModel，定义了People的数据格式</span></span><br><span class="line">    name: <span class="built_in">str</span> = <span class="literal">None</span>  <span class="comment"># 默认了name的值为None</span></span><br><span class="line">    age: <span class="built_in">int</span> = <span class="number">18</span>  <span class="comment"># 默认了age为18</span></span><br><span class="line">    sex: <span class="built_in">str</span> = <span class="string">&quot;renyao&quot;</span>  <span class="comment"># 默认了sex为renyao</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/fastapi/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">postdate</span>(<span class="params">people: People</span>):  <span class="comment"># 传入一个People类型的参数people</span></span><br><span class="line">    <span class="keyword">return</span> people</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uvicorn.run(<span class="string">&quot;test:app&quot;</span>, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">5000</span>, log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以postget在设计上的确具有很多差异，但是实际使用的时候两者都能够满足传参的需求，但是为了标准，尽可能的使用get用于获取数据，用post提交数据。百度搜索采用的就是get获取数据，而几乎所有的账户登录都是post用于提交数据。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>静态资源与动态资源</title>
    <url>/2022/05/29/%E7%BD%91%E7%BB%9C-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>简单理解WEB服务静态和动态资源请求过程 </p>
<ul>
<li>用户发起访问  </li>
<li>服务器端接收到请求，该请求到达服务器的内核空间，因为tcp/ip协议工作在内核空间；到达内核空间后，发现访问的是80端口的套接字，通过路由和相关解码，请求被转到服务器的用户空间，也就是转到了web服务上；  </li>
<li>请求到达用户空间后，发现请求的是一个文件，然后继续把请求转到内核空间，内核空间通过内核在磁盘上获取对应文件；  </li>
<li>请求在内核空间获取到对应文件后，把文件返回至用户空间即web服务；  </li>
<li>请求结果到达用户空间的web服务上后，把结果再通过套接字回到内核空间；  </li>
<li>内核空间把结果通过网络tcp/ip协议栈返回至客户端。  </li>
</ul>
<h2 id="动态资源请求"><a href="#动态资源请求" class="headerlink" title="动态资源请求"></a>动态资源请求</h2><p>简单理解WEB服务静态和动态资源请求过程</p>
<ul>
<li>用户发起访问  </li>
<li>服务器端接收到请求，该请求到达服务器的内核空间，因为tcp/ip协议工作在内核空间；到达内核空间后，发现访问的是80端口的套接字，通过路由和相关解码，请求被转到服务器的用户空间，也就是转到了web服务上；  </li>
<li>请求到达用户空间后，发现请求的是一个动态页面，然后根据相关协议调用php解释器程序；  </li>
<li>请求到达php解释器中，把请求转至内核空间从磁盘上获取对应文件；  </li>
<li>获取到文件后，请求到达用户空间的解释器中执行一遍；  </li>
<li>解释器把执行结果返回至web服务上，然后解释器进程自行销毁；  </li>
<li>请求结果到达用户空间的web服务上后，把结果再通过套接字回到内核空间；  </li>
<li>内核空间把结果通过网络tcp/ip协议栈返回至客户端。</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>三层架构/MVC/MTV</title>
    <url>/2022/08/01/%E8%AE%BE%E8%AE%A1-%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84-MVC-MTV/</url>
    <content><![CDATA[<p>在以前的时候，我总是把这三者混为一谈，总以为是不同语言或者不同环境条件下的称呼或者变种，后来我逐渐明白这是不一样的。</p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>web开发其实并不一定需要遵循某一个框架进行开发，其实上能够实现web服务就行，但是在长期的摸索跟探究过程中，前人根据自己的经验进行总结，得出依据某个框架或者某个模式进行开发是一个较为高效的过程。</p>
<ul>
<li><strong>界面层（表示层）</strong>:用户看的界面。用户可以通过界面上的组件和服务器进行交互</li>
<li><strong>业务处理逻辑</strong>:处理业务逻辑的</li>
<li><strong>数据访问层</strong>:操作数据存储文件</li>
</ul>
<p>本质上这是一个线性结构，从上往下：</p>
<ul>
<li>表示层请求数据，发送给业务逻辑层</li>
<li>业务逻辑层根据情况去数据访问层进行数据查询</li>
</ul>
<p>从下往上：</p>
<ul>
<li>数据访问层提交原始数据给业务逻辑层</li>
<li>业务逻辑层将处理后的数据提交给表示层</li>
</ul>
<p>整个过程是一个线性结构从上至下的请求数据，数据从下往上进行返回</p>
<h3 id="三层架构的优缺点"><a href="#三层架构的优缺点" class="headerlink" title="三层架构的优缺点"></a>三层架构的优缺点</h3><p>优点:<br>1、高内聚，低耦合<br>2、方便维护，易于扩展<br>3、开发人员可以只关注某一层，有利于分工协作，加快开发速度  </p>
<p>缺点:<br>1、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。<br>2、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。<br>3、增加了代码量，增加了工作量  </p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><strong>M-model模型:</strong> 数据存储层，和数据库打交道。<br><strong>V-view视图:</strong> 视图层，用户看到并与之交互的界面，如由html元素组成的网页界面，或软件的客户端界面。<br><strong>C-controler控制器:</strong> 控制层，控制器把视图层所给的指令用来检索数据层的数据，该层编写代码产生结果并输出。</p>
<p>这个模型的运行过程如下：</p>
<ul>
<li>用户与人机交互输入信息到控制器</li>
<li>控制器将数据指令传递给业务模型</li>
<li>业务模型从数据库当中进行数据从存取</li>
<li>最后根据不同的业务逻辑选择不同的视图</li>
<li>视图给用户之后，用户再选择下一步操作</li>
</ul>
<p>相比于三层模型，MVC没有直接与数据库进行交互，而是通过模型操控数据库，同时根据：用户-&gt;控制器-&gt;模型-&gt;视图-&gt;用户形成一个闭环。相比于三层结构的层层深入再返回，这就不再是一个线性结构，而是一个基于用户操作三角闭环结构。</p>
<h3 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h3><p>1.<strong>耦合性低</strong>，视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。</p>
<p>2.<strong>重用性高</strong>，MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。</p>
<p>3.<strong>部署快，生命周期成本低</strong>，MVC使开发和维护用户接口的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。</p>
<p>4.<strong>可维护性高</strong>，分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。</p>
<h3 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h3><p>1.<strong>完全理解MVC比较复杂</strong>，由于MVC模式提出的时间不长，加上同学们的实践经验不足，所以完全理解并掌握MVC不是一个很容易的过程。</p>
<p>2.<strong>调试困难</strong>，因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试。</p>
<p>3.<strong>不适合小型，中等规模的应用程序</strong>，在一个中小型的应用程序中，强制性的使用MVC进行开发，往往会花费大量时间，并且不能体现MVC的优势，同时会使开发变得繁琐。</p>
<p>4.<strong>增加系统结构和实现的复杂性</strong>，对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p>
<p>5.<strong>视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问</strong>，视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p>
<h2 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h2><p><strong>M-Model模型:</strong> 数据存储层，和数据库打交道。相当于mvc的m</p>
<p><strong>T-Template模板:</strong> 模板层，用来处理页面的显示。相当于mvc的v</p>
<p><strong>V-View视图:</strong> 业务逻辑层，处理具体的业务逻辑，如下图所示，它的作用是通过请求响应获取Model 层，把Model层与 Template层联通。相当于mvc的c</p>
<p>第一次遇见MTV的时候是学习Django的时候，虽然在通用的描述过程当中，会将MTV与MCV相对比起来，建立对应关系，但是其本质运行逻辑是有一定不同的，不能够完全对比。</p>
<p>在MTV中存在以下几种数据交换或者请求：</p>
<ul>
<li>网络请求根据web服务器找到web框架中的路由</li>
<li>路由将消息传递给视图</li>
<li>视图可以发消息给模型，模型也能够直接返回视图信息。</li>
<li>视图可以操作模板，模板也能够直接返回模板结果给视图。</li>
<li>模型也能通过模板语言与模板进行数据交互形成有数据的模板。</li>
<li>最后结构再通过视图从新根据路由原路返回。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>行存储与列存储</title>
    <url>/2024/07/29/%E8%AE%BE%E8%AE%A1-%E8%A1%8C%E5%AD%98%E5%82%A8%E4%B8%8E%E5%88%97%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>在数据库领域，数据存储的方式主要有两种：行存储（Row Storage）和列存储（Column Storage）。这两种存储方式各有优缺点，适用于不同的场景。本文将详细介绍行存储与列存储的区别、优缺点及适用场景。</p>
<h2 id="行存储与列存储的区别"><a href="#行存储与列存储的区别" class="headerlink" title="行存储与列存储的区别"></a>行存储与列存储的区别</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>行存储是将一行数据存储在一起，列存储是将一列数据存储在一起。</p>
<h3 id="数据访问方式"><a href="#数据访问方式" class="headerlink" title="数据访问方式"></a>数据访问方式</h3><p>行存储通常以行为单位进行数据访问，列存储通常以列为单位进行数据访问。</p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>行存储通常使用行级别的压缩算法，列存储通常使用列级别的压缩算法。</p>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>行存储在更新数据时，需要更新整行数据，列存储在更新数据时，只需要更新对应的列。</p>
<h2 id="行存储的优缺点"><a href="#行存储的优缺点" class="headerlink" title="行存储的优缺点"></a>行存储的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>数据访问速度快：行存储以行为单位进行数据访问，可以快速定位到需要的数据行。</li>
<li>数据更新方便：行存储在更新数据时，只需要更新整行数据，不需要更新其他列。</li>
<li>支持事务：行存储支持事务，可以保证数据的一致性和完整性。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>数据压缩率低：行存储通常使用行级别的压缩算法，压缩率相对较低。</li>
<li>数据扫描效率低：行存储在扫描数据时，需要扫描整行数据，效率相对较低。</li>
<li>不适合OLAP场景：行存储在OLAP场景下，无法高效地进行列级别的数据聚合和分析。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li>OLTP场景：行存储在OLTP场景下，可以快速进行数据插入、更新和删除操作，适合事务处理。</li>
<li>数据库管理系统：行存储在数据库管理系统（DBMS）中，可以支持事务、索引等功能。</li>
</ol>
<h2 id="列存储的优缺点"><a href="#列存储的优缺点" class="headerlink" title="列存储的优缺点"></a>列存储的优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>数据压缩率高：列存储通常使用列级别的压缩算法，压缩率相对较高。</li>
<li>数据扫描效率高：列存储在扫描数据时，只需要扫描需要的列，效率相对较高。</li>
<li>适合OLAP场景：列存储在OLAP场景下，可以高效地进行列级别的数据聚合和分析。</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>数据访问速度慢：列存储以列为单位进行数据访问，需要先定位到需要的列，再进行数据访问，速度相对较慢。</li>
<li>数据更新复杂：列存储在更新数据时，需要更新对应的列，操作相对复杂。</li>
<li>不支持事务：列存储通常不支持事务，无法保证数据的一致性和完整性。</li>
</ol>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li>OLAP场景：列存储在OLAP场景下，可以高效地进行数据聚合和分析，适合大数据量的查询和分析。</li>
<li>数据仓库：列存储在数据仓库中，可以存储大量历史数据，并进行高效的数据分析和报表生成。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>行存储和列存储各有优缺点，适用于不同的场景。在实际应用中，可以根据具体的需求和场景，选择合适的存储方式。</p>
]]></content>
  </entry>
  <entry>
    <title>None、nan、null、&quot;&quot;</title>
    <url>/2023/09/07/%E8%AF%AD%E6%B3%95-None%E3%80%81nan%E3%80%81null%E3%80%81%E2%80%9C%E2%80%9D/</url>
    <content><![CDATA[<p>在python语言当中经常会遇到None、nan、null、””还有与之相关的0与False。这几个之间有着明显的区别同时又在特定的时候能够表达一个含义。</p>
<h2 id="None"><a href="#None" class="headerlink" title="None"></a>None</h2><p>在Python中，None是一个特殊的对象，表示空或无值。它用于表示一个变量或返回值没有被赋予任何值。</p>
<p>None在Python中被用作默认参数值、函数返回值或变量初始化时的占位符。当一个函数没有显式地返回任何值时，默认返回None。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_something</span>():</span><br><span class="line">    <span class="comment"># 执行一些操作，但没有返回值</span></span><br><span class="line"></span><br><span class="line">result = do_something()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出 None</span></span><br><span class="line">在条件语句中，<span class="literal">None</span>被视为<span class="literal">False</span>。例如：</span><br><span class="line"></span><br><span class="line">python</span><br><span class="line">value = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> value:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;value is not None&quot;</span>)  <span class="comment"># 不会执行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;value is None&quot;</span>)  <span class="comment"># 输出 value is None</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，None是一个对象，而不是关键字。因此，可以将None赋值给变量，也可以作为函数的参数或返回值。但是，None不能与其他对象进行比较，只能使用<code>is</code>或<code>is not</code>运算符进行判断。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line">b = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is None&quot;</span>)  <span class="comment"># 输出 a is None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is not None&quot;</span>)  <span class="comment"># 不会执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a equals b&quot;</span>)  <span class="comment"># 不会执行</span></span><br></pre></td></tr></table></figure>

<p>None在Python中代表空或无值，用于表示变量没有被赋予任何值，或者函数没有返回值。它在条件语句中被视为False，可以用<code>is</code>或<code>is not</code>来判断变量是否为None。</p>
<h2 id="nan"><a href="#nan" class="headerlink" title="nan"></a>nan</h2><p>在NumPy库中，NaN代表”不是一个数字”（Not a Number）。它是一种特殊的浮点数值，用于表示缺失或无效的数据。</p>
<p>NaN的主要作用是处理缺失数据或在数学计算中表示无效的结果。当使用NumPy进行数值计算时，如果遇到缺失数据或无法进行有效计算的情况，通常会返回NaN。</p>
<p>NaN的特点如下：</p>
<ul>
<li><ol>
<li>NaN是一个浮点数值，用于表示无法进行有效计算或缺失数据。</li>
</ol>
</li>
<li><ol start="2">
<li>NaN在比较操作中不等于任何值，包括自身。这是因为NaN表示一个未知的值，无法与其他值进行比较。</li>
</ol>
</li>
<li><ol start="3">
<li>NaN在数学运算中具有传染性。任何与NaN进行计算的结果都将是NaN。这是为了防止无效的计算结果被误用。</li>
</ol>
</li>
</ul>
<p>在NumPy中，可以使用np.nan来表示NaN。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 [ 1.  2. nan  4.]</span></span><br><span class="line"></span><br><span class="line">b = np.sqrt(a)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出 [ 1.          1.41421356         nan  2.        ]</span></span><br></pre></td></tr></table></figure>

<p>在处理包含NaN的数据时，通常需要使用一些特殊的函数来处理它们，例如<code>np.isnan()</code>用于检查数组中的NaN值，<code>np.nanmean()</code>用于计算数组的平均值（忽略NaN值），<code>np.nanmax()</code>用于找到数组中的最大值（忽略NaN值）等。</p>
<p>NaN在NumPy库中代表不是一个数字，用于表示缺失或无效的数据。它在数学计算中具有传染性，任何与NaN进行计算的结果都将是NaN。处理包含NaN的数据时，需要使用特殊的函数来处理它们。</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>null并不存在于python当中，而是属于json的关键词，但是如果经常使用python操作json或者进行dict于json的转化就会经常遇到这个符号。<br>在JSON（JavaScript Object Notation）中，null代表空值或缺失值。它是JSON中的一个特殊关键字，用于表示一个没有值的对象属性。</p>
<p>JSON是一种轻量级的数据交换格式，常用于数据传输和存储。null在JSON中用于表示一个空的或无效的值，与其他数据类型（如字符串、数字、布尔值和数组）相区别。<br>null的特点如下：</p>
<ul>
<li><ol>
<li>null表示一个空值或缺失值，用于表示属性没有值。</li>
</ol>
</li>
<li><ol start="2">
<li>null不是字符串，也不是关键字，它是JSON语法中的一个特殊标记。</li>
</ol>
</li>
<li><ol start="3">
<li>null在JSON中是大小写敏感的，只能写成小写形式。</li>
</ol>
</li>
</ul>
<p>在JSON中，可以将null用作属性的值，例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述JSON对象中，”age”和”email”属性的值都是null，表示这些属性没有具体的值。在解析JSON数据时，可以使用不同的编程语言或库来处理null值。例如，在Python中，可以使用<code>json</code>模块来解析JSON数据，并使用<code>None</code>来表示null值。null在JSON中代表空值或缺失值，用于表示属性没有值。它是JSON语法中的一个特殊标记，不是字符串或关键字。在解析JSON数据时，可以使用不同的编程语言或库来处理null值。</p>
<h2 id="“”以及-、-等"><a href="#“”以及-、-等" class="headerlink" title="“”以及[]、{}等"></a>“”以及[]、{}等</h2><p>在python当中想要表达一个变量不具备意义的时候可以可以选择None，也可以选择将其制空。但是需要注意<code>&quot;&quot;</code>以及<code>[]</code>、<code>&#123;&#125;</code>等值是具有自己类型的，只是表示当前这个类型的值为空。因此不能互通，也不是None类型。因此在使用函数注释或者装饰的时候需要注意默认参数值与返回值上使用的区别。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这几种值在bool状态下都表示False，包括0也表示False。但是每一种值都有属于自己的类型，在使用上表达不同的含义，仅在bool判断的时候能够作为一种含义表述。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>object当中有什么？</title>
    <url>/2023/10/27/%E8%AF%AD%E6%B3%95-object%E5%BD%93%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">classname</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    docstring</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>:</span><br><span class="line">    __doc__: <span class="built_in">str</span> | <span class="literal">None</span></span><br><span class="line">    __dict__: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span><br><span class="line">    __module__: <span class="built_in">str</span></span><br><span class="line">    __annotations__: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__class__</span>(<span class="params">self</span>) -&gt; <span class="built_in">type</span>[Self]: ...</span><br><span class="line">    <span class="comment"># Ignore errors about type mismatch between property getter and setter</span></span><br><span class="line"><span class="meta">    @__class__.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__class__</span>(<span class="params">self, __<span class="built_in">type</span>: <span class="built_in">type</span>[<span class="built_in">object</span>]</span>) -&gt; <span class="literal">None</span>: ...  <span class="comment"># noqa: F811</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>) -&gt; Self: ...</span><br><span class="line">    <span class="comment"># N.B. `object.__setattr__` and `object.__delattr__` are heavily special-cased by type checkers.</span></span><br><span class="line">    <span class="comment"># Overriding them in subclasses has different semantics, even if the override has an identical signature.</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, __name: <span class="built_in">str</span>, __value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, __name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, __value: <span class="built_in">object</span></span>) -&gt; <span class="built_in">bool</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, __value: <span class="built_in">object</span></span>) -&gt; <span class="built_in">bool</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>: ...  <span class="comment"># noqa: Y029</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>: ...  <span class="comment"># noqa: Y029</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, __format_spec: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, __name: <span class="built_in">str</span></span>) -&gt; <span class="type">Any</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sizeof__</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line">    <span class="comment"># return type of pickle methods is rather hard to express in the current type system</span></span><br><span class="line">    <span class="comment"># see #6661 and https://docs.python.org/3/library/pickle.html#object.__reduce__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span> | <span class="built_in">tuple</span>[<span class="type">Any</span>, ...]: ...</span><br><span class="line">    <span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">8</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__reduce_ex__</span>(<span class="params">self, __protocol: SupportsIndex</span>) -&gt; <span class="built_in">str</span> | <span class="built_in">tuple</span>[<span class="type">Any</span>, ...]: ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__reduce_ex__</span>(<span class="params">self, __protocol: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span> | <span class="built_in">tuple</span>[<span class="type">Any</span>, ...]: ...</span><br><span class="line">    <span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">11</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getstate__</span>(<span class="params">self</span>) -&gt; <span class="built_in">object</span>: ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__dir__</span>(<span class="params">self</span>) -&gt; Iterable[<span class="built_in">str</span>]: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls</span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, __subclass: <span class="built_in">type</span></span>) -&gt; <span class="built_in">bool</span>: ...</span><br></pre></td></tr></table></figure>

<h2 id="doc-str-None"><a href="#doc-str-None" class="headerlink" title="__doc__: str | None"></a><code>__doc__: str | None</code></h2><p><code>__doc__</code>方法是python内置方法之一，该方法通常会返回指定对象中的注释部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">   <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   这个是我定义的类的注释</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    这是一个类属性</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">index = ClassName()</span><br><span class="line"><span class="built_in">print</span>(index.__doc__)</span><br><span class="line"><span class="built_in">print</span>(index.__init__.__doc__)</span><br></pre></td></tr></table></figure>

<h2 id="dict-dict-str-Any"><a href="#dict-dict-str-Any" class="headerlink" title="__dict__: dict[str, Any]"></a><code>__dict__: dict[str, Any]</code></h2><p><code>__dict__</code>属性在不同的地方有不同的使用：</p>
<ul>
<li>类<code>__dict__</code>属性：包括静态函数、普通函数、类函数或者全局变量、一些内置属性</li>
<li>类对象<code>__dict__</code>属性：存储了一些<code>self.xxx</code>的一些东西，其中父类与子类对象共用<code>__dict__</code></li>
<li>在字典中是一个字典里面存放的数据</li>
<li>一些内置数据类型是没有<code>__dict__</code>属性的。比如<code>int</code>、<code>list</code>、<code>dict</code>等这些数据类型</li>
<li>继承的时候<code>__dict__</code>属性中每个类的类变量，函数名都放在自己的<code>__dict__</code>中，实例变量的<code>__dict__</code>中父类和子类对象的<code>__dict__</code>是公用的</li>
</ul>
<h2 id="module-str"><a href="#module-str" class="headerlink" title="__module__: str"></a><code>__module__: str</code></h2><h2 id="annotations-dict-str-Any"><a href="#annotations-dict-str-Any" class="headerlink" title="__annotations__: dict[str, Any]"></a><code>__annotations__: dict[str, Any]</code></h2><h2 id="def-class-self-type-type-object-gt-None-noqa-F811"><a href="#def-class-self-type-type-object-gt-None-noqa-F811" class="headerlink" title="def __class__(self, __type: type[object]) -&gt; None: ...  # noqa: F811"></a><code>def __class__(self, __type: type[object]) -&gt; None: ...  # noqa: F811</code></h2><h2 id="def-init-self-gt-None"><a href="#def-init-self-gt-None" class="headerlink" title="def __init__(self) -&gt; None: ..."></a><code>def __init__(self) -&gt; None: ...</code></h2><h2 id="def-new-cls-gt-Self"><a href="#def-new-cls-gt-Self" class="headerlink" title="def __new__(cls) -&gt; Self: ..."></a><code>def __new__(cls) -&gt; Self: ...</code></h2><h2 id="def-setattr-self-name-str-value-Any-gt-None"><a href="#def-setattr-self-name-str-value-Any-gt-None" class="headerlink" title="def __setattr__(self, __name: str, __value: Any) -&gt; None: ..."></a><code>def __setattr__(self, __name: str, __value: Any) -&gt; None: ...</code></h2><h2 id="def-delattr-self-name-str-gt-None"><a href="#def-delattr-self-name-str-gt-None" class="headerlink" title="def __delattr__(self, __name: str) -&gt; None: ..."></a><code>def __delattr__(self, __name: str) -&gt; None: ...</code></h2><h2 id="def-eq-self-value-object-gt-bool"><a href="#def-eq-self-value-object-gt-bool" class="headerlink" title="def __eq__(self, __value: object) -&gt; bool: ..."></a><code>def __eq__(self, __value: object) -&gt; bool: ...</code></h2><h2 id="def-ne-self-value-object-gt-bool"><a href="#def-ne-self-value-object-gt-bool" class="headerlink" title="def __ne__(self, __value: object) -&gt; bool: ..."></a><code>def __ne__(self, __value: object) -&gt; bool: ...</code></h2><h2 id="def-str-self-gt-str-noqa-Y029"><a href="#def-str-self-gt-str-noqa-Y029" class="headerlink" title="def __str__(self) -&gt; str: ...  # noqa: Y029"></a><code>def __str__(self) -&gt; str: ...  # noqa: Y029</code></h2><h2 id="def-repr-self-gt-str-noqa-Y029"><a href="#def-repr-self-gt-str-noqa-Y029" class="headerlink" title="def __repr__(self) -&gt; str: ...  # noqa: Y029"></a><code>def __repr__(self) -&gt; str: ...  # noqa: Y029</code></h2><h2 id="def-hash-self-gt-int"><a href="#def-hash-self-gt-int" class="headerlink" title="def __hash__(self) -&gt; int: ..."></a><code>def __hash__(self) -&gt; int: ...</code></h2><h2 id="def-format-self-format-spec-str-gt-str"><a href="#def-format-self-format-spec-str-gt-str" class="headerlink" title="def __format__(self, __format_spec: str) -&gt; str: ..."></a><code>def __format__(self, __format_spec: str) -&gt; str: ...</code></h2><h2 id="def-getattribute-self-name-str-gt-Any"><a href="#def-getattribute-self-name-str-gt-Any" class="headerlink" title="def __getattribute__(self, __name: str) -&gt; Any: ..."></a><code>def __getattribute__(self, __name: str) -&gt; Any: ...</code></h2><h2 id="def-sizeof-self-gt-int"><a href="#def-sizeof-self-gt-int" class="headerlink" title="def __sizeof__(self) -&gt; int: ..."></a><code>def __sizeof__(self) -&gt; int: ...</code></h2><h2 id="def-reduce-self-gt-str-tuple-Any"><a href="#def-reduce-self-gt-str-tuple-Any" class="headerlink" title="def __reduce__(self) -&gt; str | tuple[Any, ...]: ..."></a><code>def __reduce__(self) -&gt; str | tuple[Any, ...]: ...</code></h2><h2 id="def-dir-self-gt-Iterable-str"><a href="#def-dir-self-gt-Iterable-str" class="headerlink" title="def __dir__(self) -&gt; Iterable[str]: ..."></a><code>def __dir__(self) -&gt; Iterable[str]: ...</code></h2><h2 id="def-init-subclass-cls-gt-None"><a href="#def-init-subclass-cls-gt-None" class="headerlink" title="def __init_subclass__(cls) -&gt; None: ..."></a><code>def __init_subclass__(cls) -&gt; None: ...</code></h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>with语句</title>
    <url>/2022/10/30/%E8%AF%AD%E6%B3%95-with%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>在工作当中写代码的时候遇到当需要使用python打开文件的时候，程序会提示你使用<code>with</code>语句而是不是<code>open+close</code>，以前自己都未曾关心为啥，这样做有什么优势，现在越发好奇了。</p>
<h2 id="With语句是什么？"><a href="#With语句是什么？" class="headerlink" title="With语句是什么？"></a>With语句是什么？</h2><p>最常见的解释就是说当年你需要打开一个文件的时候，如果只是打开不关闭是危险或者不规范的操作，所以必须要有打开也要有关闭，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">data = file.read()</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>但是这里有两个问题：  </p>
<ul>
<li>一是可能忘记关闭文件句柄；</li>
<li>二是文件读取数据发生异常，没有进行任何处理。</li>
</ul>
<p>所以为了安全起见推荐有以下改进方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = file.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure>

<p>虽然更加安全，但是冗长以及理解更困难的问题也随之出现了。而<code>with</code>语法正好可以解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br></pre></td></tr></table></figure>

<h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p><code>with</code>语句的使用被成为上下文管理器。当与第一个例子对比时，可以看到，通过使用 <code>with</code>，许多样板代码（boilerplate code）被消掉了。 这就是 with 语句的主要优势，它确保文件会被关闭，而不用关注嵌套代码如何退出。上下文管理器的一个常见用例，是资源的加锁和解锁，以及关闭已打开的文件（就像我已经展示给你看的）。</p>
<p>以下展示关于上下文管理器的实现代码：</p>
<h3 id="基于类"><a href="#基于类" class="headerlink" title="基于类"></a>基于类</h3><p>一个上下文管理器的类，最起码要定义 <code>__enter__</code> 和 <code>__exit__</code> 方法。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_name, method</span>):</span><br><span class="line">        self.file_obj = <span class="built_in">open</span>(file_name, method)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.file_obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):</span><br><span class="line">        self.file_obj.close()</span><br></pre></td></tr></table></figure>

<p>通过定义 <code>__enter__</code> 和 <code>__exit__</code> 方法，可以在<code>with</code>语句里使用它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> File(<span class="string">&#x27;demo.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.write(<span class="string">&#x27;Hola!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p> <code>__exit__</code> 函数接受三个参数。这些参数对于每个上下文管理器类中的 <code>__exit__</code> 方法都是必须的。</p>
<ul>
<li>with 语句先暂存了 <code>File</code> 类的 <code>__exit__</code> 方法。</li>
<li>然后它调用 File 类的 <code>__enter__</code> 方法。</li>
<li><code>__enter__</code> 方法打开文件并返回给 <code>with</code> 语句。</li>
<li>打开的文件句柄被传递给 <code>opened_file</code> 参数。</li>
<li>使用 <code>.write()</code> 来写文件。</li>
<li><code>with</code> 语句调用之前暂存的 <code>__exit__</code> 方法。</li>
<li><code>__exit__</code> 方法关闭了文件。</li>
</ul>
<hr>
<p><code>__exit__</code> 方法的这三个参数：<code>type</code>，<code>value</code> 和 <code>traceback</code>。 在第4步和第6步之间，如果发生异常，<code>Python</code> 会将异常的 <code>type</code>，<code>value</code> 和 <code>traceback</code> 传递给 <code>__exit__</code> 方法。 它让 <code>__exit__</code> 方法来决定如何关闭文件以及是否需要其他步骤。在案例中，并没有注意它们。<br>那如果文件对象抛出一个异常呢？万一尝试访问文件对象的一个不支持的方法。举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> File(<span class="string">&#x27;demo.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.undefined_function(<span class="string">&#x27;Hola!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>来列一下，当异常发生时，with 语句会采取哪些步骤。</p>
<ul>
<li>它把异常的 <code>type</code>，<code>value</code> 和 <code>traceback</code> 传递给 <code>__exit__</code>方法。</li>
<li>它让 <code>__exit__</code> 方法来处理异常。</li>
<li>如果 <code>__exit__</code> 返回的是 <code>True</code>，那么这个异常就被优雅地处理了。</li>
<li>如果 <code>__exit__</code> 返回的是 <code>True</code> 以外的任何东西，那么这个异常将被 <code>with</code> 语句抛出。</li>
</ul>
<p>案例中，<code>__exit__</code> 方法返回的是 <code>None</code> （如果没有 <code>return</code> 语句那么方法会返回 <code>None</code>）。因此，<code>with</code> 语句抛出了那个异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;file&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;undefined_function&#x27;</span></span><br></pre></td></tr></table></figure>

<p>尝试下在 <code>__exit__</code> 方法中处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_name, method</span>):</span><br><span class="line">        self.file_obj = <span class="built_in">open</span>(file_name, method)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.file_obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exception has been handled&quot;</span>)</span><br><span class="line">        self.file_obj.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> File(<span class="string">&#x27;demo.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.undefined_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: Exception has been handled</span></span><br></pre></td></tr></table></figure>

<p><code>__exit__</code> 方法返回了 True，因此没有异常会被 with 语句抛出。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>with</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅地废弃代码</title>
    <url>/2024/12/01/%E8%AF%AD%E6%B3%95-%E4%BC%98%E9%9B%85%E5%9C%B0%E5%BA%9F%E5%BC%83%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Python-中的-deprecated-装饰器：优雅地废弃代码"><a href="#Python-中的-deprecated-装饰器：优雅地废弃代码" class="headerlink" title="Python 中的 @deprecated 装饰器：优雅地废弃代码"></a>Python 中的 @deprecated 装饰器：优雅地废弃代码</h2><p>在软件开发过程中，我们经常会遇到需要废弃旧代码的情况。这可能是因为代码存在安全问题、性能问题，或者是因为有了更好的替代方案。Python 提供了一种优雅的方式来处理这种情况，那就是使用 <code>@deprecated</code> 装饰器。本文将详细介绍 <code>@deprecated</code> 装饰器的使用方法、实现原理以及最佳实践。</p>
<h2 id="什么是-deprecated-装饰器？"><a href="#什么是-deprecated-装饰器？" class="headerlink" title="什么是 @deprecated 装饰器？"></a>什么是 <code>@deprecated</code> 装饰器？</h2><p><code>@deprecated</code> 装饰器是一个用于标记函数、方法或类为已废弃的工具。当被标记的代码被调用时，它会触发一个 <code>DeprecationWarning</code> 警告，提醒开发者该功能将在未来版本中被移除或更改。</p>
<h2 id="如何使用-deprecated-装饰器？"><a href="#如何使用-deprecated-装饰器？" class="headerlink" title="如何使用 @deprecated 装饰器？"></a>如何使用 <code>@deprecated</code> 装饰器？</h2><p>Python 标准库中的 <code>warnings</code> 模块提供了 <code>warn</code> 函数，可以用来发出警告。结合 <code>functools</code> 模块中的 <code>wraps</code> 装饰器，我们可以创建一个自定义的 <code>@deprecated</code> 装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deprecated</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;func.__name__&#125;</span> is deprecated and will be removed in future versions.&quot;</span>,</span><br><span class="line">            category=DeprecationWarning,</span><br><span class="line">            stacklevel=<span class="number">2</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>使用这个装饰器非常简单，只需将其添加到你想要废弃的函数上方即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@deprecated</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">old_function</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<h2 id="deprecated-装饰器的工作原理"><a href="#deprecated-装饰器的工作原理" class="headerlink" title="@deprecated 装饰器的工作原理"></a><code>@deprecated</code> 装饰器的工作原理</h2><p>当你调用被 <code>@deprecated</code> 装饰的函数时，装饰器内部的 <code>wrapper</code> 函数会被执行。这个 <code>wrapper</code> 函数首先使用 <code>warnings.warn</code> 发出一个 <code>DeprecationWarning</code>，然后调用原始函数。这样，即使函数被废弃，它仍然可以执行其原始功能，同时提醒使用者注意即将到来的更改。</p>
<h2 id="为什么要使用-deprecated-装饰器？"><a href="#为什么要使用-deprecated-装饰器？" class="headerlink" title="为什么要使用 @deprecated 装饰器？"></a>为什么要使用 <code>@deprecated</code> 装饰器？</h2><ol>
<li><strong>提前通知</strong>：通过 <code>DeprecationWarning</code> 提前通知用户，让他们有时间迁移到新的API。</li>
<li><strong>代码兼容性</strong>：在完全移除旧代码之前，保持向后兼容性。</li>
<li><strong>逐步迁移</strong>：允许开发者逐步迁移代码，而不是一次性大规模更改。</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li><strong>明确替代方案</strong>：在发出警告时，最好提供替代方案的信息，帮助用户平滑过渡。</li>
<li><strong>设置警告级别</strong>：根据需要，可以设置警告的级别，例如 <code>DeprecationWarning</code> 或 <code>PendingDeprecationWarning</code>。</li>
<li><strong>记录废弃日志</strong>：在发出警告的同时，可以考虑将废弃信息记录到日志文件中，方便追踪废弃代码的使用情况。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 <code>@deprecated</code> 装饰器是处理代码废弃的一种优雅方式。它不仅提醒开发者注意即将到来的更改，还有助于保持代码的兼容性和可维护性。通过合理使用 <code>@deprecated</code> 装饰器，我们可以确保代码的平滑过渡和持续改进。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>不常见的python类型校验</title>
    <url>/2022/09/06/%E8%AF%AD%E6%B3%95-%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84python%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>以前写过关于python类型校验的相关总结，但是不怎么全面，有些不常见的特殊情况并未被记录。</p>
<h2 id="任意类型any"><a href="#任意类型any" class="headerlink" title="任意类型any"></a>任意类型any</h2><p>若声明某函数时指定函数传入参数的数据类型为any，则调用该函数时该参数的参数类型可以为任意类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">name: <span class="built_in">any</span>, age: <span class="string">&#x27;int &gt; 0&#x27;</span> = <span class="number">20</span></span>) -&gt; <span class="built_in">str</span>:  <span class="comment"># -&gt;str 表示该函数的返回值是str类型的</span></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="built_in">type</span>(name))</span><br><span class="line">    <span class="built_in">print</span>(age, <span class="built_in">type</span>(age))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给List[float]类型取个别名为Vector</span></span><br><span class="line">Vector = <span class="type">List</span>[<span class="built_in">float</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scale</span>(<span class="params">scalar: <span class="built_in">float</span>, vector: Vector</span>) -&gt; Vector:</span><br><span class="line">    <span class="keyword">return</span> [scalar * num <span class="keyword">for</span> num <span class="keyword">in</span> vector]</span><br><span class="line"></span><br><span class="line">new_vector = scale(<span class="number">2.0</span>, [<span class="number">1.0</span>, -<span class="number">4.2</span>, <span class="number">5.4</span>])</span><br></pre></td></tr></table></figure>

<h2 id="内容与长度限制"><a href="#内容与长度限制" class="headerlink" title="内容与长度限制"></a>内容与长度限制</h2><p>在需要限制声明变量的长度以及包含类型的时候可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line">version: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="泛型与嵌套类型"><a href="#泛型与嵌套类型" class="headerlink" title="泛型与嵌套类型"></a>泛型与嵌套类型</h2><p>类型结构包含多种样式的时候可以使用泛型与嵌套类型的方式处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var: <span class="type">List</span>[<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">float</span>] = [<span class="number">2</span>, <span class="number">3.5</span>] <span class="comment"># 泛型</span></span><br><span class="line">var: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]] = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]] <span class="comment"># 嵌套类型</span></span><br><span class="line">person: <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">int</span>, <span class="built_in">float</span>] = (<span class="string">&#x27;Mike&#x27;</span>, <span class="number">22</span>, <span class="number">1.75</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Dict、Mapping、MutableMapping-Set、AbstractSet"><a href="#Dict、Mapping、MutableMapping-Set、AbstractSet" class="headerlink" title="Dict、Mapping、MutableMapping / Set、AbstractSet"></a>Dict、Mapping、MutableMapping / Set、AbstractSet</h2><p>在需要声明字典类型的时候需要十分注意，因为根据官方文档，<code>Dict</code> 推荐用于注解返回类型，<code>Mapping</code> 推荐用于注解参数。它们的使用方法都是一样的，其后跟一个中括号，中括号内分别声明键名、键值的类型.</p>
<p>因此以下写法是不规范的，容易引起编辑器警告：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testfun</span>(<span class="params">dict_info:<span class="type">Dict</span>[<span class="built_in">str</span>,<span class="built_in">int</span>]=&#123;<span class="string">&quot;key&quot;</span>:<span class="number">1</span>&#125;</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>正确写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">rect: Mapping[<span class="built_in">str</span>, <span class="built_in">int</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;width&#x27;</span>: rect[<span class="string">&#x27;width&#x27;</span>] + <span class="number">100</span>, <span class="string">&#x27;height&#x27;</span>: rect[<span class="string">&#x27;width&#x27;</span>] + <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>set</code>亦如此</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe</span>(<span class="params">s: AbstractSet[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Set</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(s)</span><br></pre></td></tr></table></figure>

<h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>Sequence是一个泛型，其本身不需要去指定究竟是List还是tuple，用法与List类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">elements: <span class="type">Sequence</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="keyword">return</span> [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> elements]</span><br></pre></td></tr></table></figure>

<h2 id="无返回内容"><a href="#无返回内容" class="headerlink" title="无返回内容"></a>无返回内容</h2><p>当函数没有返回内容的时候也可以进行注解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() -&gt; NoReturn:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="TypeVar"><a href="#TypeVar" class="headerlink" title="TypeVar"></a>TypeVar</h2><p>当使用场景当中某个返回变量可以是多种类型，但不能是某些少数类型的时候，可以采用TypeVar</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如一个人的身高，便可以使用 int 或 float 或 None 来表示，但不能用 dict 来表示，所以可以这么声明：</span></span><br><span class="line"></span><br><span class="line">height = <span class="number">1.75</span></span><br><span class="line">Height = TypeVar(<span class="string">&#x27;Height&#x27;</span>, <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_height</span>() -&gt; Height:</span><br><span class="line">    <span class="keyword">return</span> height</span><br></pre></td></tr></table></figure>

<h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p>Union，联合类型，Union[X, Y] 代表要么是 X 类型，要么是 Y 类型。但是不能是两者混用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="type">Union</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>], <span class="built_in">float</span>] == <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">float</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional：意思是说这个参数可以为空或已经声明的类型，即 Optional[X] 等价于 Union[X, None]。</p>
<p>在参数传递的时候某些参数不一定非要传值，这时候Optional作为一种可选类型非常好用。</p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>如果想代表一个生成器类型，可以使用 Generator，它的声明比较特殊，其后的中括号紧跟着三个参数，分别代表 YieldType、SendType、ReturnType，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Generator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo_round</span>() -&gt; Generator[<span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">str</span>]:</span><br><span class="line">    sent = <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> sent &gt;= <span class="number">0</span>:</span><br><span class="line">        sent = <span class="keyword">yield</span> <span class="built_in">round</span>(sent)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这里 yield 关键字后面紧跟的变量的类型就是 YieldType，yield 返回的结果的类型就是 SendType，最后生成器 return 的内容就是 ReturnType。</p>
<p>当然很多情况下，生成器往往只需要 yield 内容就够了，我们是不需要 SendType 和 ReturnType 的，可以将其设置为空，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Generator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_stream</span>(<span class="params">start: <span class="built_in">int</span></span>) -&gt; Generator[<span class="built_in">int</span>, <span class="literal">None</span>, <span class="literal">None</span>]:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line">        start += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊类型的声明</title>
    <url>/2022/05/10/%E8%AF%AD%E6%B3%95-%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<p>在类型声明的部分，提供的类型声明大多都是官方给定的类型，如:<code>int</code>,<code>float</code>,<code>str</code>,<code>list</code>,<code>dict</code>,<code>set</code>等等，但是某些时候当我们使用一些特殊的变量的时候，类型并不存在于官方给定的选项中。比如某些python的库创造的变量是具有自定义的类型的，这个时候该怎么操作呢？以下给出两个例子：</p>
<h2 id="库当中的类型"><a href="#库当中的类型" class="headerlink" title="库当中的类型"></a>库当中的类型</h2><p>先看案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html_doc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup)</span><br></pre></td></tr></table></figure>

<p>这是一段BeautifulSoup库的代码，如果需要将soup当作变量传递到一个函数当中，soup是什么类型的呢？可以用<code>type()</code>方法进行查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(soup)</span><br><span class="line"><span class="comment"># &lt;class &#x27;bs4.BeautifulSoup&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在就知道了soup的类型，于是代码就能写成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4 <span class="comment"># 引入类型对象</span></span><br><span class="line"></span><br><span class="line">html_doc = <span class="string">&quot;&quot;&quot;&lt;html&gt;test&lt;/html&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">soup:bs4.BeautifulSoup</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义的类型"><a href="#自定义的类型" class="headerlink" title="自定义的类型"></a>自定义的类型</h2><p>如果是自定义的类型呢？什么情况下有自定义的类型？当然是将class对象当中变量传递的时候了，我们都知道实例化的对象是class或者啥的，但是class并不是对象的类型，对象的类型应该是class的名字.<br>所以代码如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcname</span>(<span class="params">parm:test</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    docstring</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>倘若不信也可以亲自使用<code>type()</code>进行验证。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python之类型提示</title>
    <url>/2022/04/30/%E8%AF%AD%E6%B3%95-%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<p>Python 3.6+ 版本加入了对”类型提示”的支持。通过声明变量的类型，编辑器和一些工具能给你提供更好的支持。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>当我们在使用python写一段代码的时候，如果遇到下面这种情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funcname</span>(<span class="params">param1,param2</span>):</span><br><span class="line">    <span class="built_in">print</span>(param1.split(<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>如果我们想要对函数传递的某些参数进行一些操作的话，在使用一些内置方法的时候，我们通常会依赖python的联想功能，但是在这种情况下，一切都不管用，因为编辑器根本不知道参数是什么类型，所以更不知道可以做什么操作。就像下面这样:</p>
<p><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/python%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA/1.png" alt="失败情况"></p>
<p>但是，我们加上类型提示之后，一切都会变得不一样。而所谓的类型提示就是告诉编辑器，这到底是一个什么类型的参数，如下：</p>
<p><img src="https://liu__tao.gitee.io/drawing-bed/blog_img/python%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA/2.png" alt="失败情况"></p>
<p>这样我们就能够正确的去实现编辑器的联想功能了。但是….类型提示仅限于此吗？并非如此，类型提示可以帮助我们规范参数类型，自动过滤某些非法参数，防止SQL注入等安全问题。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h3 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h3><p>普通类型即我们常见的类型，如：int、float、bool、bytes这些类型使用方式如上，在函数参数处声明使用。</p>
<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>嵌套类型指该类型内部可以包含其他类型，如常见的 dict、list、set 和 tuple等，这些类型的内部可以拥有其他类型，甚至于这些类型可以相互嵌套，如列表于字典的混合嵌套就是非常常见的情况。</p>
<blockquote>
<p>由于嵌套类型在python语言中不能够直接被识别，因此需要导入一个特定的库才可以，即:<code>tying</code></p>
</blockquote>
<p>嵌套类型的使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcname</span>(<span class="params">param: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">    <span class="built_in">print</span>(param.append(<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>其他嵌套类型以此类推。</p>
<h3 id="以类作为类型提示"><a href="#以类作为类型提示" class="headerlink" title="以类作为类型提示"></a>以类作为类型提示</h3><p>通过上面的案例，我们已将能够实现较多的数据类型提示功能了，但是当遇到一些复杂情况的时候，比如需要复杂的数据校验，或者涉及到需要多层嵌套的情况下，以前的简单数据类型已经完全不能够满足需求了，这个时候就需要类的出现了。</p>
<p>对于使用类来作为类型提示，需要引入一个特别的库即：<code>Pydantic</code>。这个库提供了丰富的类型提示的相关帮助，能够帮助开发者实现数据校验、数据限制、嵌套类型识别、密码安全验证、数据库操作模型等等。由于这是一个庞大的知识，我一时半会也阐述不完整，因此我附上两份文档：</p>
<p><a href="https://pydantic-docs.helpmanual.io/">https://pydantic-docs.helpmanual.io/</a>   </p>
<p><a href="https://blog.csdn.net/swinfans/article/details/89629641">https://blog.csdn.net/swinfans/article/details/89629641</a></p>
<p>同时附上几个从互联网上找到的几个案例：</p>
<p>配合函数使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;The description of the item&quot;</span>, max_length=<span class="number">300</span>)</span><br><span class="line">    price: <span class="built_in">float</span> = Field(..., gt=<span class="number">0</span>, description=<span class="string">&quot;The price must be greater than zero&quot;</span>)</span><br><span class="line">    tax: <span class="built_in">float</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item = Body(<span class="params">..., embed=<span class="literal">True</span></span>)</span>):</span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<p>嵌套类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Union</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gender</span>(<span class="built_in">str</span>, Enum):</span><br><span class="line">    man = <span class="string">&quot;man&quot;</span></span><br><span class="line">    women = <span class="string">&quot;women&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name : <span class="built_in">str</span></span><br><span class="line">    gender : Gender</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name : <span class="built_in">str</span></span><br><span class="line">    lead : Person</span><br><span class="line">    cast : <span class="type">List</span>[Person]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    owner: Person</span><br><span class="line">    member_list: <span class="type">List</span>[Person] = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    owner: <span class="type">Union</span>[Person, Group]</span><br><span class="line">    regtime: date</span><br><span class="line">    department_list: <span class="type">List</span>[Department] = []</span><br></pre></td></tr></table></figure>

<p>数据校验：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, ValidationError, validator</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoModel</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    friends: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line">    books: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &#x27;*&#x27; 在这里是匹配任意字段，包含friends，books</span></span><br><span class="line"><span class="meta">    @validator(<span class="params"><span class="string">&#x27;*&#x27;</span>, pre=<span class="literal">True</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split_str</span>(<span class="params">cls, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果传参是字符串，根据逗号切割成list&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">return</span> v.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"><span class="meta">    @validator(<span class="params"><span class="string">&#x27;books&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">books_greater_then_5</span>(<span class="params">cls, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断books数量少于5&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;books greater than 5&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = &#123;</span><br><span class="line">    <span class="string">&quot;friends&quot;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">&quot;books&quot;</span>: <span class="string">&quot;3,4,5&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">d = DemoModel(**a1)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># friends=[2, 3, 4] books=[3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(d.<span class="built_in">dict</span>())  <span class="comment"># &#123;&#x27;friends&#x27;: [2, 3, 4], &#x27;books&#x27;: [3, 4, 5]&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>python提供的类型提示方法能够帮助使用者快速高效的去验证数据参数的合规性与安全性，保障数据传输在高效的同时兼顾安全性能，相比于其他的手动验证方式，这样的方式明显高效更多。也能使得文档具有更强的可读性，帮助开发者理解代码逻辑含义，提高编程效率。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>循环、迭代器、生成器</title>
    <url>/2025/05/23/%E8%AF%AD%E6%B3%95-%E5%BE%AA%E7%8E%AF%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、循环（Loop）"><a href="#一、循环（Loop）" class="headerlink" title="一、循环（Loop）"></a><strong>一、循环（Loop）</strong></h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a><strong>本质</strong></h3><p>循环是一种<strong>控制结构</strong>，用于重复执行代码块。它本身不是数据结构，而是一种语法机制。</p>
<h3 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a><strong>常见形式</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. for 循环（遍历可迭代对象）</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. while 循环（基于条件）</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>需要重复执行相同或相似的操作</li>
<li>遍历容器中的元素（如列表、字典）</li>
<li>实现需要终止条件的逻辑（如用户登录验证）</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h3><ul>
<li>简单直观，易于理解和使用</li>
<li>适用于大多数重复操作场景</li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a><strong>劣势</strong></h3><ul>
<li>当处理大量数据时，可能占用大量内存（如生成全量数据列表）</li>
<li>无法暂停或恢复执行流程</li>
</ul>
<h2 id="二、迭代器（Iterator）"><a href="#二、迭代器（Iterator）" class="headerlink" title="二、迭代器（Iterator）"></a><strong>二、迭代器（Iterator）</strong></h2><h3 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a><strong>本质</strong></h3><p>迭代器是实现了<strong>迭代器协议</strong>的对象（即包含 <code>__iter__()</code> 和 <code>__next__()</code> 方法）。它是一种<strong>数据访问方式</strong>，允许你按需逐个访问元素。</p>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a><strong>核心方法</strong></h3><ul>
<li><code>__iter__()</code>：返回迭代器自身</li>
<li><code>__next__()</code>：返回下一个元素，若没有元素则抛出 <code>StopIteration</code> 异常</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_iter = <span class="built_in">iter</span>(my_list)  <span class="comment"># 创建迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))  <span class="comment"># 输出 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))  <span class="comment"># 输出 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))  <span class="comment"># 抛出 StopIteration</span></span><br></pre></td></tr></table></figure>

<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>需要逐个处理大量数据（如文件读取、数据库查询结果）</li>
<li>实现自定义的遍历逻辑（如树形结构遍历）</li>
</ul>
<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a><strong>优势</strong></h3><ul>
<li><strong>节省内存</strong>：不需要预先生成所有元素，而是按需生成</li>
<li>支持无限序列（如计数器、斐波那契数列）</li>
</ul>
<h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a><strong>劣势</strong></h3><ul>
<li>只能向前遍历，不能回退或重置（除非重新创建迭代器）</li>
<li>代码复杂度略高于普通循环</li>
</ul>
<h2 id="三、生成器（Generator）"><a href="#三、生成器（Generator）" class="headerlink" title="三、生成器（Generator）"></a><strong>三、生成器（Generator）</strong></h2><h3 id="本质-2"><a href="#本质-2" class="headerlink" title="本质"></a><strong>本质</strong></h3><p>生成器是一种<strong>特殊的迭代器</strong>，它通过更简洁的语法实现（使用 <code>yield</code> 关键字或生成器表达式）。它允许你在需要时生成值，而不是预先计算并存储所有值。</p>
<h3 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a><strong>两种形式</strong></h3><ol>
<li><p><strong>生成器函数</strong>（使用 <code>yield</code>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">gen = my_generator()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出 1</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>生成器表达式</strong>（类似列表推导式，但用圆括号）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出 0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>处理大量数据或无限序列（如日志分析、大数据集）</li>
<li>实现惰性计算（只在需要时生成结果）</li>
<li>简化迭代器的实现（无需手动编写 <code>__iter__</code> 和 <code>__next__</code> 方法）</li>
</ul>
<h3 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a><strong>优势</strong></h3><ul>
<li><strong>最节省内存</strong>：逐个生成值，不存储整个序列</li>
<li>代码简洁，可读性高</li>
<li>支持暂停和恢复执行（每次 <code>yield</code> 后暂停，下次调用 <code>next()</code> 继续执行）</li>
</ul>
<h3 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a><strong>劣势</strong></h3><ul>
<li>只能遍历一次，不能回头</li>
<li>不适合需要随机访问元素的场景</li>
</ul>
<h2 id="四、对比总结"><a href="#四、对比总结" class="headerlink" title="四、对比总结"></a><strong>四、对比总结</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>循环（Loop）</strong></th>
<th><strong>迭代器（Iterator）</strong></th>
<th><strong>生成器（Generator）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td>控制结构</td>
<td>实现迭代协议的对象</td>
<td>特殊的迭代器</td>
</tr>
<tr>
<td><strong>内存效率</strong></td>
<td>低（预生成所有元素）</td>
<td>高（按需生成）</td>
<td>极高（按需生成）</td>
</tr>
<tr>
<td><strong>代码复杂度</strong></td>
<td>最低</td>
<td>中等</td>
<td>低（比迭代器更简洁）</td>
</tr>
<tr>
<td><strong>状态保存</strong></td>
<td>无</td>
<td>自动保存（通过 <code>__next__</code>）</td>
<td>自动保存（通过 <code>yield</code>）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单重复操作</td>
<td>自定义遍历逻辑</td>
<td>大数据处理、惰性计算</td>
</tr>
<tr>
<td><strong>能否无限序列</strong></td>
<td>需手动控制终止条件</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h2 id="五、何时用哪个？"><a href="#五、何时用哪个？" class="headerlink" title="五、何时用哪个？"></a><strong>五、何时用哪个？</strong></h2><ul>
<li><strong>用循环</strong>：当需要简单遍历已知的、有限的数据集，且不需要节省内存时。</li>
<li><strong>用迭代器</strong>：当需要自定义遍历逻辑，或处理大量数据但不想一次性加载到内存时。</li>
<li><strong>用生成器</strong>：当处理超大数据集、无限序列，或需要最大化内存效率时（如数据管道、流式处理）。</li>
</ul>
<p><strong>举个例子</strong>：</p>
<ul>
<li>遍历一个小列表：直接用 <code>for</code> 循环。</li>
<li>遍历一个 10GB 的日志文件：用生成器逐行读取。</li>
<li>实现一个斐波那契数列生成器：用生成器函数（无限序列）。</li>
</ul>
<hr>
<p>看完之后可能还会有一个疑问，就是<code>__iter__</code>返回自身，但是好像并没有看到调用<code>__iter__</code>的地方，这是为什么呢？</p>
<h2 id="六、-iter-的核心作用"><a href="#六、-iter-的核心作用" class="headerlink" title="六、__iter__ 的核心作用"></a><strong>六、<code>__iter__</code> 的核心作用</strong></h2><p>在Python中，<strong>迭代器协议</strong>要求对象必须同时实现两个方法：</p>
<ol>
<li><code>__iter__()</code>：返回迭代器自身（即 <code>self</code>）</li>
<li><code>__next__()</code>：返回下一个元素，若无元素则抛出 <code>StopIteration</code></li>
</ol>
<p><strong>关键点</strong>：<code>__iter__</code> 的存在是为了让迭代器对象<strong>也能作为可迭代对象使用</strong>。</p>
<h2 id="七、为什么需要-iter-返回自身？"><a href="#七、为什么需要-iter-返回自身？" class="headerlink" title="七、为什么需要 __iter__ 返回自身？"></a><strong>七、为什么需要 <code>__iter__</code> 返回自身？</strong></h2><h3 id="1-支持-for-循环和内置函数"><a href="#1-支持-for-循环和内置函数" class="headerlink" title="1. 支持 for 循环和内置函数"></a><strong>1. 支持 <code>for</code> 循环和内置函数</strong></h3><p>Python的 <code>for</code> 循环、<code>list()</code>、<code>sum()</code> 等内置函数在使用迭代器前，会先调用 <code>iter()</code> 函数将对象转换为迭代器。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">iterator = <span class="built_in">iter</span>(my_list)  <span class="comment"># 等价于调用 my_list.__iter__()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两种写法等价</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterator:  <span class="comment"># 隐式调用 iter(iterator)</span></span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于手动实现的循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        item = iterator.__next__()  <span class="comment"># 手动调用 next</span></span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：当你将迭代器对象传入 <code>for</code> 循环时，Python会先调用 <code>iter(iterator)</code>，此时需要 <code>iterator.__iter__()</code> 返回自身，否则会报错。</p>
<h3 id="2-支持多重迭代"><a href="#2-支持多重迭代" class="headerlink" title="2. 支持多重迭代"></a><strong>2. 支持多重迭代</strong></h3><p>有些场景需要对同一个迭代器进行多次迭代（虽然不常见）。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRange</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 返回自身，支持多重迭代</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; self.n:</span><br><span class="line">            value = self.current</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误示例：重置迭代器状态的错误方式</span></span><br><span class="line">r = MyRange(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r: <span class="built_in">print</span>(i)  <span class="comment"># 输出 0, 1, 2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r: <span class="built_in">print</span>(i)  <span class="comment"># 无输出，因为迭代器已耗尽</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确示例：每次创建新迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRangeFixed</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> MyRangeIterator(self.n)  <span class="comment"># 每次返回新的迭代器实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRangeIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>): <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>): ...</span><br><span class="line"></span><br><span class="line">r = MyRangeFixed(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r: <span class="built_in">print</span>(i)  <span class="comment"># 输出 0, 1, 2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r: <span class="built_in">print</span>(i)  <span class="comment"># 再次输出 0, 1, 2（因为每次都创建新迭代器）</span></span><br></pre></td></tr></table></figure>


<h2 id="八、-iter-何时被调用？"><a href="#八、-iter-何时被调用？" class="headerlink" title="八、__iter__ 何时被调用？"></a><strong>八、<code>__iter__</code> 何时被调用？</strong></h2><ol>
<li><strong>显式调用</strong>：当你手动调用 <code>iter(iterator)</code> 时</li>
<li><strong>隐式调用</strong>：<ul>
<li>使用 <code>for</code> 循环遍历迭代器时</li>
<li>使用内置函数（如 <code>list()</code>、<code>sum()</code>、<code>tuple()</code> 等）处理迭代器时</li>
<li>在需要可迭代对象的地方使用迭代器时（如解包操作 <code>*iterator</code>）</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_iterator = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 创建迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显式调用</span></span><br><span class="line">explicit_iter = <span class="built_in">iter</span>(my_iterator)  <span class="comment"># 调用 my_iterator.__iter__()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐式调用</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_iterator:  <span class="comment"># 隐式调用 iter(my_iterator)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置函数调用</span></span><br><span class="line"><span class="built_in">list</span>(my_iterator)  <span class="comment"># 调用 iter(my_iterator)</span></span><br></pre></td></tr></table></figure>


<h2 id="九、为什么你没看到-iter-被调用？"><a href="#九、为什么你没看到-iter-被调用？" class="headerlink" title="九、为什么你没看到 __iter__ 被调用？"></a><strong>九、为什么你没看到 <code>__iter__</code> 被调用？</strong></h2><p>因为 <code>__iter__</code> 通常是被Python解释器<strong>隐式调用</strong>的，你在代码中看不到它。但如果没有正确实现 <code>__iter__</code>，以下情况会报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BadIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.count &lt; <span class="number">3</span>:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.count</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少 __iter__，无法用于 for 循环</span></span><br><span class="line">bad = BadIterator()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> bad:  <span class="comment"># 报错：TypeError: &#x27;BadIterator&#x27; object is not iterable</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h2 id="十、-iter-的意义"><a href="#十、-iter-的意义" class="headerlink" title="十、__iter__ 的意义"></a><strong>十、<code>__iter__</code> 的意义</strong></h2><ol>
<li><strong>满足迭代器协议</strong>：Python要求迭代器必须同时实现 <code>__iter__</code> 和 <code>__next__</code></li>
<li><strong>支持与语言特性无缝集成</strong>：确保迭代器可以在 <code>for</code> 循环、内置函数等场景中正常工作</li>
<li><strong>区分迭代器和可迭代对象</strong>：<ul>
<li><strong>可迭代对象</strong>（如列表）：<code>__iter__</code> 返回一个新的迭代器</li>
<li><strong>迭代器本身</strong>：<code>__iter__</code> 返回自身（<code>self</code>）</li>
</ul>
</li>
</ol>
<p>如果没有 <code>__iter__</code>，迭代器就无法作为可迭代对象使用，Python的许多语法和函数都将无法正常处理它。</p>
<hr>
<p>看到迭代器跟生成器有这么复杂的功能，那么实际场景当中不免让人想，生成器跟迭代器在循环过程当中可以重置吗？可以反向找到上一个吗？</p>
<p>在 Python 中，<strong>生成器默认是单向、不可逆的</strong>，但可以通过一些技巧实现“回退”或“重置”的效果。让我分情况解释：</p>
<h2 id="十一、标准生成器：无法回退或重置"><a href="#十一、标准生成器：无法回退或重置" class="headerlink" title="十一、标准生成器：无法回退或重置"></a><strong>十一、标准生成器：无法回退或重置</strong></h2><p>生成器函数（使用 <code>yield</code>）或生成器表达式创建的生成器对象，只能向前迭代，无法后退或重置。每次调用 <code>next()</code> 会执行到下一个 <code>yield</code>，状态自动保存，直到生成结束（抛出 <code>StopIteration</code>）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_up_to</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">gen = count_up_to(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># StopIteration（无法回退到 0 或 1）</span></span><br></pre></td></tr></table></figure>


<h2 id="十二、实现“回退”功能的方法"><a href="#十二、实现“回退”功能的方法" class="headerlink" title="十二、实现“回退”功能的方法"></a><strong>十二、实现“回退”功能的方法</strong></h2><h3 id="1-缓存已生成的值（手动回退）"><a href="#1-缓存已生成的值（手动回退）" class="headerlink" title="1. 缓存已生成的值（手动回退）"></a><strong>1. 缓存已生成的值（手动回退）</strong></h3><p>将生成器的输出缓存到列表中，需要回退时直接访问列表。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_up_to</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">gen = count_up_to(<span class="number">3</span>)</span><br><span class="line">cache = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常迭代并缓存</span></span><br><span class="line">cache.append(<span class="built_in">next</span>(gen))  <span class="comment"># 缓存 0</span></span><br><span class="line">cache.append(<span class="built_in">next</span>(gen))  <span class="comment"># 缓存 1</span></span><br><span class="line"><span class="built_in">print</span>(cache)  <span class="comment"># [0, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到之前的值</span></span><br><span class="line"><span class="built_in">print</span>(cache[-<span class="number">1</span>])  <span class="comment"># 1（回退到上一个值）</span></span><br><span class="line"><span class="built_in">print</span>(cache[<span class="number">0</span>])   <span class="comment"># 0（回退到第一个值）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-自定义生成器类（支持双向迭代）"><a href="#2-自定义生成器类（支持双向迭代）" class="headerlink" title="2. 自定义生成器类（支持双向迭代）"></a><strong>2. 自定义生成器类（支持双向迭代）</strong></h3><p>通过实现 <code>__iter__</code> 和 <code>__next__</code> 方法，结合内部状态管理，实现双向迭代。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BidirectionalGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &lt; <span class="built_in">len</span>(self.data):</span><br><span class="line">            value = self.data[self.index]</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prev</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &gt; <span class="number">0</span>:</span><br><span class="line">            self.index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data[self.index]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Already at the beginning&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">gen = BidirectionalGenerator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(gen.prev()) <span class="comment"># 1（回退）</span></span><br></pre></td></tr></table></figure>


<h2 id="十三、实现“重置”功能的方法"><a href="#十三、实现“重置”功能的方法" class="headerlink" title="十三、实现“重置”功能的方法"></a><strong>十三、实现“重置”功能的方法</strong></h2><h3 id="1-每次创建新生成器实例"><a href="#1-每次创建新生成器实例" class="headerlink" title="1. 每次创建新生成器实例"></a><strong>1. 每次创建新生成器实例</strong></h3><p>最简单的方法是每次需要重置时重新调用生成器函数。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_up_to</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">gen = count_up_to(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置：重新创建生成器</span></span><br><span class="line">gen = count_up_to(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 0（从头开始）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-自定义可重置生成器类"><a href="#2-自定义可重置生成器类" class="headerlink" title="2. 自定义可重置生成器类"></a><strong>2. 自定义可重置生成器类</strong></h3><p>通过添加 <code>reset()</code> 方法重置内部状态。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResettableGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &lt; self.n:</span><br><span class="line">            value = self.index</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">gen = ResettableGenerator(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">gen.reset()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 0（重置后从头开始）</span></span><br></pre></td></tr></table></figure>


<h2 id="十四、使用-tee-复制生成器（有限回退）"><a href="#十四、使用-tee-复制生成器（有限回退）" class="headerlink" title="十四、使用 tee 复制生成器（有限回退）"></a><strong>十四、使用 <code>tee</code> 复制生成器（有限回退）</strong></h2><p><code>itertools.tee</code> 可以将一个生成器复制为多个独立的迭代器，允许有限次数的回退。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> tee</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_up_to</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">gen = count_up_to(<span class="number">3</span>)</span><br><span class="line">gen1, gen2 = tee(gen, <span class="number">2</span>)  <span class="comment"># 复制为两个独立迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen1))  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen1))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen2))  <span class="comment"># 0（gen2 独立于 gen1，从头开始）</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>tee</code> 会缓存已生成的值，若原生成器已消耗过多元素，可能导致内存问题。</p>
<h2 id="十五、建议"><a href="#十五、建议" class="headerlink" title="十五、建议"></a><strong>十五、建议</strong></h2><table>
<thead>
<tr>
<th><strong>需求</strong></th>
<th><strong>最佳实现方式</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>少量回退</td>
<td>缓存已生成的值（列表/队列）</td>
<td>数据量较小，需频繁前后移动</td>
</tr>
<tr>
<td>完全重置</td>
<td>重新创建生成器实例或自定义 <code>reset()</code></td>
<td>需多次从头开始迭代</td>
</tr>
<tr>
<td>多分支迭代</td>
<td><code>itertools.tee</code></td>
<td>需要同时维护多个迭代进度</td>
</tr>
</tbody></table>
<p><strong>核心原则</strong>：生成器的设计初衷是<strong>高效处理一次性数据流</strong>，若需要频繁回退或随机访问，建议使用列表等可重复遍历的数据结构。只有在数据量极大且确实需要回退时，才考虑上述优化方法。</p>
<blockquote>
<p>看到以上案例，肯定还有人还有疑问，就是这不是在说生成器么，怎么生成器的class当中没有yield？没有yield的话，这是不是就是歌迭代器类了？不是生成器类了？马上回答这个问题</p>
</blockquote>
<p>这涉及到 Python 中 <strong>生成器(Generator)</strong> 和 <strong>迭代器(Iterator)</strong> 的本质区别。</p>
<h2 id="十六、核心概念区分"><a href="#十六、核心概念区分" class="headerlink" title="十六、核心概念区分"></a><strong>十六、核心概念区分</strong></h2><h3 id="1-生成器（Generator）"><a href="#1-生成器（Generator）" class="headerlink" title="1. 生成器（Generator）"></a><strong>1. 生成器（Generator）</strong></h3><ul>
<li><strong>定义</strong>：一种特殊的迭代器，使用 <strong><code>yield</code> 关键字</strong> 或 <strong>生成器表达式</strong> 创建。</li>
<li><strong>特点</strong>：<ul>
<li>自动实现 <code>__iter__</code> 和 <code>__next__</code> 方法。</li>
<li>状态自动保存（每次 <code>yield</code> 暂停，下次从暂停处继续）。</li>
<li>代码更简洁，无需手动管理状态。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_numbers</span>():  <span class="comment"># 生成器函数（使用 yield）</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">gen = gen_numbers()  <span class="comment"># 创建生成器对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-迭代器（Iterator）"><a href="#2-迭代器（Iterator）" class="headerlink" title="2. 迭代器（Iterator）"></a><strong>2. 迭代器（Iterator）</strong></h3><ul>
<li><strong>定义</strong>：实现了 <strong><code>__iter__</code> 和 <code>__next__</code> 方法</strong> 的对象。</li>
<li><strong>特点</strong>：<ul>
<li>手动管理状态（如维护索引）。</li>
<li>需显式抛出 <code>StopIteration</code>。</li>
<li>代码更复杂，但更灵活。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumIterator</span>:  <span class="comment"># 迭代器类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        self.data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &lt; <span class="built_in">len</span>(self.data):</span><br><span class="line">            value = self.data[self.index]</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">it = NumIterator()  <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>


<h2 id="十七、我们提到的类属于迭代器，而非生成器"><a href="#十七、我们提到的类属于迭代器，而非生成器" class="headerlink" title="十七、我们提到的类属于迭代器，而非生成器"></a><strong>十七、我们提到的类属于迭代器，而非生成器</strong></h2><p>当我编写的类（如 <code>ResettableGenerator</code> 和 <code>BidirectionalGenerator</code>）<strong>没有使用 <code>yield</code> 关键字</strong> 时，它们实际上是 <strong>迭代器类</strong>，而非生成器类。虽然名字中包含“Generator”，但从技术上讲：</p>
<ol>
<li><strong>生成器</strong>：由 <code>yield</code> 或生成器表达式创建，是 Python 内置的特殊类型。</li>
<li><strong>迭代器</strong>：通过手动实现 <code>__iter__</code> 和 <code>__next__</code> 方法创建的普通类。</li>
</ol>
<p><strong>示例对比</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器（使用 yield）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator_example</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器（手动实现协议）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IteratorExample</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; <span class="number">2</span>:</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.current</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure>


<h2 id="十八、为什么会混淆？"><a href="#十八、为什么会混淆？" class="headerlink" title="十八、为什么会混淆？"></a><strong>十八、为什么会混淆？</strong></h2><ol>
<li><strong>生成器是迭代器的子类</strong>：所有生成器都是迭代器（因为自动实现了迭代器协议），但并非所有迭代器都是生成器。</li>
<li><strong>语义习惯</strong>：在日常交流中，有时会用“生成器”泛指任何可迭代对象，导致混淆。</li>
<li><strong>功能重叠</strong>：两者都支持 <code>next()</code> 和 <code>for</code> 循环，但实现方式不同。</li>
</ol>
<h2 id="十九、何时用迭代器？何时用生成器？"><a href="#十九、何时用迭代器？何时用生成器？" class="headerlink" title="十九、何时用迭代器？何时用生成器？"></a><strong>十九、何时用迭代器？何时用生成器？</strong></h2><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>选择</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>简单的一次性数据流</td>
<td>生成器</td>
<td><code>python&lt;br&gt;def read_file_lines(file_path):&lt;br&gt;    with open(file_path) as f:&lt;br&gt;        for line in f:&lt;br&gt;            yield line&lt;br&gt;</code></td>
</tr>
<tr>
<td>复杂状态管理（如双向迭代）</td>
<td>迭代器</td>
<td>自定义类实现 <code>prev()</code> 或 <code>reset()</code> 方法</td>
</tr>
<tr>
<td>需要实现特定接口（如上下文管理器）</td>
<td>迭代器</td>
<td>类中同时实现 <code>__iter__</code> 和 <code>__enter__</code>/<code>__exit__</code></td>
</tr>
</tbody></table>
<h3 id="二十、理解"><a href="#二十、理解" class="headerlink" title="二十、理解"></a><strong>二十、理解</strong></h3><ol>
<li><strong>生成器</strong>：用 <code>yield</code> 创建，自动实现迭代器协议，代码简洁。</li>
<li><strong>迭代器</strong>：手动实现 <code>__iter__</code> 和 <code>__next__</code>，更灵活但代码复杂。</li>
<li><strong>选择标准</strong>：优先用生成器（代码简洁），需要高级控制时用迭代器。</li>
</ol>
<p>当你需要“回退”或“重置”功能时，由于生成器本身不支持这些特性，只能通过迭代器类手动实现。虽然名称可能叫“Generator”，但本质上是迭代器。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器</title>
    <url>/2022/04/29/%E8%AF%AD%E6%B3%95-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">&#x27;all&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="装饰器-Decorators"><a href="#装饰器-Decorators" class="headerlink" title="装饰器(Decorators)"></a>装饰器(Decorators)</h2><p>装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hi</span>(<span class="params">name=<span class="string">&quot; world&quot;</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name</span><br><span class="line">hi()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span></span><br><span class="line">greet = hi</span><br><span class="line"><span class="comment"># 我们这里没有在使用小括号，因为并不是在调用hi函数</span></span><br><span class="line"><span class="comment"># 而是在将它放在greet变量里头。尝试运行下这个</span></span><br><span class="line">greet()</span><br><span class="line"><span class="comment"># 如果删掉旧的hi函数</span></span><br><span class="line"><span class="keyword">del</span> hi</span><br><span class="line"><span class="comment"># hi() # 报错</span></span><br><span class="line"> </span><br><span class="line">greet()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="在函数中定义函数"><a href="#在函数中定义函数" class="headerlink" title="在函数中定义函数"></a>在函数中定义函数</h2><p>刚才那些就是函数的基本知识了。我们来让你的知识更进一步。在 Python 中我们可以在一个函数中定义另一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testfunction</span>(<span class="params">parameter=<span class="string">&quot;info&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;现在会调用里层函数&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;greet函数被调用&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">welcome</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;welcome函数被调用&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gentleman</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gentleman函数被调用&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(greet())</span><br><span class="line">    <span class="built_in">print</span>(welcome())</span><br><span class="line">    gentleman()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数调用结束&quot;</span>)</span><br><span class="line"> </span><br><span class="line">testfunction()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 上面展示了无论何时调用hi(), greet()和welcome()将会同时被调用。</span></span><br><span class="line"><span class="comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span></span><br><span class="line"><span class="comment"># welcome()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">现在会调用里层函数</span><br><span class="line">greet函数被调用</span><br><span class="line">welcome函数被调用</span><br><span class="line">gentleman函数被调用</span><br><span class="line">函数调用结束</span><br></pre></td></tr></table></figure>

<p>可以在函数中定义另外的函数。也就是说可以创建嵌套的函数。现在需要再多学一点，就是函数也能返回函数。</p>
<h2 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h2><p>其实并不需要在一个函数里去执行另一个函数，我们也可以将其作为输出返回出来：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testfunction</span>(<span class="params">parameter=<span class="string">&quot;info&quot;</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;greet函数被调用&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">welcome</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;welcome函数被调用&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parameter == <span class="string">&quot;info&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"></span><br><span class="line">a = testfunction()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span></span><br><span class="line"><span class="comment">#现在试试这个</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a())</span><br><span class="line">testfunction()()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">function</span> testfunction.&lt;locals&gt;.greet at 0x7f9e00638f28&gt;</span><br><span class="line">greet函数被调用</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;greet函数被调用&#x27;</span></span><br></pre></td></tr></table></figure>

<p>再次看看这个代码。在if/else语句中返回greet和welcome，而不是greet()和welcome()。<br>当把一对小括号放在后面，这个函数就会执行；然而如果不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。<br>再稍微多解释点细节:<br>当我们写下a = testfunction()，testfunction()会被执行，而由于name参数默认是info，所以函数greet被返回了。如果我们把语句改为a = testfunction(name = “Alice”)，那么welcome函数将被返回。<br>我们还可以打印出testfunction()()，这会输出greet函数被调用。</p>
<h2 id="将函数作为参数传给另一个函数"><a href="#将函数作为参数传给另一个函数" class="headerlink" title="将函数作为参数传给另一个函数"></a>将函数作为参数传给另一个函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testfunction</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Do_Something_Before_testfunction</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing hi()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(func())</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Do_Something_Before_testfunction(testfunction)</span><br><span class="line">I am doing some boring work before executing hi()</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>现在已经具备所有必需知识来学习装饰器是什么了,装饰器让你在一个函数的前后去执行代码。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>(<span class="params">a_func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapTheFunction</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在执行a_func()之前我正在做一些无聊的工作&quot;</span>)</span><br><span class="line"></span><br><span class="line">        a_func()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在执行a_func()之后我正在做一些无聊的工作&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数2的输出&quot;</span>)</span><br><span class="line"></span><br><span class="line">function2()</span><br><span class="line"><span class="comment">#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span><br><span class="line"></span><br><span class="line">function2 = function1(function2)</span><br><span class="line"><span class="comment">#现在function2被function1包装了</span></span><br><span class="line"></span><br><span class="line">function2()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">函数2的输出</span><br><span class="line">在执行a_func()之前我正在做一些无聊的工作</span><br><span class="line">函数2的输出</span><br><span class="line">在执行a_func()之后我正在做一些无聊的工作</span><br><span class="line">刚刚应用了之前学习到的原理。这正是python中装饰器做的事情！它封装一个函数，并且用这样或者那样的方式来修改它的行为。</span><br><span class="line">现在也许疑惑，在代码里并没有使用@符号？只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用@来运行之前的代码：</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@function1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#@a_new_decorator就是下面这种方式的简写:</span></span><br><span class="line">a_function_requiring_decoration = function1(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在执行a_func()之前我正在做一些无聊的工作</span><br><span class="line">I am the <span class="keyword">function</span> <span class="built_in">which</span> needs some decoration to remove my foul smell</span><br><span class="line">在执行a_func()之后我正在做一些无聊的工作</span><br></pre></td></tr></table></figure>

<p>希望现在对Python装饰器的工作原理有一个基本的理解。如果运行如下代码会存在一个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wrapTheFunction</span><br></pre></td></tr></table></figure>

<p>这并不是想要的！Ouput输出应该是a_function_requiring_decoration。这里的函数被warpTheFunction替代了。它重写了函数的名字和注释文档(docstring)。幸运的是Python提供给一个简单的函数来解决这个问题，那就是functools.wraps。修改上一个例子来使用functools.wraps：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">a_func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapTheFunction</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Hey yo! Decorate me!&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_function_requiring_decoration</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_name</span>(<span class="params">f</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorated</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Function will not run&quot;</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span>(<span class="string">&quot;Function is running&quot;</span>)</span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Function is running</span><br><span class="line">Function will not run</span><br></pre></td></tr></table></figure>

<p>注意： @wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。<br>装饰器在某些地方特别耀眼，使用它可以让一些事情管理起来变得更简单。<br>装饰器可以用于日志管理<br>装饰器可以监控函数运行之前的状态，捕捉函数的运行情况，传入参数等等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logit</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">with_logging</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(func.__name__ + <span class="string">&quot; was called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addition_func</span>(<span class="params">x</span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;Do some math.&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = addition_func(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Output: addition_func was called</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addition_func was called</span><br></pre></td></tr></table></figure>

<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>来想想这个问题，难道@wraps不也是个装饰器吗？<br>但是，它接收一个参数，就像任何普通的函数能做的那样。那么，为什么我们不也那样做呢？<br>这是因为，当使用@my_decorator语法时，是在应用一个以单个函数作为参数的一个包裹函数。记住，Python里每个东西都是一个对象，而且这包括函数！<br>记住了这些，我们可以编写一个能返回一个包裹函数的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logit</span>(<span class="params">logfile=<span class="string">&#x27;out.log&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">logging_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped_function</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            log_string = func.__name__ + <span class="string">&quot; was called&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile，并写入内容</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(logfile, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的logfile</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line">    <span class="keyword">return</span> logging_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc1()</span><br><span class="line"><span class="comment"># Output: myfunc1 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logit(<span class="params">logfile=<span class="string">&#x27;func2.log&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc2()</span><br><span class="line"><span class="comment"># Output: myfunc2 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myfunc1 was called</span><br><span class="line">myfunc2 was called</span><br></pre></td></tr></table></figure>

<h2 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h2><p>现在有了能用于正式环境的logit装饰器，但当应用的某些部分还比较脆弱时，异常也许是需要更紧急关注的事情。比方说有时想打日志到一个文件。而有时想把引起你注意的问题发送到一个email，同时也保留日志，留个记录。这是一个使用继承的场景，但目前为止只看到过用来构建装饰器的函数。<br>幸运的是，类也可以用来构建装饰器。那现在以一个类而不是一个函数的方式，来重新构建logit。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">logit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, logfile=<span class="string">&#x27;out.log&#x27;</span></span>):</span><br><span class="line">        self.logfile = logfile</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):<span class="comment">#类的特殊成员</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped_function</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            log_string = func.__name__ + <span class="string">&quot; was called&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.logfile, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的文件</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># logit只打日志，不做别的</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打印日志&quot;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这个实现有一个附加优势，在于比嵌套函数的方式更加整洁，而且包裹一个函数还是使用跟以前一样的语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">myfunc1()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myfunc1 was called</span><br><span class="line">打印日志</span><br><span class="line">开始</span><br></pre></td></tr></table></figure>

<p>现在，我们给logit创建子类，来添加新的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">email_logit</span>(<span class="title class_ inherited__">logit</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    一个logit的实现版本，可以在函数调用时发送email给管理员</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, email=<span class="string">&#x27;admin@myproject.com&#x27;</span>, *args, **kwargs</span>):</span><br><span class="line">        self.email = email</span><br><span class="line">        <span class="built_in">super</span>(email_logit, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 发送一封email到self.email</span></span><br><span class="line">        <span class="comment"># 这里就不做实现了</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;假设已经发送了邮件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@email_logit()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">myfunc1()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myfunc1 was called</span><br><span class="line">假设已经发送了邮件</span><br><span class="line">开始</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy版本问题导致不可用</title>
    <url>/2024/12/01/%E9%97%AE%E9%A2%98-SQLAlchemy%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E4%B8%8D%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近，我遇到了一个关于SQLAlchemy版本的问题。我尝试使用SQLAlchemy与关系型数据库进行交互，但在某些情况下，它似乎与我的当前环境不兼容。经过一番研究，我发现了SQLAlchemy的两个主要版本——SQLAlchemy 1.x和SQLAlchemy 2.x，并了解了它们之间的区别以及如何解决兼容性问题。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>SQLAlchemy是一个Python库，用于与关系型数据库进行交互。它提供了两个主要版本：SQLAlchemy 1.x和SQLAlchemy 2.x。在这两个版本之间有一些关键区别：</p>
<ol>
<li><p>主要功能变化：SQLAlchemy 2.x引入了一些新的主要功能，例如支持关系、更高级的ORM功能和更好的性能。</p>
</li>
<li><p>兼容性问题：虽然SQLAlchemy 2.x在大多数情况下与SQLAlchemy 1.x兼容，但在某些情况下，例如使用特定数据库引擎或特定ORM功能时，可能会遇到兼容性问题。在这种情况下，您可能需要升级或降级您的SQLAlchemy版本以解决兼容性问题。</p>
</li>
</ol>
<p>要了解更多信息，请查看SQLAlchemy的官方文档，特别是SQLAlchemy 2.0的迁移指南：<a href="https://docs.sqlalchemy.org/en/14/changelog/migration_20.html">https://docs.sqlalchemy.org/en/14/changelog/migration_20.html</a></p>
<p>如果您遇到与SQLAlchemy版本相关的问题，请确保您的环境（例如数据库引擎、操作系统等）与您尝试使用的SQLAlchemy版本兼容。如果您无法解决问题，请尝试升级或降级SQLAlchemy版本，或考虑使用其他数据库库。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>要解决SQLAlchemy版本问题，您可以尝试以下几种方法：</p>
<ol>
<li>升级或降级SQLAlchemy版本：如果您遇到与SQLAlchemy版本相关的问题，您可以尝试升级或降级SQLAlchemy版本。您可以使用pip命令来升级或降级SQLAlchemy版本，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade sqlalchemy</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install sqlalchemy==1.4.23</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>检查兼容性问题：如果您遇到与SQLAlchemy版本相关的问题，请检查您的环境（例如数据库引擎、操作系统等）与您尝试使用的SQLAlchemy版本是否兼容。您可以在SQLAlchemy的官方文档中找到有关兼容性的信息。</p>
</li>
<li><p>使用其他数据库库：如果您无法解决与SQLAlchemy版本相关的问题，您可以考虑使用其他数据库库，例如PyMySQL、psycopg2等。这些库提供了与SQLAlchemy类似的功能，但可能更易于使用或与您的环境兼容。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlalchemy库的2.0版本问题</title>
    <url>/2024/04/07/%E9%97%AE%E9%A2%98-sqlalchemy%E5%BA%93%E7%9A%842-0%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在更新项目的python库的时候，更新完毕后使用sqlalchemy执行engine.execute语句的时候报错，然后发现新的sqlalchemy中根本没有这个方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AttributeError: <span class="string">&#x27;Engine&#x27;</span> object has no attribute <span class="string">&#x27;execute&#x27;</span></span><br></pre></td></tr></table></figure>

<p>找了半天原因发现sqlalchemy2.0后取消了engine.execute方法。需要通过Connection中的execute方法去执行sql语句，而且需要通过sqlalchemy.text对象去传递sql语句。好消息是1.0其实并没有放弃更新，这个实际上已经是两个库了，不能算一个东西，就像是python2跟python3的差距一样大。</p>
<p>2.0版本写法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from sqlalchemy import create_engine, text</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">&quot;配置信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">sqltext = text(<span class="string">&quot;select * from ...;&quot;</span>)</span><br><span class="line">conn = engine.connect()</span><br><span class="line">conn.execute(sqltext)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>关于opencv的libGL报错</title>
    <url>/2024/04/07/%E9%97%AE%E9%A2%98-%E5%85%B3%E4%BA%8Eopencv%E7%9A%84libGL%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>在配云端GPU服务器时，出现这个错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">File <span class="string">&quot;/usr/local/lib/python3.6/dist-packages/cv2/__init__.py&quot;</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from .cv2 import *</span><br><span class="line">ImportError: libGL.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>解决方法（easy）</p>
<p><a href="https://github.com/Korea-Health-Datathon/KHD2020/issues/78">setup 에서 cv2 설치 오류가 발생합니다. · Issue #78 · Korea-Health-Datathon/KHD2020 · GitHub</a></p>
<ul>
<li>卸载 <code>pip uninstall opencv-python</code></li>
<li>安装 <code>pip install opencv-python-headless</code></li>
</ul>
<p>在Stack Overflow上有其他回答</p>
<h2 id="Ubuntu系统"><a href="#Ubuntu系统" class="headerlink" title="Ubuntu系统"></a>Ubuntu系统</h2><p>在docker中出错,将以下行添加到您的 Dockerfile：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu系统</span></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install ffmpeg libsm6 libxext6  -y</span><br></pre></td></tr></table></figure>

<p>这些命令安装通常存在于本地计算机上的 cv2 依赖项，但可能会在您的 Docker 容器中丢失，从而导致问题。</p>
<p>libGL.so.1由 package 提供libgl1，所以添加一下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install libgl1</span><br></pre></td></tr></table></figure>

<p>还有一些解决方案，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">环境是ubuntu16.04。指令：</span><br><span class="line">apt update</span><br><span class="line">apt install libgl1-mesa-glx</span><br></pre></td></tr></table></figure>

<p>这里说明了这个包的作用个，然后说了是Ubuntu16.0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"><span class="comment"># 安装libgl库</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y libgl1-mesa-glx</span><br><span class="line"><span class="comment"># 安装其他必要的软件</span></span><br><span class="line">RUN apt-get install -y software-properties-common &amp;&amp; add-apt-repository ppa:jonathonf/python-3.6 &amp;&amp; apt-get update &amp;&amp; apt-get install -y python3.6 python3-setuptools python3-pip</span><br><span class="line"><span class="comment"># 设置Python3.6为默认版本</span></span><br><span class="line">RUN <span class="built_in">ln</span> -sf /usr/bin/python3.6 /usr/bin/python3 &amp;&amp; <span class="built_in">ln</span> -sf /usr/bin/python3 /usr/bin/python</span><br><span class="line"><span class="comment"># 安装其他必要的Python库</span></span><br><span class="line">RUN pip3 install --no-cache-dir numpy opencv-python</span><br></pre></td></tr></table></figure>

<h2 id="CentOS系统"><a href="#CentOS系统" class="headerlink" title="CentOS系统"></a>CentOS系统</h2><p>如果您使用的是 CentOS、RHEL、Fedora 或其他使用 的 linux 发行版yum，您将需要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install mesa-libGL -y</span><br></pre></td></tr></table></figure>

<p>注意，这个安装包名和linux系统需要对应。否则，No package libgl1 available.当前yum源找不到所需包，安装epel源即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure>

<p>最终放在Dockerfile里是这样解决的，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">USER root</span><br><span class="line">RUN yum install -y mesa-libGL</span><br><span class="line">RUN yum install -y mesa-libGL-devel <span class="comment"># 安装这个最终解决</span></span><br></pre></td></tr></table></figure>

<p><a href="https://link.csdn.net/?target=https://github.com/conda-forge/pygridgen-feedstock/issues/10">ImportError: libGL.so.1: cannot open shared object file: No such file or directory · Issue #10 · conda-forge/pygridgen-feedstock · GitHub</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决robo3t无法翻页的错误</title>
    <url>/2023/10/25/%E9%97%AE%E9%A2%98-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3robo3t%E6%97%A0%E6%B3%95%E7%BF%BB%E9%A1%B5%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>问题:</p>
<p>robo3t mongo工具 windows 版本连接mongo，翻页提示如下报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The ntoreturn find <span class="built_in">command</span> parameter is not supported when FCV &gt;= 5.1</span><br></pre></td></tr></table></figure>

<p>解决方案:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.adminCommand(&#123;setFeatureCompatibilityVersion: <span class="string">&quot;5.0&quot;</span>,&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>始化COM库</title>
    <url>/2024/12/01/%E9%97%AE%E9%A2%98-%E5%A7%8B%E5%8C%96COM%E5%BA%93/</url>
    <content><![CDATA[<p>COM 是一种微软的软件组件技术，它允许不同的应用程序之间进行通信和交互。在 Windows 操作系统中，许多应用程序和服务都使用 COM 来实现其功能。</p>
<p>pythoncom.CoInitialize() 在 Python 程序中的作用是初始化 COM（Component Object Model）库。</p>
<p>当你在 Python 程序中使用 pythoncom.CoInitialize() 时，你是在告诉 Python 解释器需要初始化 COM 库，以便能够使用 COM 相关的功能。这通常在以下情况下需要：</p>
<ul>
<li><p>使用 COM 库：如果你需要在 Python 程序中使用 COM 库来与其他应用程序或服务进行交互，你需要首先初始化 COM 库。</p>
</li>
<li><p>多线程环境：在多线程环境中，每个线程都需要独立地初始化 COM 库。如果你在多线程程序中使用 COM，你需要在每个线程中调用 pythoncom.CoInitialize()。</p>
</li>
<li><p>避免冲突：COM 库的初始化是线程安全的，但在同一线程中多次初始化可能会导致问题。因此，通常建议在程序开始时调用一次 pythoncom.CoInitialize()，并在程序结束时调用 pythoncom.CoUninitialize() 来清理资源。</p>
</li>
</ul>
<p>如果 pythoncom.CoInitialize() 是在一个循环中被调用，这可能是因为程序需要在每个循环迭代中处理 COM 相关的任务，或者是因为程序需要在多个线程中并行处理 COM 任务。然而，频繁地初始化和清理 COM 库可能会影响程序的性能，因此通常建议只在必要时初始化 COM 库，并在不再需要时及时清理。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>无联网下载谷歌浏览器</title>
    <url>/2024/04/07/%E9%97%AE%E9%A2%98-%E6%97%A0%E8%81%94%E7%BD%91%E4%B8%8B%E8%BD%BD%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<p>最近因为swagger的更新，需要在内网更新谷歌浏览器，但是真到下载的时候发现官网下载的安装包都是需要联网安装的，一下子拔我搞蒙了。翻了一下，也没有翻到下载完整安装包的地址，又不想去一些奇怪的网站下载，因此通过自己搜索找到了一个地址：<a href="https://www.google.cn/chrome/index.html?standalone=1">https://www.google.cn/chrome/index.html?standalone=1</a></p>
<hr>
<p>Standalone这个单词，它本身的意思就是脱机的，单独的意思，即不依赖网络而存在的本地安装版本。不仅是在IE 8浏览器中，在其他浏览器中我们想要下载本地安装包时也都可以采用这个方法。这个真的是一个很小的问题，但是耽误了我十多分钟，因此记录一下，避免以后更新的时候又要来找一遍。</p>
]]></content>
      <categories>
        <category>琐事</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>fstapi后台任务</title>
    <url>/2024/12/01/%EF%BC%88fstapi%EF%BC%89%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>在现代的 Web 开发中，后台任务处理是一个常见的需求。FastAPI 提供了一个非常方便的功能，名为 <code>BackgroundTasks</code>，它允许在处理请求后执行一些后台任务。这些任务对于不需要即时返回结果的操作非常有用，比如发送电子邮件、日志记录、数据缓存等。</p>
<h2 id="BackgroundTasks-的基本使用"><a href="#BackgroundTasks-的基本使用" class="headerlink" title="BackgroundTasks 的基本使用"></a>BackgroundTasks 的基本使用</h2><p>首先，看看如何在 FastAPI 中使用 <code>BackgroundTasks</code>。</p>
<ol>
<li><strong>导入 BackgroundTasks</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, BackgroundTasks</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>定义后台任务函数</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">some_background_task</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="comment"># 后台任务的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;后台任务执行，参数：<span class="subst">&#123;arg1&#125;</span>, <span class="subst">&#123;arg2&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>在路径操作函数中添加后台任务</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/background_task/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">background_task</span>(<span class="params">background_tasks: BackgroundTasks</span>):</span><br><span class="line">    background_tasks.add_task(some_background_task, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;后台任务添加成功&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当客户端发送 POST 请求到 <code>/background_task/</code> 路径时，<code>some_background_task</code> 函数将作为一个后台任务被添加，并在主函数执行完毕后开始运行。</p>
<h2 id="BackgroundTasks-是并行的吗？"><a href="#BackgroundTasks-是并行的吗？" class="headerlink" title="BackgroundTasks 是并行的吗？"></a>BackgroundTasks 是并行的吗？</h2><p>关于 <code>BackgroundTasks</code> 的并行性，这是一个常见的问题。答案是，<code>BackgroundTasks</code> 默认情况下是顺序执行的，而不是并行的。这意味着，即使你添加了多个后台任务，它们也会按照添加的顺序一个接一个地执行。</p>
<p>然而，如果你需要并行执行后台任务，FastAPI 也支持这一点。你可以通过定义异步的后台任务函数来实现。</p>
<h2 id="使用异步后台任务实现并行执行"><a href="#使用异步后台任务实现并行执行" class="headerlink" title="使用异步后台任务实现并行执行"></a>使用异步后台任务实现并行执行</h2><p>以下是如何使用异步后台任务的示例：</p>
<ol>
<li><strong>定义异步后台任务函数</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">some_background_task</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="comment"># 异步后台任务的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;异步后台任务执行，参数：<span class="subst">&#123;arg1&#125;</span>, <span class="subst">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟异步操作</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在路径操作函数中添加异步后台任务</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/background_tasks_async/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">background_tasks_async</span>(<span class="params">background_tasks: BackgroundTasks</span>):</span><br><span class="line">    background_tasks.add_task(some_background_task, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;异步后台任务添加成功&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>some_background_task</code> 是一个异步函数，它将被并行执行，前提是 FastAPI 应用是在支持异步的 ASGI 服务器上运行的（例如 Uvicorn）。</p>
<p>请注意，即使任务是异步的，它们仍然会在单个进程或线程中按顺序添加到事件循环中，由事件循环来调度它们的执行。这意味着，尽管任务可以并发运行，但它们并不是在多个 CPU 核心上真正并行执行的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>FastAPI 的 <code>BackgroundTasks</code> 提供了一种简单而有效的方式来处理后台任务。虽然它默认是顺序执行的，但通过使用异步函数，可以实现任务的并行执行。这使得 FastAPI 成为构建高效、可扩展的 Web 应用的理想选择。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>(fastapi八)如何捕获一些特殊的状态码</title>
    <url>/2024/07/24/%EF%BC%88fastapi%E5%85%AB%EF%BC%89-%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<!-- [text](https://blog.csdn.net/weixin_36179862/article/details/110507491) -->

<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>在 Python 中，<code>Exception</code> 是所有内置异常的基类。通过继承 <code>Exception</code>，你可以创建自定义的异常类型，以便在代码中处理特定的错误情况。以下是对 <code>Exception</code> 的详细解释以及一些高级案例。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h4><p>你可以通过继承 <code>Exception</code> 来创建自定义异常类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message: <span class="built_in">str</span></span>):</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.message</span><br></pre></td></tr></table></figure>

<h4 id="抛出自定义异常"><a href="#抛出自定义异常" class="headerlink" title="抛出自定义异常"></a>抛出自定义异常</h4><p>在函数中，你可以使用 <code>raise</code> 关键字抛出自定义异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyCustomError(<span class="string">&quot;Cannot divide by zero&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br></pre></td></tr></table></figure>

<h4 id="捕获自定义异常"><a href="#捕获自定义异常" class="headerlink" title="捕获自定义异常"></a>捕获自定义异常</h4><p>你可以使用 <code>try</code> 和 <code>except</code> 块来捕获并处理自定义异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = divide(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> MyCustomError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Caught an exception: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="高级案例"><a href="#高级案例" class="headerlink" title="高级案例"></a>高级案例</h3><h4 id="1-带有详细信息的自定义异常"><a href="#1-带有详细信息的自定义异常" class="headerlink" title="1. 带有详细信息的自定义异常"></a>1. 带有详细信息的自定义异常</h4><p>你可以为自定义异常添加更多的属性，以便在捕获时提供更多的上下文信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message: <span class="built_in">str</span>, code: <span class="built_in">int</span></span>):</span><br><span class="line">        self.message = message</span><br><span class="line">        self.code = code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Error <span class="subst">&#123;self.code&#125;</span>: <span class="subst">&#123;self.message&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-使用自定义异常进行错误处理"><a href="#2-使用自定义异常进行错误处理" class="headerlink" title="2. 使用自定义异常进行错误处理"></a>2. 使用自定义异常进行错误处理</h4><p>在处理复杂逻辑时，你可以使用自定义异常来区分不同的错误类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidInputError</span>(<span class="title class_ inherited__">MyCustomError</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(message, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InternalServerError</span>(<span class="title class_ inherited__">MyCustomError</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(message, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">raise</span> InvalidInputError(<span class="string">&quot;Input data is empty&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 处理数据</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> InternalServerError(<span class="string">f&quot;An internal error occurred: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-捕获多个自定义异常"><a href="#3-捕获多个自定义异常" class="headerlink" title="3. 捕获多个自定义异常"></a>3. 捕获多个自定义异常</h4><p>你可以使用多个 <code>except</code> 块来捕获不同的自定义异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = divide(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> InvalidInputError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Invalid input: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> InternalServerError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Internal server error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Exception</code> 是 Python 中用于处理异常的基础类。通过创建自定义异常，你可以更好地控制错误处理逻辑，提高代码的可读性和可维护性。在处理复杂逻辑时，使用自定义异常可以更清晰地区分不同的错误类型，并为其提供详细的上下文信息。</p>
<h2 id="HTTPException"><a href="#HTTPException" class="headerlink" title="HTTPException"></a>HTTPException</h2><p><code>HTTPException</code> 是 FastAPI 中用于抛出 HTTP 错误的异常类。它允许你定义自定义的 HTTP 响应状态码和响应体，从而提供更灵活的错误处理机制。下面是关于 <code>HTTPException</code> 的详细解释：</p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>HTTPException</code> 的基本用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> item_id == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">418</span>, detail=<span class="string">&quot;This item is a teapot&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当 <code>item_id</code> 为 3 时，会抛出一个 <code>HTTPException</code>，状态码为 418（这是一个 HTTP 状态码，表示“我是一个茶壶”）。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>HTTPException</code> 构造函数接受以下参数：</p>
<ul>
<li><code>status_code</code>：HTTP 状态码，例如 404、500 等。</li>
<li><code>detail</code>：错误详情，通常是一个字符串，用于描述错误原因。</li>
<li><code>headers</code>：一个字典，包含额外的 HTTP 响应头。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一些使用 <code>HTTPException</code> 的示例：</p>
<h4 id="1-抛出-404-错误"><a href="#1-抛出-404-错误" class="headerlink" title="1. 抛出 404 错误"></a>1. 抛出 404 错误</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> item_id == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;Item not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-抛出-400-错误并添加自定义头"><a href="#2-抛出-400-错误并添加自定义头" class="headerlink" title="2. 抛出 400 错误并添加自定义头"></a>2. 抛出 400 错误并添加自定义头</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> item_id &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=<span class="number">400</span>,</span><br><span class="line">            detail=<span class="string">&quot;Item ID must be a positive integer&quot;</span>,</span><br><span class="line">            headers=&#123;<span class="string">&quot;X-Error&quot;</span>: <span class="string">&quot;Invalid-Item-ID&quot;</span>&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-抛出-500-错误并添加多个头"><a href="#3-抛出-500-错误并添加多个头" class="headerlink" title="3. 抛出 500 错误并添加多个头"></a>3. 抛出 500 错误并添加多个头</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> item_id == <span class="number">999</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=<span class="number">500</span>,</span><br><span class="line">            detail=<span class="string">&quot;Internal server error&quot;</span>,</span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&quot;X-Error&quot;</span>: <span class="string">&quot;Internal-Error&quot;</span>,</span><br><span class="line">                <span class="string">&quot;X-Internal-Error-Code&quot;</span>: <span class="string">&quot;500-001&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h3><p>FastAPI 允许你自定义异常处理逻辑，以便在捕获到 <code>HTTPException</code> 时执行特定的操作。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.exception_handler(<span class="params">HTTPException</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">http_exception_handler</span>(<span class="params">request: Request, exc: HTTPException</span>):</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(</span><br><span class="line">        status_code=exc.status_code,</span><br><span class="line">        content=&#123;<span class="string">&quot;message&quot;</span>: exc.detail&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> item_id == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">418</span>, detail=<span class="string">&quot;This item is a teapot&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当捕获到 <code>HTTPException</code> 时，会返回一个 JSON 响应，而不是默认的 HTML 响应。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>HTTPException</code> 是 FastAPI 中一个非常有用的工具，它允许你抛出自定义的 HTTP 错误，并控制响应的状态码、详情和头信息。通过自定义异常处理，你可以进一步优化错误处理逻辑，提高应用的健壮性和用户体验。</p>
<h2 id="RequestValidationError"><a href="#RequestValidationError" class="headerlink" title="RequestValidationError"></a>RequestValidationError</h2><p><code>RequestValidationError</code> 是 FastAPI 中用于处理请求验证错误的异常类。当请求中的数据不符合 OpenAPI 或 Pydantic 模型定义时，FastAPI 会抛出这个异常。通过捕获和处理 <code>RequestValidationError</code>，你可以向客户端返回详细的验证错误信息。</p>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>RequestValidationError</code> 通常在请求处理函数中自动抛出，但你也可以手动抛出它来处理特定的验证错误。以下是一个基本示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> RequestValidationError</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">q: <span class="built_in">str</span> = Query(<span class="params">..., min_length=<span class="number">3</span></span>)</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>q</code> 参数的长度小于 3，FastAPI 会自动抛出 <code>RequestValidationError</code>。</p>
<h3 id="自定义异常处理-1"><a href="#自定义异常处理-1" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h3><p>你可以通过自定义异常处理来捕获和处理 <code>RequestValidationError</code>。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> RequestValidationError</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.exception_handler(<span class="params">RequestValidationError</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">validation_exception_handler</span>(<span class="params">request: Request, exc: RequestValidationError</span>):</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(</span><br><span class="line">        status_code=<span class="number">422</span>,</span><br><span class="line">        content=&#123;<span class="string">&quot;detail&quot;</span>: exc.errors()&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">q: <span class="built_in">str</span> = Query(<span class="params">..., min_length=<span class="number">3</span></span>)</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当捕获到 <code>RequestValidationError</code> 时，会返回一个 JSON 响应，包含详细的验证错误信息。</p>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p><code>RequestValidationError</code> 的主要属性是 <code>errors</code>，它是一个包含所有验证错误的列表。每个错误都是一个字典，包含以下字段：</p>
<ul>
<li><code>loc</code>：错误的位置，通常是一个元组，表示模型路径。</li>
<li><code>msg</code>：错误消息，描述了验证失败的原因。</li>
<li><code>type</code>：错误类型，表示验证失败的具体原因。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下是一些使用 <code>RequestValidationError</code> 的示例：</p>
<h4 id="1-抛出自定义验证错误"><a href="#1-抛出自定义验证错误" class="headerlink" title="1. 抛出自定义验证错误"></a>1. 抛出自定义验证错误</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> RequestValidationError</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">q: <span class="built_in">str</span> = Query(<span class="params">..., min_length=<span class="number">3</span></span>)</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> RequestValidationError([&#123;<span class="string">&quot;loc&quot;</span>: (<span class="string">&quot;query&quot;</span>, <span class="string">&quot;q&quot;</span>), <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Query must be at least 3 characters long&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string.min_length&quot;</span>&#125;])</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-捕获并处理验证错误"><a href="#2-捕获并处理验证错误" class="headerlink" title="2. 捕获并处理验证错误"></a>2. 捕获并处理验证错误</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"><span class="keyword">from</span> fastapi.exceptions <span class="keyword">import</span> RequestValidationError</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.exception_handler(<span class="params">RequestValidationError</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">validation_exception_handler</span>(<span class="params">request: Request, exc: RequestValidationError</span>):</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(</span><br><span class="line">        status_code=<span class="number">422</span>,</span><br><span class="line">        content=&#123;<span class="string">&quot;detail&quot;</span>: exc.errors()&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">q: <span class="built_in">str</span> = Query(<span class="params">..., min_length=<span class="number">3</span></span>)</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> RequestValidationError([&#123;<span class="string">&quot;loc&quot;</span>: (<span class="string">&quot;query&quot;</span>, <span class="string">&quot;q&quot;</span>), <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Query must be at least 3 characters long&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string.min_length&quot;</span>&#125;])</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>RequestValidationError</code> 是 FastAPI 中一个非常有用的工具，它允许你捕获和处理请求验证错误，并向客户端返回详细的错误信息。通过自定义异常处理，你可以进一步优化错误处理逻辑，提高应用的健壮性和用户体验。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>fastapi</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
</search>
